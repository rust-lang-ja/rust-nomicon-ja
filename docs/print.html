<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">はじめに</a></li><li class="chapter-item expanded "><a href="meet-safe-and-unsafe.html"><strong aria-hidden="true">1.</strong> 安全と危険のご紹介</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="safe-unsafe-meaning.html"><strong aria-hidden="true">1.1.</strong> 安全と危険の相互作用</a></li><li class="chapter-item expanded "><a href="working-with-unsafe.html"><strong aria-hidden="true">1.2.</strong> Unsafe と連携する</a></li></ol></li><li class="chapter-item expanded "><a href="data.html"><strong aria-hidden="true">2.</strong> データレイアウト</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="repr-rust.html"><strong aria-hidden="true">2.1.</strong> repr(Rust)</a></li><li class="chapter-item expanded "><a href="exotic-sizes.html"><strong aria-hidden="true">2.2.</strong> 奇妙なサイズの型</a></li><li class="chapter-item expanded "><a href="other-reprs.html"><strong aria-hidden="true">2.3.</strong> 代替メモリレイアウト</a></li></ol></li><li class="chapter-item expanded "><a href="ownership.html"><strong aria-hidden="true">3.</strong> 所有権とライフタイム</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">3.1.</strong> リファレンス</a></li><li class="chapter-item expanded "><a href="lifetimes.html"><strong aria-hidden="true">3.2.</strong> ライフタイム</a></li><li class="chapter-item expanded "><a href="lifetime-mismatch.html"><strong aria-hidden="true">3.3.</strong> ライフタイムシステムの限界</a></li><li class="chapter-item expanded "><a href="lifetime-elision.html"><strong aria-hidden="true">3.4.</strong> ライフタイムの省略</a></li><li class="chapter-item expanded "><a href="unbounded-lifetimes.html"><strong aria-hidden="true">3.5.</strong> 無制限のライフタイム</a></li><li class="chapter-item expanded "><a href="hrtb.html"><strong aria-hidden="true">3.6.</strong> 高階トレイト境界</a></li><li class="chapter-item expanded "><a href="subtyping.html"><strong aria-hidden="true">3.7.</strong> Subtyping and Variance</a></li><li class="chapter-item expanded "><a href="dropck.html"><strong aria-hidden="true">3.8.</strong> Drop Check</a></li><li class="chapter-item expanded "><a href="phantom-data.html"><strong aria-hidden="true">3.9.</strong> PhantomData</a></li><li class="chapter-item expanded "><a href="borrow-splitting.html"><strong aria-hidden="true">3.10.</strong> 借用の分割</a></li></ol></li><li class="chapter-item expanded "><a href="conversions.html"><strong aria-hidden="true">4.</strong> 型変換</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="coercions.html"><strong aria-hidden="true">4.1.</strong> 型強制</a></li><li class="chapter-item expanded "><a href="dot-operator.html"><strong aria-hidden="true">4.2.</strong> ドットオペレータ</a></li><li class="chapter-item expanded "><a href="casts.html"><strong aria-hidden="true">4.3.</strong> キャスト</a></li><li class="chapter-item expanded "><a href="transmutes.html"><strong aria-hidden="true">4.4.</strong> トランスミュート</a></li></ol></li><li class="chapter-item expanded "><a href="uninitialized.html"><strong aria-hidden="true">5.</strong> 初期化されないメモリ</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="checked-uninit.html"><strong aria-hidden="true">5.1.</strong> チェックされるメモリ</a></li><li class="chapter-item expanded "><a href="drop-flags.html"><strong aria-hidden="true">5.2.</strong> ドロップフラグ</a></li><li class="chapter-item expanded "><a href="unchecked-uninit.html"><strong aria-hidden="true">5.3.</strong> チェックされないメモリ</a></li></ol></li><li class="chapter-item expanded "><a href="obrm.html"><strong aria-hidden="true">6.</strong> 所有権に基づいたリソース管理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="constructors.html"><strong aria-hidden="true">6.1.</strong> コンストラクタ</a></li><li class="chapter-item expanded "><a href="destructors.html"><strong aria-hidden="true">6.2.</strong> Destructors</a></li><li class="chapter-item expanded "><a href="leaking.html"><strong aria-hidden="true">6.3.</strong> Leaking</a></li></ol></li><li class="chapter-item expanded "><a href="unwinding.html"><strong aria-hidden="true">7.</strong> 巻き戻し</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="exception-safety.html"><strong aria-hidden="true">7.1.</strong> 例外安全性</a></li><li class="chapter-item expanded "><a href="poisoning.html"><strong aria-hidden="true">7.2.</strong> Poisoning</a></li></ol></li><li class="chapter-item expanded "><a href="concurrency.html"><strong aria-hidden="true">8.</strong> 並行性</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="races.html"><strong aria-hidden="true">8.1.</strong> Races</a></li><li class="chapter-item expanded "><a href="send-and-sync.html"><strong aria-hidden="true">8.2.</strong> Send and Sync</a></li><li class="chapter-item expanded "><a href="atomics.html"><strong aria-hidden="true">8.3.</strong> Atomics</a></li></ol></li><li class="chapter-item expanded "><a href="vec.html"><strong aria-hidden="true">9.</strong> Implementing Vec</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="vec-layout.html"><strong aria-hidden="true">9.1.</strong> Layout</a></li><li class="chapter-item expanded "><a href="vec-alloc.html"><strong aria-hidden="true">9.2.</strong> Allocating</a></li><li class="chapter-item expanded "><a href="vec-push-pop.html"><strong aria-hidden="true">9.3.</strong> Push and Pop</a></li><li class="chapter-item expanded "><a href="vec-dealloc.html"><strong aria-hidden="true">9.4.</strong> Deallocating</a></li><li class="chapter-item expanded "><a href="vec-deref.html"><strong aria-hidden="true">9.5.</strong> Deref</a></li><li class="chapter-item expanded "><a href="vec-insert-remove.html"><strong aria-hidden="true">9.6.</strong> Insert and Remove</a></li><li class="chapter-item expanded "><a href="vec-into-iter.html"><strong aria-hidden="true">9.7.</strong> IntoIter</a></li><li class="chapter-item expanded "><a href="vec-raw.html"><strong aria-hidden="true">9.8.</strong> RawVec</a></li><li class="chapter-item expanded "><a href="vec-drain.html"><strong aria-hidden="true">9.9.</strong> Drain</a></li><li class="chapter-item expanded "><a href="vec-zsts.html"><strong aria-hidden="true">9.10.</strong> Handling Zero-Sized Types</a></li><li class="chapter-item expanded "><a href="vec-final.html"><strong aria-hidden="true">9.11.</strong> Final Code</a></li></ol></li><li class="chapter-item expanded "><a href="arc-and-mutex.html"><strong aria-hidden="true">10.</strong> Implementing Arc and Mutex</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- The Rustonomicon -->
<h1><a class="header" href="#rust-裏本" id="rust-裏本">Rust 裏本</a></h1>
<!-- The Dark Arts of Advanced and Unsafe Rust Programming -->
<h4><a class="header" href="#高度で危険な-rust-programming-のための闇の技法" id="高度で危険な-rust-programming-のための闇の技法">高度で危険な Rust Programming のための闇の技法</a></h4>
<!-- NOTE: This is a draft document, and may contain serious errors -->
<h1><a class="header" href="#note-この文書はドラフトです重大な間違いを含んでいるかもしれません" id="note-この文書はドラフトです重大な間違いを含んでいるかもしれません">NOTE: この文書はドラフトです。重大な間違いを含んでいるかもしれません。</a></h1>
<!--
Instead of the programs I had hoped for, there came only a shuddering blackness and ineffable loneliness; and I saw at last a fearful truth which no one had ever dared to breathe before — the unwhisperable secret of secrets — The fact that this language of stone and stridor is not a sentient perpetuation of Rust as London is of Old London and Paris of Old Paris, but that it is in fact quite unsafe, its sprawling body imperfectly embalmed and infested with queer animate things which have nothing to do with it as it was in compilation.
-->
<blockquote>
<p>私に与えられたのは、望んだようなプログラムではなく、身を震わせるような暗黒と言い表せないような孤独であった。そして私はついに、誰ひとり口にしようともしなかった恐ろしい真実、ささやくことすらできない神秘中の神秘を目にしたのだ。石のように硬く、耳障りな音をたてるこの言語は、ロンドンが古きロンドンではなく、パリが古きパリではないように、Rust の御代をとこしえにするものではなく、実はきわめて危険で、不完全に防腐処理された、だらしなく寝そべった死体だったのだ。そこにはコンパイル時に生まれた奇妙な生き物たちが所在なさげに蔓延っていた。</p>
<p>（訳注: H.P. ラヴクラフトの小説「<a href="http://quotes.yourdictionary.com/author/h-p-lovecraft/172934">あの男</a>」のパロディのようです。）</p>
</blockquote>
<!--
This book digs into all the awful details that are necessary to understand in order to write correct Unsafe Rust programs. Due to the nature of this problem, it may lead to unleashing untold horrors that shatter your psyche into a billion infinitesimal fragments of despair.
-->
<p>この本は、危険な Rust プログラムを正しく書くために理解しなくてはいけない、不愉快な詳細について詳しく見ていきます。このような性質上、この文書は今まで語られることのなかった恐怖を解き放ち、あなたの精神を何十億もの絶望のかけらに砕いてしまうかもしれません。</p>
<!--
Should you wish a long and happy career of writing Rust programs, you should turn back now and forget you ever saw this book. It is not necessary. However if you intend to write unsafe code -- or just want to dig into the guts of the language -- this book contains invaluable information.
-->
<p>もし貴方が Rust とともに長く幸せな人生を歩みたいと望むなら、今すぐに背を向けて、この本を見てしまったことを忘れるのです。貴方には必要ないのですから。しかし、危険なコードを書く意思がもしも貴方にあるのなら、もしくはこの言語の最重要部にただ踏み込んでみたいのなら、この本は代えがたい情報をもたらすでしょう。</p>
<!--
Unlike [The Book][trpl] we will be assuming considerable prior knowledge. In
particular, you should be comfortable with basic systems programming and Rust.
If you don't feel comfortable with these topics, you should consider [reading
The Book][trpl] first. Though we will not be assuming that you have, and will
take care to occasionally give a refresher on the basics where appropriate. You
can skip straight to this book if you want; just know that we won't be
explaining everything from the ground up.
-->
<p><a href="https://doc.rust-lang.org/book/">The Book</a> とは異なり、ここでは多くの事前知識を前提としています。特に基本的なシステムプログラミングと Rust に精通していなくてはなりません。もし貴方がそうでないなら、まず <a href="https://doc.rust-lang.org/book/">The Book を読む</a> べきでしょう。とはいえ、The Book は前提ではありませんし、適切な場面で基本知識を復習する機会を与えます。The Book を飛ばしてこの本を読んでも構いませんが、すべてが基礎から説明されるわけではないことを覚えておいてください。</p>
<!--
To be clear, this book goes into deep detail. We're going to dig into
exception-safety, pointer aliasing, memory models, and even some type-theory.
We will also be spending a lot of time talking about the different kinds
of safety and guarantees.
-->
<p>はっきり言いますが、この本は詳細について深く説明します。例外の安全性、ポインタエイリアシング、メモリモデル、そして型理論についても少し。また、様々な種類の安全性や保証についてもたくさん説明します。</p>
<blockquote>
<p>訳注: 原文は<a href="https://doc.rust-lang.org/nomicon/index.html">こちら</a>、日本語の翻訳文書は<a href="https://github.com/rust-lang-ja/rust-nomicon-ja">こちら</a>です。</p>
</blockquote>
<!-- # Meet Safe and Unsafe -->
<h1><a class="header" href="#安全と危険のご紹介" id="安全と危険のご紹介">安全と危険のご紹介</a></h1>
<!--
Programmers in safe "high-level" languages face a fundamental dilemma. On one
hand, it would be *really* great to just say what you want and not worry about
how it's done. On the other hand, that can lead to unacceptably poor
performance. It may be necessary to drop down to less clear or idiomatic
practices to get the performance characteristics you want. Or maybe you just
throw up your hands in disgust and decide to shell out to an implementation in
a less sugary-wonderful *unsafe* language.
-->
<p>安全な「高級」言語のプログラマは、本質的なジレンマに直面します。何が欲しいかをただ伝えるだけで、
それがどのように実現されるかを悩む必要がないのは <em>本当に</em> 素晴らしいのですが、それが許容できないほどの
ひどいパフォーマンスをもたらすこともあります。
期待するパフォーマンスを得るために、明瞭で慣用的なやり方を断念しなくてはいけないかもしれないし、
または、どうしようもないと諦めて、それほど心地よくない <em>危険な</em> 言語で実装することを決心するかもしれません。</p>
<!--
Worse, when you want to talk directly to the operating system, you *have* to
talk to an unsafe language: *C*. C is ever-present and unavoidable. It's the
lingua-franca of the programming world.
Even other safe languages generally expose C interfaces for the world at large!
Regardless of why you're doing it, as soon as your program starts talking to
C it stops being safe.
-->
<p>もっと悪いことに、オペレーティングシステムと直接話したい時には、<em>C 言語</em> という危険な言語で
会話を <em>しなくてはなりません</em>。C 言語はつねに存在し、逃れることはできないのです。
C 言語はプログラミングの世界での橋渡し言語だからです。
他の安全な言語も、たいてい C 言語のインターフェースを世界中に野放しでさらしています。
理由の如何にかかわらず、あなたのプログラムが C 言語と会話した瞬間に、安全ではなくなるのです。</p>
<!--
With that said, Rust is *totally* a safe programming language.
-->
<p>とはいえ、Rust は <em>完全に</em> 安全なプログラミング言語です。</p>
<!--
Well, Rust *has* a safe programming language. Let's step back a bit.
-->
<p>・・・いえ、Rust は安全なプログラミング言語を<em>もっている</em>と言えます。一歩下がって考えてみましょう。</p>
<!--
Rust can be thought of as being composed of two programming languages: *Safe
Rust* and *Unsafe Rust*. Safe Rust is For Reals  Totally Safe. Unsafe Rust,
unsurprisingly, is *not* For Reals Totally Safe.  In fact, Unsafe Rust lets you
do some really, *really* unsafe things.
-->
<p>Rust は 2 つのプログラミング言語から成り立っていると言えます。<em>安全な Rust</em> と <em>危険な Rust</em> です。
安全な Rust は、本当に全く安全ですが、危険な Rust は、当然ですが、本当に全く安全では<em>ありません</em>。
実際、危険な Rust では本当に<em>本当に</em>危険な事ができるのです。</p>
<!--
Safe Rust is the *true* Rust programming language. If all you do is write Safe
Rust, you will never have to worry about type-safety or memory-safety. You will
never endure a null or dangling pointer, or any of that Undefined Behavior
nonsense.
-->
<p>安全な Rust は真の Rust プログラミング言語です。もしあなたが安全な Rust だけでコードを書くなら、
型安全やメモリ安全性などを心配する必要はないでしょう。
ヌルポインタやダングリングポインタ、馬鹿げた「未定義な挙動」などに我慢する必要はないのです。</p>
<!--
*That's totally awesome.*
-->
<p><em>なんて素晴らしいんだ。</em></p>
<!--
The standard library also gives you enough utilities out-of-the-box that you'll
be able to write awesome high-performance applications and libraries in pure
idiomatic Safe Rust.
-->
<p>また、標準ライブラリにはすぐに使える十分なユーティリティが揃っています。
それを使えば、ハイパフォーマンスでかっこいいアプリケーションやライブラリを、
正当で慣用的な安全な Rust で書けるでしょう。</p>
<!--
But maybe you want to talk to another language. Maybe you're writing a
low-level abstraction not exposed by the standard library. Maybe you're
*writing* the standard library (which is written entirely in Rust). Maybe you
need to do something the type-system doesn't understand and just *frob some dang
bits*. Maybe you need Unsafe Rust.
-->
<p>でも、もしかしたらあなたは他の言語と話したいかもしれません。もしかしたら標準ライブラリが提供していない
低レイヤを抽象化しようとしているのかもしれないし、もしかしたら標準ライブラリを<em>書いている</em>
（標準ライブラリは Rust で書かれています）のかもしれないし、もしかしたらあなたがやりたい事は、
型システムが理解できない、<em>ぎょっとするようなこと</em>かもしれません。
もしかしたらあなたには<em>危険な Rust</em> が必要かもしれません。</p>
<!--
Unsafe Rust is exactly like Safe Rust with all the same rules and semantics.
However Unsafe Rust lets you do some *extra* things that are Definitely Not Safe.
-->
<p>危険な Rust のルールとセマンティクスは、安全な Rust と同じです。
ただし、危険な Rust ではちょっと<em>多くの</em>事ができ、それは間違いなく安全ではありません。</p>
<!--
The only things that are different in Unsafe Rust are that you can:
-->
<p>危険な Rust であなたができる事は、たったこれだけです。</p>
<!--
* Dereference raw pointers
* Call `unsafe` functions (including C functions, intrinsics, and the raw allocator)
* Implement `unsafe` traits
* Mutate statics
-->
<ul>
<li>生ポインタが指す値を得る</li>
<li><code>unsafe</code> な関数を呼ぶ（C 言語で書かれた関数や、intrinsic、生のアロケータなど）</li>
<li><code>unsafe</code> なトレイトを実装する</li>
<li>静的な構造体を変更する</li>
</ul>
<!--
That's it. The reason these operations are relegated to Unsafe is that misusing
any of these things will cause the ever dreaded Undefined Behavior. Invoking
Undefined Behavior gives the compiler full rights to do arbitrarily bad things
to your program. You definitely *should not* invoke Undefined Behavior.
-->
<p>これだけです。これらの操作がなぜ「危険」と分類されているかというと、
間違って使うととても恐ろしい「未定義な挙動」を引き起こすからです。
「未定義な挙動」が起きると、コンパイラは、あなたのプログラムにとってどんな悪いことでもできるようになります。
何があっても「未定義な挙動」を起こす<em>べきではない</em>です。</p>
<!--
Unlike C, Undefined Behavior is pretty limited in scope in Rust. All the core
language cares about is preventing the following things:
-->
<p>C 言語と違って、Rust では「未定義な挙動」は限定されています。
言語コアは次のような事が起きるのを防ぎます。</p>
<!--
* Dereferencing null or dangling pointers
* Reading [uninitialized memory]
* Breaking the [pointer aliasing rules]
* Producing invalid primitive values:
    * dangling/null references
    * a `bool` that isn't 0 or 1
    * an undefined `enum` discriminant
    * a `char` outside the ranges [0x0, 0xD7FF] and [0xE000, 0x10FFFF]
    * A non-utf8 `str`
* Unwinding into another language
* Causing a [data race][race]
-->
<ul>
<li>ヌルポインタやダングリングポインタの参照外し</li>
<li><a href="uninitialized.html">未初期化のメモリ</a> を読む</li>
<li><a href="references.html">ポインタエイリアスルール</a> を破る</li>
<li>不正なプリミティブな値を生成する
<ul>
<li>ダングリング参照、ヌル参照</li>
<li>0 でも 1 でもない <code>bool</code> 値</li>
<li>未定義な <code>enum</code> 判別式</li>
<li>[0x0, 0xD7FF] と [0xE000, 0x10FFFF] 範囲外の <code>char</code> 値</li>
<li>utf8 ではない <code>str</code> 値</li>
</ul>
</li>
<li>他の言語に巻き戻す</li>
<li><a href="races.html">データ競合</a> を引き起こす</li>
</ul>
<!--
That's it. That's all the causes of Undefined Behavior baked into Rust. Of
course, unsafe functions and traits are free to declare arbitrary other
constraints that a program must maintain to avoid Undefined Behavior. However,
generally violations of these constraints will just transitively lead to one of
the above problems. Some additional constraints may also derive from compiler
intrinsics that make special assumptions about how code can be optimized.
-->
<p>これだけです。これが、Rust が防ぐ「未定義な挙動」の原因です。
もちろん、危険な関数やトレイトが「未定義な挙動」を起こさないための他の制約を作り出す事は可能ですが、
そういった制約が破られた場合、たいてい上の問題のどれかを引き起こします。
コンパイラ intrinsic がその他の制約を生み出し、コードの最適化に関する特別な仮定をすることもあります。</p>
<!--
Rust is otherwise quite permissive with respect to other dubious operations.
Rust considers it "safe" to:
-->
<p>Rust はその他の疑わしい操作については、とても寛容です。
Rust は次の操作を「安全」だと判断します。</p>
<!--
* Deadlock
* Have a [race condition][race]
* Leak memory
* Fail to call destructors
* Overflow integers
* Abort the program
* Delete the production database
-->
<ul>
<li>デッドロック</li>
<li><a href="races.html">競合状態</a></li>
<li>メモリリーク</li>
<li>デストラクタを呼ぶことに失敗する</li>
<li>整数のオーバーフロー</li>
<li>プログラムの異常終了</li>
<li>本番環境のデータベースを削除してしまう事</li>
</ul>
<!--
However any program that actually manages to do such a thing is *probably*
incorrect. Rust provides lots of tools to make these things rare, but
these problems are considered impractical to categorically prevent.
-->
<p>とはいえ、こういうことをできてしまうプログラムは<em>恐らく</em>間違っていると言えるでしょう。
Rust はこういった事を起きにくくするためのツールをたくさん提供します。
しかし、これらの問題を完全に防ぐのは現実的ではないと考えられています。</p>
<!-- # How Safe and Unsafe Interact -->
<h1><a class="header" href="#安全と危険の相互作用" id="安全と危険の相互作用">安全と危険の相互作用</a></h1>
<!-- What's the relationship between Safe Rust and Unsafe Rust? How do they
interact? -->
<p>安全な Rust とアンセーフな Rust とはどう関係しているのでしょうか? どのように影響し合うのでしょうか?</p>
<!-- The separation between Safe Rust and Unsafe Rust is controlled with the
`unsafe` keyword, which acts as an interface from one to the other. This is
why we can say Safe Rust is a safe language: all the unsafe parts are kept
exclusively behind the boundary. -->
<p><code>unsafe</code> キーワードがインターフェースとなり、安全な Rust とアンセーフな Rust とを分離します。
このため、安全な Rust は安全な言語で、アンセーフな部分は完全に境界外に管理されている、と言うことができるのです。</p>
<!--
The `unsafe` keyword has two uses: to declare the existence of contracts the
compiler can't check, and to declare that the adherence of some code to
those contracts has been checked by the programmer.
-->
<p><code>unsafe</code> は 2 つの目的に使われます。コンパイラがチェックできない契約が存在する事を宣言することと、
コードが契約に準拠していることがプログラマによってチェックされた事を宣言する事です。</p>
<!--
You can use `unsafe` to indicate the existence of unchecked contracts on
_functions_ and on _trait declarations_. On functions, `unsafe` means that
users of the function must check that function's documentation to ensure
they are using it in a way that maintains the contracts the function
requires. On trait declarations, `unsafe` means that implementors of the
trait must check the trait documentation to ensure their implementation
maintains the contracts the trait requires.
-->
<p><em>関数</em> と <em>トレイトの宣言</em> に未チェックな契約が存在する事を、<code>unsafe</code> を使って示すことができます。
関数に <code>unsafe</code> を使うと、ドキュメントを読んで、
要求された契約を守るように関数を使うことを、その関数のユーザーに要請することになります。
トレイトの宣言に <code>unsafe</code> を使うと、そのトレイトを実装するユーザーに対し、ドキュメントをチェックして契約を守るよう要請します。</p>
<!--
You can use `unsafe` on a block to declare that all constraints required
by an unsafe function within the block have been adhered to, and the code
can therefore be trusted. You can use `unsafe` on a trait implementation
to declare that the implementation of that trait has adhered to whatever
contracts the trait's documentation requires.
-->
<p>コードブロックに使われた <code>unsafe</code> は、そのブロックで呼ばれているアンセーフな関数が要求する契約は守られていて、コードが信頼出来る事を意味します。<code>unsafe</code> をトレイトの実装に使うと、その実装がトレイトのドキュメントに書かれている契約に準拠している事を示します。</p>
<!--
The standard library has a number of unsafe functions, including:
-->
<p>標準ライブラリにはいくつものアンセーフな関数があります。例えば、</p>
<!--
* `slice::get_unchecked`, which performs unchecked indexing, allowing
  memory safety to be freely violated.
* `mem::transmute` reinterprets some value as having a given type, bypassing
  type safety in arbitrary ways (see [conversions] for details).
* Every raw pointer to a sized type has an intrinstic `offset` method that
  invokes Undefined Behavior if the passed offset is not "in bounds" as
  defined by LLVM.
* All FFI functions are `unsafe` because the other language can do arbitrary
  operations that the Rust compiler can't check.
-->
<ul>
<li><code>slice::get_unchecked</code> は未チェックのインデックス参照を実行します。自由自在にメモリ安全性に違反できます。</li>
<li><code>mem::transmute</code> は、型安全の仕組みを好きなようにすり抜けて、ある値が特定の型であると再解釈します（詳細は <a href="conversions.html">変換</a> をみてください）。</li>
<li>サイズが確定している型の生ポインタには、固有の <code>offset</code> メソッドがあります。渡されたオフセットが LLVM が定める &quot;境界内&quot; になければ、未定義の挙動を引き起こします。</li>
<li>すべての FFI 関数は <code>unsafe</code> です。なぜなら Rust コンパイラは、他の言語が実行するどんな操作もチェックできないからです。</li>
</ul>
<!--
As of Rust 1.0 there are exactly two unsafe traits:
-->
<p>Rust 1.0 現在、アンセーフなトレイトは 2 つしかありません。</p>
<!--
* `Send` is a marker trait (a trait with no API) that promises implementors are
  safe to send (move) to another thread.
* `Sync` is a marker trait that promises threads can safely share implementors
  through a shared reference.
  -->
<ul>
<li><code>Send</code> は API を持たないマーカートレイトで、実装された型が他のスレッドに安全に送れる（ムーブできる）ことを約束します。</li>
<li><code>Sync</code> もマーカートレイトで、このトレイトを実装した型は、共有された参照を使って安全に複数のスレッドで共有できる事を約束します。</li>
</ul>
<!--
Much of the Rust standard library also uses Unsafe Rust internally, although
these implementations are rigorously manually checked, and the Safe Rust
interfaces provided on top of these implementations can be assumed to be safe.
-->
<p>また、多くの Rust 標準ライブラリは内部でアンセーフな Rust を使っています。ただ、標準ライブラリの
実装はプログラマが徹底的にチェックしているので、アンセーフな Rust の上に実装された安全な Rust は安全であると仮定して良いでしょう。</p>
<!--
The need for all of this separation boils down a single fundamental property
of Safe Rust:

**No matter what, Safe Rust can't cause Undefined Behavior.**
-->
<p>このように分離する目的は、結局のところ、安全な Rust のたった一つの基本的な性質にあります。</p>
<p><strong>どうやっても、安全な Rust では未定義な挙動を起こせない。</strong></p>
<!--
The design of the safe/unsafe split means that Safe Rust inherently has to
trust that any Unsafe Rust it touches has been written correctly (meaning
the Unsafe Rust actually maintains whatever contracts it is supposed to
maintain). On the other hand, Unsafe Rust has to be very careful about
trusting Safe Rust.
-->
<p>このように安全とアンセーフを分けると、安全な Rust は、自分が利用するアンセーフな Rust が正しく書かれている事、
つまりアンセーフな Rust がそれが守るべき契約を実際に守っている事、を本質的に信頼しなくてはいけません。
逆に、アンセーフな Rust は安全な Rust を注意して信頼しなくてはいけません。</p>
<!--
As an example, Rust has the `PartialOrd` and `Ord` traits to differentiate
between types which can "just" be compared, and those that provide a total
ordering (where every value of the type is either equal to, greater than,
or less than any other value of the same type). The sorted map type
`BTreeMap` doesn't make sense for partially-ordered types, and so it
requires that any key type for it implements the `Ord` trait. However,
`BTreeMap` has Unsafe Rust code inside of its implementation, and this
Unsafe Rust code cannot assume that any `Ord` implementation it gets makes
sense. The unsafe portions of `BTreeMap`'s internals have to be careful to
maintain all necessary contracts, even if a key type's `Ord` implementation
does not implement a total ordering.
-->
<p>例えば、Rust には <code>PartialOrd</code>トレイトと <code>Ord</code>トレイトがあり、単に比較可能な型と全順序が
定義されている型（任意の値が同じ型の他の値と比べて等しいか、大きいか、小さい）とを区別します。
順序つきマップの <code>BTreeMap</code> は半順序の型には使えないので、キーとして使われる型が <code>Ord</code>トレイトを
実装している事を要求します。
しかし <code>BTreeMap</code> の実装ではアンセーフな Rust が使われていて、アンセーフな Rust は渡された <code>Ord</code> の実装が
適切であるとは仮定できません。
<code>BTreeMap</code> 内部のアンセーフな部分は、キー型の <code>Ord</code> の実装が全順序ではない場合でも、必要な契約が
すべて守られるよう注意深く書かれなくてはいけません。</p>
<!--
Unsafe Rust cannot automatically trust Safe Rust. When writing Unsafe Rust,
you must be careful to only rely on specific Safe Rust code, and not make
assumptions about potential future Safe Rust code providing the same
guarantees.
-->
<p>アンセーフな Rust は安全な Rust を無意識には信頼できません。アンセーフな Rust コードを書くときには、
安全な Rust の特定のコードのみに依存する必要があり、
安全な Rust が将来にわたって同様の安全性を提供すると仮定してはいけません。</p>
<!--
This is the problem that `unsafe` traits exist to resolve. The `BTreeMap`
type could theoretically require that keys implement a new trait called
`UnsafeOrd`, rather than `Ord`, that might look like this:
-->
<p>この問題を解決するために <code>unsafe</code> なトレイトが存在します。理論上は、<code>BTreeMap</code> 型は
キーが <code>Ord</code> ではなく、新しいトレイト<code>UnsafeOrd</code> を実装する事を要求する事ができます。
このようなコードになるでしょう。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cmp::Ordering;

unsafe trait UnsafeOrd {
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering;
}
<span class="boring">}
</span></code></pre></pre>
<!--
Then, a type would use `unsafe` to implement `UnsafeOrd`, indicating that
they've ensured their implementation maintains whatever contracts the
trait expects. In this situation, the Unsafe Rust in the internals of
`BTreeMap` could trust that the key type's `UnsafeOrd` implementation is
correct. If it isn't, it's the fault of the unsafe trait implementation
code, which is consistent with Rust's safety guarantees.
-->
<p>この場合、<code>UnsafeOrd</code> を実装する型は、このトレイトが期待する契約に準拠している事を示すために
<code>unsafe</code> キーワードを使うことになります。
この状況では、<code>BTreeMap</code> 内部のアンセーフな Rust は、キー型が <code>UnsafeOrd</code> を正しく実装していると
信用する事ができます。もしそうで無ければ、それはトレイトの実装の問題であり、
これは Rust の安全性の保証と一致しています。</p>
<!--
The decision of whether to mark a trait `unsafe` is an API design choice.
Rust has traditionally avoided marking traits unsafe because it makes Unsafe
Rust pervasive, which is not desirable. `Send` and `Sync` are marked unsafe
because thread safety is a *fundamental property* that unsafe code can't
possibly hope to defend against in the way it could defend against a bad
`Ord` implementation. The decision of whether to mark your own traits `unsafe`
depends on the same sort of consideration. If `unsafe` code cannot reasonably
expect to defend against a bad implementation of the trait, then marking the
trait `unsafe` is a reasonable choice.
-->
<p>トレイトに <code>unsafe</code> をつけるかどうかは API デザインにおける選択です。
Rust では従来 <code>unsafe</code> なトレイトを避けてきました。そうしないとアンセーフな Rust が
蔓延してしまい、好ましくないからです。
<code>Send</code> と <code>Sync</code> が <code>unsafe</code> となっているのは、スレッドの安全性が <em>基本的な性質</em> であり、
間違った <code>Ord</code> の実装に対して危険なコードが防衛できるのと同様の意味では防衛できないからです。
あなたが宣言したトレイトを <code>unsafe</code> とマークするかどうかも、同じようにじっくりと考えてください。
もし <code>unsafe</code> なコードがそのトレイトの間違った実装から防御することが合理的に不可能であるなら、
そのトレイトを <code>unsafe</code> とするのは合理的な選択です。</p>
<!--
As an aside, while `Send` and `Sync` are `unsafe` traits, they are
automatically implemented for types when such derivations are provably safe
to do. `Send` is automatically derived for all types composed only of values
whose types also implement `Send`. `Sync` is automatically derived for all
types composed only of values whose types also implement `Sync`.
-->
<p>余談ですが、<code>unsafe</code> なトレイトである <code>Send</code> と <code>Sync</code> は、それらを実装する事が安全だと
実証可能な場合には自動的に実装されます。
<code>Send</code> は、<code>Send</code> を実装した型だけから構成される型に対して、自動的に実装されます。
<code>Sync</code> は、<code>Sync</code> を実装した型だけから構成される型に対して、自動的に実装されます。</p>
<!--
This is the dance of Safe Rust and Unsafe Rust. It is designed to make using
Safe Rust as ergonomic as possible, but requires extra effort and care when
writing Unsafe Rust. The rest of the book is largely a discussion of the sort
of care that must be taken, and what contracts it is expected of Unsafe Rust
to uphold.
-->
<p>これが安全な Rust とアンセーフな Rust のダンスです。
これは、安全な Rust をできるだけ快適に使えるように、しかしアンセーフな Rust を書くには
それ以上の努力と注意深さが要求されるようなデザインになっています。
この本の残りでは、どういう点に注意しなくはいけないのか、
アンセーフな Rust を維持するための契約とは何なのかを議論します。</p>
<!--
# Working with Unsafe
-->
<h1><a class="header" href="#unsafe-と連携する" id="unsafe-と連携する">Unsafe と連携する</a></h1>
<!--
Rust generally only gives us the tools to talk about Unsafe Rust in a scoped and
binary manner. Unfortunately, reality is significantly more complicated than
that. For instance, consider the following toy function:
-->
<p>たいていの場合、アンセーフな Rust を扱うツールは、限定された状況やバイナリでしか使えないようになっています。
残念なことに、現実はそれよりも極めて複雑です。例えば、以下の簡単な関数を見てみましょう。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn index(idx: usize, arr: &amp;[u8]) -&gt; Option&lt;u8&gt; {
    if idx &lt; arr.len() {
        unsafe {
            Some(*arr.get_unchecked(idx))
        }
    } else {
        None
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
Clearly, this function is safe. We check that the index is in bounds, and if it
is, index into the array in an unchecked manner. But even in such a trivial
function, the scope of the unsafe block is questionable. Consider changing the
`<` to a `<=`:
-->
<p>この関数は明らかに安全です。インデックスが範囲内である事をチェックし、
範囲内であれば未チェックで配列をインデックス参照します。
しかしこのような自明な関数でさえも、unsafe ブロックのスコープには疑問が残ります。
<code>&lt;</code> を <code>&lt;=</code> に変えてみましょう。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn index(idx: usize, arr: &amp;[u8]) -&gt; Option&lt;u8&gt; {
    if idx &lt;= arr.len() {
        unsafe {
            Some(*arr.get_unchecked(idx))
        }
    } else {
        None
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
This program is now unsound, and yet *we only modified safe code*. This is the
fundamental problem of safety: it's non-local. The soundness of our unsafe
operations necessarily depends on the state established by otherwise
"safe" operations.
-->
<p><em>安全なコードを変更しただけなのに</em>、今やこのプログラムは安全ではなくなりました。
これが安全性の本質的な問題です。局所的ではないのです。
アンセーフな操作の健全性は、通常 &quot;安全&quot; な操作によって構築された状態に依存しているのです。</p>
<!--
Safety is modular in the sense that opting into unsafety doesn't require you
to consider arbitrary other kinds of badness. For instance, doing an unchecked
index into a slice doesn't mean you suddenly need to worry about the slice being
null or containing uninitialized memory. Nothing fundamentally changes. However
safety *isn't* modular in the sense that programs are inherently stateful and
your unsafe operations may depend on arbitrary other state.
-->
<p>安全性は、アンセーフな操作をしたからといってあらゆる他の悪い事を考慮する必要はない、という意味ではモジュール化されています。
例えば、スライスに対して未チェックのインデックスアクセスをしても、スライスがヌルだったらどうしようとか、
スライスが未初期化のメモリを含んでいるかもといった心配をする必要はありません。基本的には何も変わりません。
しかし、プログラムは本質的にステートフルであり、アンセーフな操作はその他の任意の状態に依存しているかもしれない、
という意味で、安全性はモジュール化<em>されてはいない</em>のです。</p>
<!--
Trickier than that is when we get into actual statefulness. Consider a simple
implementation of `Vec`:
-->
<p>実際にステートフルな状況を考えると、事態はもっと厄介になります。
<code>Vec</code> の簡単な実装を見てみましょう。</p>
<pre><pre class="playground"><code class="language-rust">use std::ptr;

// この定義は不完全であることに注意してください。Vec の実装に関するセクションをみてください。
pub struct Vec&lt;T&gt; {
    ptr: *mut T,
    len: usize,
    cap: usize,
}

// この実装ではサイズが 0 の型を正しく扱えないことに注意してください。
// ここでは、すべてが 0 以上の固定サイズの型しか存在しない素敵な仮想的な世界を仮定します。
impl&lt;T&gt; Vec&lt;T&gt; {
    pub fn push(&amp;mut self, elem: T) {
        if self.len == self.cap {
            // この例では重要ではありません。
            self.reallocate();
        }
        unsafe {
            ptr::write(self.ptr.offset(self.len as isize), elem);
            self.len += 1;
        }
    }

<span class="boring">    fn reallocate(&amp;mut self) { }
</span>}

<span class="boring">fn main() {}
</span></code></pre></pre>
<!--
This code is simple enough to reasonably audit and verify. Now consider
adding the following method:
-->
<p>このコードはとてもシンプルなので、それなりに監査して検証できるでしょう。
それでは次のメソッドを追加してみましょう。</p>
<pre><code class="language-rust ignore">fn make_room(&amp;mut self) {
    // キャパシティを大きくする
    self.cap += 1;
}
</code></pre>
<!--
This code is 100% Safe Rust but it is also completely unsound. Changing the
capacity violates the invariants of Vec (that `cap` reflects the allocated space
in the Vec). This is not something the rest of Vec can guard against. It *has*
to trust the capacity field because there's no way to verify it.
-->
<p>このコードは 100% 安全な Rust ですが、同時に完全に不健全です。
キャパシティの変更は、Vec の普遍条件（<code>cap</code> は Vec にアロケートされたスペースを表している）を破ることになります。
Vec の他のコードはこれを防げません。
Vec は <code>cap</code> フィールドを検証できないので、<em>信頼しなくてはならない</em> のです。</p>
<!--
`unsafe` does more than pollute a whole function: it pollutes a whole *module*.
Generally, the only bullet-proof way to limit the scope of unsafe code is at the
module boundary with privacy.
-->
<p><code>unsafe</code> は関数そのものを汚染するだけでなく、<em>モジュール</em> 全体を汚染します。
一般的に、アンセーフなコードのスコープを制限する唯一で完全無欠の方法は、モジュール境界での非公開性を利用することです。</p>
<!--
However this works *perfectly*. The existence of `make_room` is *not* a
problem for the soundness of Vec because we didn't mark it as public. Only the
module that defines this function can call it. Also, `make_room` directly
accesses the private fields of Vec, so it can only be written in the same module
as Vec.
-->
<p>しかしこれは <em>完璧な</em> やり方です。
<code>make_room</code> は、public メソッドではないので、Vec の健全性の問題にはなりません。
この関数を定義しているモジュールだけがこの関数を呼べるのです。
また、<code>make_room</code> は Vec の private フィールドを直接アクセスしているので、
Vec と同じモジュールでのみ定義できます。</p>
<!--
It is therefore possible for us to write a completely safe abstraction that
relies on complex invariants. This is *critical* to the relationship between
Safe Rust and Unsafe Rust. We have already seen that Unsafe code must trust
*some* Safe code, but can't trust *generic* Safe code. It can't trust an
arbitrary implementor of a trait or any function that was passed to it to be
well-behaved in a way that safe code doesn't care about.
-->
<p>このように、複雑な普遍条件に依存した安全な抽象化を提供することは可能なのです。
これは安全な Rust とアンセーフな Rust の関係において<em>決定的に</em>重要です。
すでに見たように、アンセーフなコードは <em>特定</em> の安全なコードを信頼しなくてはなりませんが、
安全なコード <em>一般</em> を信頼することはできません。
安全なコードを書くときには気にする必要はないのですが、アンセーフなコードでは、
トレイトの任意の実装や渡された任意の関数が行儀よく振る舞うことを期待することはできないのです。</p>
<!--
However if unsafe code couldn't prevent client safe code from messing with its
state in arbitrary ways, safety would be a lost cause. Thankfully, it *can*
prevent arbitrary code from messing with critical state due to privacy.
-->
<p>しかし、安全なコードが状態をあらゆる方法でぐちゃぐちゃにすることを、アンセーフなコードが防げないのだとしたら、
安全性とは絵に描いた餅かもしれません。
ありがたいことに、非公開性を利用することで、
任意のコードが重要な状態をめちゃくちゃにしないよう防ぐことが<em>できる</em>のです。</p>
<!--
Safety lives!
-->
<p>安全性は無事です!</p>
<!--
# Data Representation in Rust
-->
<h1><a class="header" href="#rust-のデータ表現" id="rust-のデータ表現">Rust のデータ表現</a></h1>
<!--
Low-level programming cares a lot about data layout. It's a big deal. It also
pervasively influences the rest of the language, so we're going to start by
digging into how data is represented in Rust.
-->
<p>低レイヤのプログラミングでは、データのレイアウトがとても重要です。本当に重要な問題です。
また言語の残りの部分の多くにわたって影響を及ぼします。
ということで、Rust でどのようにデータが表現されるかを詳しく見るところから始めましょう。</p>
<h1><a class="header" href="#reprrust" id="reprrust">repr(Rust)</a></h1>
<!--
First and foremost, all types have an alignment specified in bytes. The
alignment of a type specifies what addresses are valid to store the value at. A
value of alignment `n` must only be stored at an address that is a multiple of
`n`. So alignment 2 means you must be stored at an even address, and 1 means
that you can be stored anywhere. Alignment is at least 1, and always a power of
2. Most primitives are generally aligned to their size, although this is
platform-specific behavior. In particular, on x86 `u64` and `f64` may be only
aligned to 32 bits.
-->
<p>最初に重要なこととして、すべての型はバイト単位で指定されたアラインメントに従います。
ある型のアラインメントは、値を格納する有効なアドレスを規定します。
アラインメント <code>n</code> の値は、<code>n</code> の倍数のアドレスにのみ格納できます。
つまりアラインメント 2 は、偶数アドレスにのみ格納できることを意味し、
アラインメント 1 はどこにでも格納できることになります。
アラインメントの最小値は 1 で、常に 2 のべき乗になります。
ほとんどのプリミティブ型はそのサイズにアラインメントされますが、
これはプラットフォーム依存の挙動です。
特に x86 では <code>u64</code> と <code>f64</code> は 32ビットにアラインされるかもしれません。</p>
<!--
A type's size must always be a multiple of its alignment. This ensures that an
array of that type may always be indexed by offsetting by a multiple of its
size. Note that the size and alignment of a type may not be known
statically in the case of [dynamically sized types][dst].
-->
<p>型のサイズは、常にそのアラインメントの倍数でなくてはなりません。
こうすることで、サイズの倍数をオフセットすることで、その型の配列のインデックスアクセスになります。
<a href="exotic-sizes.html#dynamically-sized-types-dsts">動的にサイズが決まる型</a> の場合、型のサイズとアラインメントは静的にはわからない場合があることに注意してください。</p>
<!--
Rust gives you the following ways to lay out composite data:
-->
<p>Rust では次の方法で複合データのメモリレイアウトを制御することができます。</p>
<!--
* structs (named product types)
* tuples (anonymous product types)
* arrays (homogeneous product types)
* enums (named sum types -- tagged unions)
-->
<ul>
<li>構造体（名前付き直積型）</li>
<li>タプル（名前なし直積型）</li>
<li>配列（同じ種類の型の直積型）</li>
<li>enum（名前付き直交型。またはタグ付き共用体）</li>
</ul>
<!--
An enum is said to be *C-like* if none of its variants have associated data.
-->
<p>enum のすべての要素が関連データを持たない場合、その enum は <em>C-like</em> と呼ばれます。</p>
<!--
Composite structures will have an alignment equal to the maximum
of their fields' alignment. Rust will consequently insert padding where
necessary to ensure that all fields are properly aligned and that the overall
type's size is a multiple of its alignment. For instance:
-->
<p>複合データのアラインメントは、その要素のうち最大のアラインメントと同じです。
そのために、Rust は必要なときにはパディングを挿入して、
すべてのフィールドが適切にアラインされ、
また全体のサイズがアラインメントの倍数になるようにします。
例えば、</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A {
    a: u8,
    b: u32,
    c: u16,
}
<span class="boring">}
</span></code></pre></pre>
<!--
will be 32-bit aligned on an architecture that aligns these primitives to their
respective sizes. The whole struct will therefore have a size that is a multiple
of 32-bits. It will potentially become:
-->
<p>この構造体は、メンバーのプリミティブ型が対応するサイズにアラインされるアーキテクチャでは、
32ビットにアラインされます。そのため全体の構造体のサイズも 32ビットの倍数になります。
このようになるでしょう。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A {
    a: u8,
    _pad1: [u8; 3], // `b` のアラインメントのため
    b: u32,
    c: u16,
    _pad2: [u8; 2], // 全体のサイズを 4バイトの倍数にするため
}
<span class="boring">}
</span></code></pre></pre>
<!--
There is *no indirection* for these types; all data is stored within the struct,
as you would expect in C. However with the exception of arrays (which are
densely packed and in-order), the layout of data is not by default specified in
Rust. Given the two following struct definitions:
-->
<p>この構造体には <em>間接参照はありません</em>。C と同様に、すべてのデータは構造体の内部に格納されます。
しかし、配列は例外（配列は隙間なく順にパックされます）ですが、Rust ではデータレイアウトは
デフォルトでは規定されていません。以下の 2 つの構造体の定義を見てみましょう。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A {
    a: i32,
    b: u64,
}

struct B {
    a: i32,
    b: u64,
}
<span class="boring">}
</span></code></pre></pre>
<!--
Rust *does* guarantee that two instances of A have their data laid out in
exactly the same way. However Rust *does not* currently guarantee that an
instance of A has the same field ordering or padding as an instance of B, though
in practice there's no reason why they wouldn't.
-->
<p>Rust は A の 2 つのインスタンスが同じようにレイアウトされることを<em>保証します</em>。
しかし、A のインスタンスと B のインスタンスとが同じフィールド順や、同じパディングを持つことを
<em>保証しません</em>。（現実的には同じにならない理由はないのですが）</p>
<!--
With A and B as written, this point would seem to be pedantic, but several other
features of Rust make it desirable for the language to play with data layout in
complex ways.
-->
<p>この A, B の例では、レイアウトが保証されないなんて融通が利かないと思うかもしれませんが、
他の機能を考えると、Rust がデータレイアウトを複雑にいじくれるようにするのは好ましいのです。</p>
<!--
For instance, consider this struct:
-->
<p>例えば、次の構造体を見てみましょう。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;T, U&gt; {
    count: u16,
    data1: T,
    data2: U,
}
<span class="boring">}
</span></code></pre></pre>
<!--
Now consider the monomorphizations of `Foo<u32, u16>` and `Foo<u16, u32>`. If
Rust lays out the fields in the order specified, we expect it to pad the
values in the struct to satisfy their alignment requirements. So if Rust
didn't reorder fields, we would expect it to produce the following:
-->
<p>さて、単体化した <code>Foo&lt;u32, u16&gt;</code> と <code>Foo&lt;u16, u32&gt;</code> とを考えてみます。
もし Rust が指定された順にフィールドをレイアウトしなくてはならないとすると、
アラインメントの要求を満たすために、パディングしなくてはなりません。
つまりもし Rust がフィールドを並び替えられないとすると、次のような型を生成すると思われます。</p>
<pre><code class="language-rust ignore">struct Foo&lt;u16, u32&gt; {
    count: u16,
    data1: u16,
    data2: u32,
}

struct Foo&lt;u32, u16&gt; {
    count: u16,
    _pad1: u16,
    data1: u32,
    data2: u16,
    _pad2: u16,
}
</code></pre>
<!--
The latter case quite simply wastes space. An optimal use of space therefore
requires different monomorphizations to have *different field orderings*.
-->
<p>後者の例ははっきり言ってスペースの無駄遣いです。
したがって、スペースを最適に使うには、異なる単体化には<em>異なるフィールド順序</em>が必要になります。</p>
<!--
**Note: this is a hypothetical optimization that is not yet implemented in Rust
1.0**
-->
<p><strong>これは仮定の最適化で、Rust 1.0 ではまた実装されていないことに注意してください。</strong></p>
<!--
Enums make this consideration even more complicated. Naively, an enum such as:
-->
<p>Enum については、もっと複雑な検討が必要になります。つまり、この enum</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Foo {
    A(u32),
    B(u64),
    C(u8),
}
<span class="boring">}
</span></code></pre></pre>
<!--
would be laid out as:
-->
<p>は、次のようにレイアウトされるでしょう。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct FooRepr {
    data: u64, // `tag` によって、u64, u32, u8 のいずれかになります
    tag: u8,   // 0 = A, 1 = B, 2 = C
}
<span class="boring">}
</span></code></pre></pre>
<!--
And indeed this is approximately how it would be laid out in general (modulo the
size and position of `tag`).
-->
<p>実際にこれが、データが一般的にどのようにレイアウトされるかの大体の説明となります。</p>
<!--
However there are several cases where such a representation is inefficient. The
classic case of this is Rust's "null pointer optimization": an enum consisting
of a single outer unit variant (e.g. `None`) and a (potentially nested) non-
nullable pointer variant (e.g. `&T`) makes the tag unnecessary, because a null
pointer value can safely be interpreted to mean that the unit variant is chosen
instead. The net result is that, for example, `size_of::<Option<&T>>() ==
size_of::<&T>()`.
-->
<p>ところが、このような表現が非効率な場合もあります。
わかりやすい例としては、Rust の &quot;ヌルポインタ最適化&quot; があります。
これは、ある enum がデータを持たないメンバー（たとえば <code>None</code>）と、（ネストしてるかもしれない）ヌルを取らないメンバー（たとえば <code>&amp;T</code>）から構成される場合、ヌルポインタをデータを持たないメンバーと解釈することができるので、タグが不要になります。
その結果、たとえば <code>size_of::&lt;Optiona&lt;&amp;T&gt;&gt;() == size_of::&lt;&amp;T&gt;()</code> となります。</p>
<!--
There are many types in Rust that are, or contain, non-nullable pointers such as
`Box<T>`, `Vec<T>`, `String`, `&T`, and `&mut T`. Similarly, one can imagine
nested enums pooling their tags into a single discriminant, as they are by
definition known to have a limited range of valid values. In principle enums could
use fairly elaborate algorithms to cache bits throughout nested types with
special constrained representations. As such it is *especially* desirable that
we leave enum layout unspecified today.
-->
<p>Rust には、ヌルポインタになりえない型や、ヌルポインタを含まない型がたくさんあります。
例えば <code>Box&lt;T&gt;</code>, <code>Vec&lt;T&gt;</code>, <code>String</code>, <code>&amp;T</code>, <code>&amp;mut T</code> などです。
同様に、ネストした複数の enum が、タグを単一の判別子に押し込めることも考えられます。
タグが取り得る値は、定義により限られているからです。
原理的には、enum はとても複雑なアルゴリズムを使って、ネストした型を特別な制約のもとで表現し、
ビットを隠すことができるでしょう。
このため、enum のレイアウトを規定しないでおくことは、現状では <em>特に</em> 好ましいのです。</p>
<!--
# Exotically Sized Types
-->
<h1><a class="header" href="#奇妙なサイズの型" id="奇妙なサイズの型">奇妙なサイズの型</a></h1>
<!--
Most of the time, we think in terms of types with a fixed, positive size. This
is not always the case, however.
-->
<p>私たちは、型は 0 以上の固定サイズを持つと通常考えます。でも常にそうであるとは限りません。</p>
<!--
# Dynamically Sized Types (DSTs)
-->
<h1><a class="header" href="#動的サイズの型dst-dynamically-sized-type" id="動的サイズの型dst-dynamically-sized-type">動的サイズの型（DST: Dynamically Sized Type）</a></h1>
<!--
Rust in fact supports Dynamically Sized Types (DSTs): types without a statically
known size or alignment. On the surface, this is a bit nonsensical: Rust *must*
know the size and alignment of something in order to correctly work with it! In
this regard, DSTs are not normal types. Due to their lack of a statically known
size, these types can only exist behind some kind of pointer. Any pointer to a
DST consequently becomes a *fat* pointer consisting of the pointer and the
information that "completes" them (more on this below).
-->
<p>実際に、Rust は動的にサイズが決まる型（DST）、静的にはサイズやアラインメントがわからない型、
をサポートしています。
一見すると、これは少し馬鹿げているようです。型をうまく扱うためには、
サイズや型を知らなければ<em>いけない</em>ですから。
こう考えると DST は通常の型ではありません。サイズが静的にわからないので、
ある種のポインタの裏にしか存在できないのです。
DST を指すポインタは結果的に、普通のポインタと DST を補完する情報（以下で詳しく説明します）から構成される、
<em>太った</em> ポインタになります。</p>
<!--
There are two major DSTs exposed by the language: trait objects, and slices.
-->
<p>言語が提供する DST のうち重要なものが 2 つあります。トレイトオブジェクトとスライスです。</p>
<!--
A trait object represents some type that implements the traits it specifies.
The exact original type is *erased* in favor of runtime reflection
with a vtable containing all the information necessary to use the type.
This is the information that completes a trait object: a pointer to its vtable.
-->
<p>トレイトオブジェクトは、それが指すトレイトを実装するある型を表現します。
元となった型は消去されますが、vtable とリフレクションとによって実行時にはその型を利用することができます。
つまり、Trait オブジェクトを補完する情報とは vtable へのポインタとなります。</p>
<!--
A slice is simply a view into some contiguous storage -- typically an array or
`Vec`. The information that completes a slice is just the number of elements
it points to.
-->
<p>スライスとは、単純にある連続したスペース（通常は配列か <code>Vec</code>）のビューです。
スライスを補完する情報とは、単にポインタが指す要素の数です。</p>
<!--
Structs can actually store a single DST directly as their last field, but this
makes them a DST as well:
-->
<p>構造体は、最後のフィールドとして DST を直接含むことができますが、その構造体自体も DST になります。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 直接スタックには置けません。
struct Foo {
    info: u32,
    data: [u8],
}
<span class="boring">}
</span></code></pre></pre>
<!--
**NOTE: [As of Rust 1.0 struct DSTs are broken if the last field has
a variable position based on its alignment][dst-issue].**
-->
<p><strong><a href="https://github.com/rust-lang/rust/issues/26403">Rust 1.0 時点では、最後のフィールドが正しくアラインメントされていない DST 構造体は正しく動きません</a></strong></p>
<!--
# Zero Sized Types (ZSTs)
-->
<h1><a class="header" href="#サイズが-0-の型zst-zero-sized-type" id="サイズが-0-の型zst-zero-sized-type">サイズが 0 の型（ZST: Zero Sized Type）</a></h1>
<!--

Rust actually allows types to be specified that occupy no space:
-->
<p>Rust ではなんと、スペースを持たない型を使うことができます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo; // フィールドがない = サイズ 0

// すべてのフィールドのサイズがない = サイズ 0
struct Baz {
    foo: Foo,
    qux: (),      // 空のタプルにはサイズがありません
    baz: [u8; 0], // 空の配列にはサイズがありません
}
<span class="boring">}
</span></code></pre></pre>
<!--
On their own, Zero Sized Types (ZSTs) are, for obvious reasons, pretty useless.
However as with many curious layout choices in Rust, their potential is realized
in a generic context: Rust largely understands that any operation that  produces
or stores a ZST can be reduced to a no-op. First off, storing it  doesn't even
make sense -- it doesn't occupy any space. Also there's only one  value of that
type, so anything that loads it can just produce it from the  aether -- which is
also a no-op since it doesn't occupy any space.
-->
<p>サイズ 0 の型（ZST）は、当然ながら、それ自体ではほとんど価値がありません。
しかし、多くの興味深いレイアウトの選択肢と組み合わせると、ZST が潜在的に役に立つことがいろいろな
ケースで明らかになります。Rust は、ZST を生成したり保存したりするオペレーションが no-op に
還元できることを理解しています。
そもそも、ZST はスペースを要求しないので、保存することには意味がありません。
また ZST は 1 つの値しかとらないので、ZST を読み込む操作は、
代わりに無から ZST を作り出すことができ、この操作もスペースを必要としないので no-op と同じです。</p>
<!--
One of the most extreme example's of this is Sets and Maps. Given a
`Map<Key, Value>`, it is common to implement a `Set<Key>` as just a thin wrapper
around `Map<Key, UselessJunk>`. In many languages, this would necessitate
allocating space for UselessJunk and doing work to store and load UselessJunk
only to discard it. Proving this unnecessary would be a difficult analysis for
the compiler.
-->
<p>究極の ZST の利用法として、Set と Map を考えてみましょう。
<code>Map&lt;Key, Value&gt;</code> があるときに、<code>Set&lt;Key&gt;</code> を <code>Map&lt;Key, UselessJunk&gt;</code> の
簡単なラッパとして実装することはよくあります。
多くの言語では、UselessJunk のスペースを割り当てる必要があるでしょうし、
結果的に使わない UselessJunk を保存したり読み込んだりする必要もあるでしょう。
こういったことが不要であると示すのはコンパイラにとっては難しい仕事でしょう。</p>
<!--
However in Rust, we can just say that  `Set<Key> = Map<Key, ()>`. Now Rust
statically knows that every load and store is useless, and no allocation has any
size. The result is that the monomorphized code is basically a custom
implementation of a HashSet with none of the overhead that HashMap would have to
support values.
-->
<p>しかし Rust では、単に <code>Set&lt;Key&gt; = Map&lt;Key, ()&gt;</code> と言えばいいだけなのです。
Rust は静的な解析で、読み込みや保存が無意味であること、メモリ割当が必要ないことを理解します。
結果として単態化したコードは、HashSet のためにカスタマイズされ、
HashMap を使う場合のオーバーヘッドはなくなります。</p>
<!--
Safe code need not worry about ZSTs, but *unsafe* code must be careful about the
consequence of types with no size. In particular, pointer offsets are no-ops,
and standard allocators (including jemalloc, the one used by default in Rust)
may return `nullptr` when a zero-sized allocation is requested, which is
indistinguishable from out of memory.
-->
<p>安全なコードは ZST について心配する必要はありませんが、<em>アンセーフな</em>コードは
サイズ 0 の型を使った時の結果について注意しなくてはなりません。
特に、ポインタのオフセットは no-op になることや、
（Rust のデフォルトである jemalloc を含む）標準的なメモリアロケータは、
サイズ 0 の割り当て要求には <code>nullptr</code> を返すこと
（これはメモリ不足と区別がつきません）に注意してください。</p>
<!--
# Empty Types
-->
<h1><a class="header" href="#空の型" id="空の型">空の型</a></h1>
<!--
Rust also enables types to be declared that *cannot even be instantiated*. These
types can only be talked about at the type level, and never at the value level.
Empty types can be declared by specifying an enum with no variants:
-->
<p>Rust では、<em>インスタンスを生成できない</em>型を宣言することもできます。
こういう型は、型レベルの話にのみ出てきて、値レベルには出てきません。
空の型は、識別子を持たない enum として宣言できます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Void {} // 識別子なし = 空
<span class="boring">}
</span></code></pre></pre>
<!--
Empty types are even more marginal than ZSTs. The primary motivating example for
Void types is type-level unreachability. For instance, suppose an API needs to
return a Result in general, but a specific case actually is infallible. It's
actually possible to communicate this at the type level by returning a
`Result<T, Void>`. Consumers of the API can confidently unwrap such a Result
knowing that it's *statically impossible* for this value to be an `Err`, as
this would require providing a value of type `Void`.
-->
<p>空の型は、ZST よりもまれにしか使いません。
空の型がもっとも必要になる例としては、型レベルの到達不可能性を示す時です。
例えば、ある API は、一般に Result を返す必要がありますが、
特定のケースでは絶対に失敗しないことがわかっているとします。
<code>Result&lt;T, Void&gt;</code> を返すことで、この事実を型レベルで伝えることが可能です。
Void 型の値を提供することはできないので、この Result は Err に<em>なり得ないと静的にわかります</em>。
そのため、この API の利用者は、自信を持って Result をアンラップすることができます。</p>
<!--
In principle, Rust can do some interesting analyses and optimizations based
on this fact. For instance, `Result<T, Void>` could be represented as just `T`,
because the `Err` case doesn't actually exist. The following *could* also
compile:
-->
<p>原理的に、Rust ではこの事実をもとに、興味深い解析と最適化が可能です。
たとえば、<code>Result&lt;T, Void&gt;</code> は <code>Err</code> にはなり得ないので、
<code>T</code> と表現することができます。以下のコードがコンパイルに通るようにも<em>できる</em>でしょう。</p>
<pre><code class="language-rust ignore">enum Void {}

let res: Result&lt;u32, Void&gt; = Ok(0);

// Err は存在しないので、Ok になることに疑問の余地はありません。
let Ok(num) = res;
</code></pre>
<!--
But neither of these tricks work today, so all Void types get you is
the ability to be confident that certain situations are statically impossible.
-->
<p>ただし、どちらの例も現時点では動きません。
つまり、Void 型による利点は、静的な解析によって、特定の状況が起こらないと確実に言えることだけです。</p>
<!--
One final subtle detail about empty types is that raw pointers to them are
actually valid to construct, but dereferencing them is Undefined Behavior
because that doesn't actually make sense. That is, you could model C's `void *`
type with `*const Void`, but this doesn't necessarily gain anything over using
e.g. `*const ()`, which *is* safe to randomly dereference.
-->
<p>最後に細かいことを一つ。空の型を指す生ポインタを構成することは有効ですが、
それを参照外しすることは、意味がないので、未定義の挙動となります。
つまり、C における <code>void *</code> と同じような意味で <code>*const Void</code> を使うこと出来ますが、
これは、<em>安全に</em>参照外しできる型（例えば <code>*const ()</code>）と比べて何も利点はありません。</p>
<!--
# Alternative representations
-->
<h1><a class="header" href="#代替メモリレイアウト" id="代替メモリレイアウト">代替メモリレイアウト</a></h1>
<!--
Rust allows you to specify alternative data layout strategies from the default.
-->
<p>Rust では、デフォルトとは異なる、代替のデータレイアウトを指定することができます。</p>
<h1><a class="header" href="#reprc" id="reprc">repr(C)</a></h1>
<!--
This is the most important `repr`. It has fairly simple intent: do what C does.
The order, size, and alignment of fields is exactly what you would expect from C
or C++. Any type you expect to pass through an FFI boundary should have
`repr(C)`, as C is the lingua-franca of the programming world. This is also
necessary to soundly do more elaborate tricks with data layout such as
reinterpreting values as a different type.
-->
<p>これは最も重要な <code>repr</code> です。意味はとても単純で、「C がやるようにやれ」です。
フィールドの順序、サイズ、アラインメントが、C や C++ に期待するのと全く同じになります。
FFI 境界を超えるであろう型は、すべて <code>repr(C)</code> になるべきです。
C はプログラミング界の共通言語なのですから。
また、値を別の型として再解釈する、といった複雑なトリックをやる場合にも <code>repr(C)</code> は必須です。</p>
<!--
However, the interaction with Rust's more exotic data layout features must be
kept in mind. Due to its dual purpose as "for FFI" and "for layout control",
`repr(C)` can be applied to types that will be nonsensical or problematic if
passed through the FFI boundary.
-->
<p>しかし、Rust の風変わりなデータレイアウト機能との相互作用も忘れてはいけません。
「FFI のため」と「データレイアウトのため」という二つの目的があるため、
FFI 境界を超えることが無意味または問題になるような型にも <code>repr(C)</code> は適用されます。</p>
<ul>
<li>
<p>ZST のサイズはやはり 0 になります。これは C の標準的な挙動ではないし、C++ の挙動
（空の型も 1 byte を消費します）とは明確に異なります。</p>
</li>
<li>
<p>DST, タプル, タグ付き共用体という概念は C には存在しないため、FFI では安全に使えません。</p>
</li>
<li>
<p><code>repr(C)</code> を適用した状況では、タプルは構造体と似ています。構造体との違いは、フィールドに名前がないことだけです。</p>
</li>
<li>
<p><strong>型に <a href="drop-flags.html">drop flags</a> が付いていても、その型は追加されます。</strong></p>
</li>
<li>
<p>enum については、<code>repr(u*)</code> （次のセクションで説明します）と同等です。選んだサイズが、対象となるプラットフォームの C ABI でのデフォルトの enum のサイズとなります。C での enum のデータ表現は実装依存なので、これはベストの推測でしかないことに注意してください。とくに、対象の C コードが特定のフラグつきでコンパイルされた場合に、正しく動かないかもしれません。</p>
</li>
</ul>
<!--
# repr(u8), repr(u16), repr(u32), repr(u64)
-->
<h1><a class="header" href="#repru8-repru16-repru32-repru64" id="repru8-repru16-repru32-repru64">repr(u8), repr(u16), repr(u32), repr(u64)</a></h1>
<!--
These specify the size to make a C-like enum. If the discriminant overflows the
integer it has to fit in, it will produce a compile-time error. You can manually
ask Rust to allow this by setting the overflowing element to explicitly be 0.
However Rust will not allow you to create an enum where two variants have the
same discriminant.
-->
<p>これらは、enum を C っぽくレイアウトするように指示します。
enum の要素が指定した整数をオーバーフローする場合、コンパイルエラーとなります。
オーバーフローする値を 0 に設定するよう Rust に指定することもできますが、
2 つの異なる enum 要素が同じ値を取ることはできません。</p>
<!--
On non-C-like enums, this will inhibit certain optimizations like the null-
pointer optimization.
-->
<p>C っぽくない enum （訳注：要素がパラメータをとるような enum）に <code>repr(u*)</code> を適用すると、
ヌルポインタ最適化のようなある種の最適化ができなくなります。</p>
<!--
These reprs have no effect on a struct.
-->
<p>この repr を構造体につかっても効果はありません。</p>
<!--
# repr(packed)
-->
<h1><a class="header" href="#reprpacked" id="reprpacked">repr(packed)</a></h1>
<!--
`repr(packed)` forces Rust to strip any padding, and only align the type to a
byte. This may improve the memory footprint, but will likely have other negative
side-effects.
-->
<p><code>repr(packed)</code> を使うと Rust はパディングを一切取り除き、すべてをバイト単位にアラインします。
メモリ使用量は改善しますが、悪い副作用を引き起こす可能性が高いです。</p>
<!--
In particular, most architectures *strongly* prefer values to be aligned. This
may mean the unaligned loads are penalized (x86), or even fault (some ARM
chips). For simple cases like directly loading or storing a packed field, the
compiler might be able to paper over alignment issues with shifts and masks.
However if you take a reference to a packed field, it's unlikely that the
compiler will be able to emit code to avoid an unaligned load.
-->
<p>特にほとんどのアーキテクチャは、値がアラインされていることを<em>強く</em>望んでいます。
つまりアラインされていないデータの読み込みにはペナルティがある（x86）かもしれませんし、
失敗する（いくつかの ARM チップ）かもしれません。
パックされたフィールドを直接読んだり書いたりするという単純なケースでは、
コンパイラがシフトやマスクを駆使してアラインメントの問題を隠してくれるかもしれません。
しかし、パックされたフィールドへの参照を扱う場合には、アラインされてない読み込みを避けるような
コードをコンパイラが生成することは期待できないでしょう。</p>
<p><strong><a href="https://github.com/rust-lang/rust/issues/27060">Rust 1.0 時点では、これは未定義な挙動です。</a></strong></p>
<p><code>repr(packed)</code> は気軽に使えるものではありません。
極端な要求に応えようとしているのでない限り、使うべきではありません。</p>
<p>この repr は <code>repr(C)</code> や <code>repr(rust)</code> の修飾子として使えます。</p>
<!--
# Ownership and Lifetimes
-->
<h1><a class="header" href="#所有権とライフタイム" id="所有権とライフタイム">所有権とライフタイム</a></h1>
<!--
Ownership is the breakout feature of Rust. It allows Rust to be completely
memory-safe and efficient, while avoiding garbage collection. Before getting
into the ownership system in detail, we will consider the motivation of this
design.
-->
<p>所有権は Rust が爆発的に有名になるきっかけとなった機能です。
所有権により、Rust は完全にメモリ安全かつ、ガーベジコレクションがないため効率的になります。
所有権の詳細に立ち入る前に、この機能がなぜ必要なのかを考えてみましょう。</p>
<!--
We will assume that you accept that garbage collection (GC) is not always an
optimal solution, and that it is desirable to manually manage memory in some
contexts. If you do not accept this, might I interest you in a different
language?
-->
<p>ガーベジコレクション（GC）が常に最適なソリューションではないこと、
手動のメモリ管理の方が望ましいケースもあることには異論はないと思います。
もしそう思わないなら、別の言語に興味を持った方が良いですよ?</p>
<!--
Regardless of your feelings on GC, it is pretty clearly a *massive* boon to
making code safe. You never have to worry about things going away *too soon*
(although whether you still wanted to be pointing at that thing is a different
issue...). This is a pervasive problem that C and C++ programs need to deal
with. Consider this simple mistake that all of us who have used a non-GC'd
language have made at one point:
-->
<p>あなたが GC のことをどう思っていようとも、GC はコードを安全にするために<em>とてつもない</em>恩恵をもたらしました。
オブジェクトが<em>早すぎるタイミングで</em>消えてしまう心配が全く必要ないんです。
（とはいえ、そのオブジェクトへのポインタをその時点まで保有しておくべきかどうかというのは別の問題ですが・・・）
これは、C や C++ プログラムが対処しなければならない、広範囲に広がっている問題です。
GC の無い言語を使ったことのあるひとなら誰でも一度はやってしまった、この単純な間違いを見てみましょう。</p>
<pre><code class="language-rust ignore">fn as_str(data: &amp;u32) -&gt; &amp;str {
    // 文字列を生成する
    let s = format!(&quot;{}&quot;, data);

    // しまった! この関数内でしか存在しないオブジェクトへの
    // 参照を返してしまった!
    // ダングリングポインタだ! メモリ解放後の参照だ! うわーー!
    // （このコードは Rust ではコンパイルエラーになります）
    &amp;s
}
</code></pre>
<!--
This is exactly what Rust's ownership system was built to solve.
Rust knows the scope in which the `&s` lives, and as such can prevent it from
escaping. However this is a simple case that even a C compiler could plausibly
catch. Things get more complicated as code gets bigger and pointers get fed through
various functions. Eventually, a C compiler will fall down and won't be able to
perform sufficient escape analysis to prove your code unsound. It will consequently
be forced to accept your program on the assumption that it is correct.
-->
<p>これこそが、Rust の所有権システムが解決する問題なのです。
Rust は <code>&amp;s</code> が生存するスコープを理解し、<code>&amp;s</code> がそのスコープ外に逃げることを防ぎます。
しかし、この単純なケースは、C コンパイラですらうまいこと防ぐことができるでしょう。
コードが大きくなり、様々な関数にポインタが渡されるようになると、やっかいなことになります。
いずれ C コンパイラは、十分なエスケープ解析ができなくなり、コードが健全である証明に失敗し、屈服することになるのです。
結果的に、C コンパイラはあなたのプログラムが正しいと仮定して、それを受け入れることを強制されます。</p>
<!--
This will never happen to Rust. It's up to the programmer to prove to the
compiler that everything is sound.
-->
<p>これは Rust では決して起こりません。全てが健全であるとコンパイラに証明するのはプログラマの責任なのです。</p>
<!--
Of course, Rust's story around ownership is much more complicated than just
verifying that references don't escape the scope of their referent. That's
because ensuring pointers are always valid is much more complicated than this.
For instance in this code,
-->
<p>もちろん、参照が参照先のスコープから逃げ出していないことを検証することよりも
所有権に関する Rust の話はもっともっと複雑です。
ポインタが常に有効であることを証明するのは、もっともっと複雑だからです。
例えばこのコードを見てみましょう。</p>
<pre><code class="language-rust ignore">let mut data = vec![1, 2, 3];
// 内部データの参照を取る
let x = &amp;data[0];

// しまった! `push` によって `data` の格納先が再割り当てされてしまった。
// ダングリングポインタだ! メモリ解放後の参照だ! うわーー!
// （このコードは Rust ではコンパイルエラーになります）
data.push(4);

println!(&quot;{}&quot;, x);
</code></pre>
<!--
naive scope analysis would be insufficient to prevent this bug, because `data`
does in fact live as long as we needed. However it was *changed* while we had
a reference into it. This is why Rust requires any references to freeze the
referent and its owners.
-->
<p>単純なスコープ解析では、このバグは防げません。
<code>data</code> のライフタイムは十分に長いからです。
問題は、その参照を保持している間に、参照先が<em>変わって</em>しまったことです。
Rust で参照を取ると、参照先とその所有者がフリーズされるのは、こういう理由なのです。</p>
<!--
# References
-->
<h1><a class="header" href="#参照" id="参照">参照</a></h1>
<!--
This section gives a high-level view of the memory model that *all* Rust
programs must satisfy to be correct. Safe code is statically verified
to obey this model by the borrow checker. Unsafe code may go above
and beyond the borrow checker while still satisfying this model. The borrow
checker may also be extended to allow more programs to compile, as long as
this more fundamental model is satisfied.
-->
<p>このセクションでは、<em>すべての</em> Rust プログラムが満たさなくてはならないメモリモデルを
ざっくりと見ていきます。
安全なコードは、借用チェッカによってこのモデルを満たしていることが静的に検証されます。
アンセーフなコードは、借用チェッカの裏をかくかもしれませんが、このモデルを満たします。
この基本的なモデルを満たしている限り、より多くのプログラムがコンパイルに通るように
借用チェッカを拡張することも可能です。</p>
<!--
There are two kinds of reference:
-->
<p>参照には 2 種類あります。</p>
<!--
* Shared reference: `&`
* Mutable reference: `&mut`
-->
<ul>
<li>共有参照: <code>&amp;</code></li>
<li>可変参照: <code>&amp;mut</code></li>
</ul>
<!--
Which obey the following rules:
-->
<p>参照は次のルールに従います。</p>
<!--
* A reference cannot outlive its referent
* A mutable reference cannot be aliased
-->
<ul>
<li>参照のライフタイムが、参照先のライフタイムより長くなることはできません。</li>
<li>可変参照は、別名を持つことができません。</li>
</ul>
<!--
That's it. That's the whole model. Of course, we should probably define
what *aliased* means. To define aliasing, we must define the notion of
*paths* and *liveness*.
-->
<p>これだけです。これがモデルの全てです。
もちろん、<em>別名を持つ</em>とはどういうことかを定義するべきでしょう。
別名を定義するには、<em>パス</em>と<em>生存</em>という概念を定義しなくてはなりません。</p>
<!--
**NOTE: The model that follows is generally agreed to be dubious and have
issues. It's ok-ish as an intuitive model, but fails to capture the desired
semantics. We leave this here to be able to use notions introduced here in later
sections. This will be significantly changed in the future. TODO: do that.**
-->
<p><strong>これから説明するモデルは疑わしく、問題があるという点に、多くの人が同意しています。
直感的なモデルとして使うにはたぶん大丈夫ですが、望むような意味論を捉えることはできないでしょう。
ここではその点にこだわらず、のちの節で使うための概念を紹介することにします。
将来的にはこの構成は大きく変わるでしょう。TODO: 構成を変える。</strong></p>
<!--
# Paths
-->
<h1><a class="header" href="#パス" id="パス">パス</a></h1>
<!--
If all Rust had were values (no pointers), then every value would be uniquely
owned by a variable or composite structure. From this we naturally derive a
*tree* of ownership. The stack itself is the root of the tree, with every
variable as its direct children. Each variable's direct children would be their
fields (if any), and so on.
-->
<p>もし、Rust が扱うのが値だけ（ポインタはない）であれば、
すべての値はただ一つの変数か複合型に所有されることになります。
ここから所有権の<em>木構造</em>が自然に導かれます。
スタック自身が木のルートになり、変数が直接の子になります。
変数がフィールドを持つのであれば、それは変数の直接の子になるでしょう。</p>
<!--
From this view, every value in Rust has a unique *path* in the tree of
ownership. Of particular interest are *ancestors* and *descendants*: if `x` owns
`y`, then `x` is an ancestor of `y`, and `y` is a descendant of `x`. Note
that this is an inclusive relationship: `x` is a descendant and ancestor of
itself.
-->
<p>このように見ると、Rust におけるすべての値は、所有権を表す木構造の<em>パス</em>を持つことになります。
特に重要なのは、<em>先祖</em>と<em>子孫</em>です。<code>x</code> が <code>y</code> が所有しているとき、<code>x</code> は <code>y</code> の先祖で、
<code>y</code> は <code>x</code> の子孫です。この関係は内包的であることに注意してください。
<code>x</code> はそれ自身の先祖であり子孫です。</p>
<!--
We can then define references as simply *names* for paths. When you create a
reference, you're declaring that an ownership path exists to this address
of memory.
-->
<p>参照は、単純にパスの<em>名前</em>と定義できます。
参照を作成するということは、あるメモリアドレスに所有権の
パスが存在することを宣言するということです。</p>
<!--
Tragically, plenty of data doesn't reside on the stack, and we must also
accommodate this. Globals and thread-locals are simple enough to model as
residing at the bottom of the stack (though we must be careful with mutable
globals). Data on the heap poses a different problem.
-->
<p>悲惨なことに、スタックに存在しないデータはたくさんあり、この点も考慮しなくてはいけません。
グローバル変数やスレッドローカル変数は、単純にスタックの底に存在すると考えることができます。
（ただし、可変なグローバル変数に注意が必要です）。
ヒープにあるデータは別の問題を提起します。</p>
<!--
If all Rust had on the heap was data uniquely owned by a pointer on the stack,
then we could just treat such a pointer as a struct that owns the value on the
heap. Box, Vec, String, and HashMap, are examples of types which uniquely
own data on the heap.
-->
<p>もし、ヒープにある各データが、スタック上のただ一つのポインタに所有されているのだとすると、
そういうポインタを、ヒープ上の値を所有する構造体だと解釈すればよいだけです。
ヒープ上のデータを独占的に所有する型の例としては、Box, Vec, String, HashMap があります。</p>
<!--
Unfortunately, data on the heap is not *always* uniquely owned. Rc for instance
introduces a notion of *shared* ownership. Shared ownership of a value means
there is no unique path to it. A value with no unique path limits what we can do
with it.
-->
<p>残念ながら、ヒープ上のデータは<em>常に</em>独占的に所有されているわけではありません。
例えば Rc によって、<em>共有</em>所有権という概念がでてきます。
値が共有所有されると、その値への一意なパスが存在しないことになります。
一意なパスが存在しない値によって、いろいろな制約が発生します。</p>
<!--
In general, only shared references can be created to non-unique paths. However
mechanisms which ensure mutual exclusion may establish One True Owner
temporarily, establishing a unique path to that value (and therefore all
its children). If this is done, the value may be mutated. In particular, a
mutable reference can be taken.
-->
<p>一般に、一意ではないパスを参照できるのは、共有参照だけです。
しかし、相互排他を保証するメカニズムがあれば、一時的にその値（とそしてすべての子ども）への唯一のパスを確立し、
「唯一の真の所有者」を確立できるかもしれません。
もしこれが可能なら、その値を変更できるかもしれません。
とくに、可変参照を取ることができるようになります。</p>
<!--
The most common way to establish such a path is through *interior mutability*,
in contrast to the *inherited mutability* that everything in Rust normally uses.
Cell, RefCell, Mutex, and RWLock are all examples of interior mutability types.
These types provide exclusive access through runtime restrictions.
-->
<p>そのようなパスを確立するために、Rust で標準的に使われる<em>継承可変性</em>ではなく、
<em>内部可変性</em>がよく使われます。
内部可変性を持った型の例としては、Cell, RefCell, Mutex, RWLock があります。
これらの型は、実行時の制約を用いて、排他的アクセスを提供します。</p>
<!--
An interesting case of this effect is Rc itself: if an Rc has refcount 1,
then it is safe to mutate or even move its internals. Note however that the
refcount itself uses interior mutability.
-->
<p>この効果を使った興味深い例が Rc 自身です。もし Rc の参照カウントが 1 なら、
内部状態を変更したり、ムーブしたりしても安全です。
参照カウント自体も内部可変性を使っています。</p>
<!--
In order to correctly communicate to the type system that a variable or field of
a struct can have interior mutability, it must be wrapped in an UnsafeCell. This
does not in itself make it safe to perform interior mutability operations on
that value. You still must yourself ensure that mutual exclusion is upheld.
-->
<p>変数や構造体のフィールドに内部可変性があることを型システムに正しく伝えるには、
UnsafeCell を使います。
UnsafeCell 自身は、その値に対して内部可変の操作を安全にはしません。
正しく相互排他していることを、あなた自身が保証しなくてはなりません。</p>
<!--
# Liveness
-->
<h1><a class="header" href="#生存性" id="生存性">生存性</a></h1>
<!--
Note: Liveness is not the same thing as a *lifetime*, which will be explained
in detail in the next section of this chapter.
-->
<p>生存性 (liveness) は、この章の次の節で詳しく説明する <em>ライフタイム (lifetime)</em> とは違うことに注意してください。</p>
<!--
Roughly, a reference is *live* at some point in a program if it can be
dereferenced. Shared references are always live unless they are literally
unreachable (for instance, they reside in freed or leaked memory). Mutable
references can be reachable but *not* live through the process of *reborrowing*.
-->
<p>大雑把に言うと、参照を参照外しできるとき、
その参照は、プログラム中のある時点で <em>生存している</em> といえます。
共有参照は、文字通り到達不可能な場合（たとえば、解放済みメモリやリークしてるメモリに
存在している場合）を除いて、常に生存しています。
可変参照には、<em>又貸し</em>というプロセスがあるので、到達できても生存して<em>いない</em>ことがあります。</p>
<!--
A mutable reference can be reborrowed to either a shared or mutable reference to
one of its descendants. A reborrowed reference will only be live again once all
reborrows derived from it expire. For instance, a mutable reference can be
reborrowed to point to a field of its referent:
-->
<p>可変参照は、その子孫を他の共有参照または可変参照に又貸しすることができます。
又貸しした参照は、派生したすべての又貸しの有効期限が切れると、再び生存することになります。
例えば、可変参照は、その参照先の一つのフィールドを指す参照を又貸しすることができます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = &amp;mut (1, 2);
{
    // x のフィールドを又借りする
    let y = &amp;mut x.0;
    // この時点で y は生存しているが、x は生存していない
    *y = 3;
}
// y がスコープ外に出たので、x が再び生存中になる
*x = (5, 7);
<span class="boring">}
</span></code></pre></pre>
<!--
It is also possible to reborrow into *multiple* mutable references, as long as
they are *disjoint*: no reference is an ancestor of another. Rust
explicitly enables this to be done with disjoint struct fields, because
disjointness can be statically proven:
-->
<p><em>複数の</em>可変参照に又貸しすることも可能ですが、その複数の参照は互いに素でなくてはいけません。
つまり、どの参照も他の参照の先祖であってはいけないということです。
Rust は、構造体のフィールドが互いに素であることを静的に証明できるので、
フィールドの又貸しが可能です。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = &amp;mut (1, 2);
{
    // x を 2 つの互いに素なフィールドに又貸しする
    let y = &amp;mut x.0;
    let z = &amp;mut x.1;

    // y と z は生存しているが、x は生存していない
    *y = 3;
    *z = 4;
}
// y と z がスコープ外に出たので、x がふたたび生存中になる
*x = (5, 7);
<span class="boring">}
</span></code></pre></pre>
<!--
However it's often the case that Rust isn't sufficiently smart to prove that
multiple borrows are disjoint. *This does not mean it is fundamentally illegal
to make such a borrow*, just that Rust isn't as smart as you want.
-->
<p>ただし、多くの場合 Rust は十分に賢くないので、複数の借り手が互いに素であることを証明できません。
<em>これはそのような又貸しが禁じられているという意味ではなく</em>、
単に Rust が期待するほど賢くないというだけです。</p>
<!--
To simplify things, we can model variables as a fake type of reference: *owned*
references. Owned references have much the same semantics as mutable references:
they can be re-borrowed in a mutable or shared manner, which makes them no
longer live. Live owned references have the unique property that they can be
moved out of (though mutable references *can* be swapped out of). This power is
only given to *live* owned references because moving its referent would of
course invalidate all outstanding references prematurely.
-->
<p>話を単純にするために、変数を参照型の一種、<em>所有中</em>参照、と仮定してみましょう。
所有中参照は、可変参照とほとんど同じ意味を持ちます。
可変参照または共有参照に又貸しでき、それによって生存中ではなくなります。
生存中の所有中参照は、値を解放（ムーブアウト）できるという特殊な性質があります
（とはいえ、可変参照は値をスワップアウトできますが）。
この能力は、<em>生存中の</em> 所有中参照のみに与えられています。
そうでなければ、早すぎるタイミングでその他の参照を無効にすることになります。</p>
<!--
As a local lint against inappropriate mutation, only variables that are marked
as `mut` can be borrowed mutably.
-->
<p>不適切な値の変更を lint が検出するので、<code>mut</code> とマークされた変数だけが変更可能なように借用されます。</p>
<!--
It is interesting to note that Box behaves exactly like an owned reference. It
can be moved out of, and Rust understands it sufficiently to reason about its
paths like a normal variable.
-->
<p>Box がまさに所有中参照のように振る舞うということを覚えておくと良いでしょう。
Box は値を解放することができ、変数が解放された時と同様に Rust はそのパスについて推論するための
十分な情報を持っています。</p>
<!--
# Aliasing
-->
<h1><a class="header" href="#別名付け" id="別名付け">別名付け</a></h1>
<!--
With liveness and paths defined, we can now properly define *aliasing*:
-->
<p>生存性とパスを定義したので、ようやく<em>別名</em>を適切に定義できます。</p>
<!--
**A mutable reference is aliased if there exists another live reference to one
of its ancestors or descendants.**
-->
<p><strong>可変参照は、その先祖か子孫に他の参照が存在している時、別名を持つといいます。</strong></p>
<!--
(If you prefer, you may also say the two live references alias *each other*.
This has no semantic consequences, but is probably a more useful notion when
verifying the soundness of a construct.)
-->
<p>（二つの生存中の参照が互いの別名になっている、と言うこともできます。
意味上の違いは特にありませんが、プログラムの構造の健全性を検証する時には、
この考え方の方がわかりやすいでしょう。）</p>
<!--
That's it. Super simple right? Except for the fact that it took us two pages to
define all of the terms in that definition. You know: Super. Simple.
-->
<p>これだけです。すげーわかりやすいですよね? この定義に必要なすべての用語を定義するのに 2 ページ必要に
なりましたが・・・。すごく、分かりやすい。でしょ?</p>
<!--
Actually it's a bit more complicated than that. In addition to references, Rust
has *raw pointers*: `*const T` and `*mut T`. Raw pointers have no inherent
ownership or aliasing semantics. As a result, Rust makes absolutely no effort to
track that they are used correctly, and they are wildly unsafe.
-->
<p>実際には、もう少し複雑です。参照に加えて Rust には<em>生ポインタ</em>もあります。
<code>*const T</code> と <code>*mut T</code> のことです。
生ポインタには、継承可能な所有権も別名という概念もありません。
そのため、Rust は生ポインタを追跡する努力を一切しませんし、生ポインタは極めて危険です。</p>
<!--
**It is an open question to what degree raw pointers have alias semantics.
However it is important for these definitions to be sound that the existence of
a raw pointer does not imply some kind of live path.**
-->
<p><strong>生ポインタが別名という意味をどの程度持っているのか、というのはまだ答えの出てない問題です。
しかし、この節で出てきた定義が健全であるためには、生ポインタを使うとある種の生存パスが
わからなくなるということ重要です。</strong></p>
<!--
# Lifetimes
-->
<h1><a class="header" href="#ライフタイム" id="ライフタイム">ライフタイム</a></h1>
<!--
Rust enforces these rules through *lifetimes*. Lifetimes are effectively
just names for scopes somewhere in the program. Each reference,
and anything that contains a reference, is tagged with a lifetime specifying
the scope it's valid for.
-->
<p>Rust は今まで説明してきたルールを<em>ライフタイム</em>を使って強制します。
ライフタイムとは、要するにプログラム中のスコープの名前です。
参照と、参照を含むものとは、有効なスコープを示すライフタイムでタグ付けられています。</p>
<!--
Within a function body, Rust generally doesn't let you explicitly name the
lifetimes involved. This is because it's generally not really necessary
to talk about lifetimes in a local context; Rust has all the information and
can work out everything as optimally as possible. Many anonymous scopes and
temporaries that you would otherwise have to write are often introduced to
make your code Just Work.
-->
<p>通常、関数本体では、関係するライフタイムの名前を明示することは求められません。
一般に、ローカルコンテキストにおいてライフタイムを気にする必要はまずないからです。
Rust はすべての情報を持っていて、可能な限りすべてを最適にできます。
省略可能な無名スコープや一時変数は、コードがきちんと動くように自動的に導入されます。</p>
<!--
However once you cross the function boundary, you need to start talking about
lifetimes. Lifetimes are denoted with an apostrophe: `'a`, `'static`. To dip
our toes with lifetimes, we're going to pretend that we're actually allowed
to label scopes with lifetimes, and desugar the examples from the start of
this chapter.
-->
<p>しかし関数の境界を超えると、ライフタイムについて気にしなくてはいけなくなります。
ライフタイムは、<code>'a</code> や <code>'static</code> などアポストロフィーつきの名前を持ちます。
ライフタイムの世界に足を踏み入れるために、
スコープにライフタイムのラベルをつけられるとして、この章の最初のサンプルコードを
「脱糖 (desugar)」してみましょう。</p>
<!--
Originally, our examples made use of *aggressive* sugar -- high fructose corn
syrup even -- around scopes and lifetimes, because writing everything out
explicitly is *extremely noisy*. All Rust code relies on aggressive inference
and elision of "obvious" things.
-->
<p>もともとのサンプルコードは、スコープとライフタイムについて、
果糖がたくさん含まれたコーンシロップのように<em>強烈に</em>甘い書き方でした。
（訳注：ライフタイムを省略できることは syntax sugar で、元のコードは大量の syntax sugar を使っているので、「甘い」と言っている）
なぜなら、すべてを明示的に書くのは<em>極めて煩わしい</em>からです。
Rust のコードは、積極的な推論と「明らかな」ことの省略とを当てにしています。</p>
<!--
One particularly interesting piece of sugar is that each `let` statement implicitly
introduces a scope. For the most part, this doesn't really matter. However it
does matter for variables that refer to each other. As a simple example, let's
completely desugar this simple piece of Rust code:
-->
<p><code>let</code> 文が、スコープを暗黙的に導入するというのは、興味深いシンタックスシュガーでしょう。
ほとんどの場合、これは問題になりません。
しかし、複数の変数がお互いを参照している場合は問題になります。
簡単な例として、この単純な Rust コードを脱糖してみましょう。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 0;
let y = &amp;x;
let z = &amp;y;
<span class="boring">}
</span></code></pre></pre>
<!--
The borrow checker always tries to minimize the extent of a lifetime, so it will
likely desugar to the following:
-->
<p>借用チェッカは、ライフタイムの長さを最小にしようとするので、
これは次のように脱糖されるでしょう。</p>
<pre><code class="language-rust ignore">// `'a: {` と `&amp;'b x` は正当な構文ではないことに注意してください!
'a: {
    let x: i32 = 0;
    'b: {
        // ここで使用されるライフタイムは 'b です。なぜなら 'b で十分だからです。
        let y: &amp;'b i32 = &amp;'b x;
        'c: {
            // 'c も同様
            let z: &amp;'c &amp;'b i32 = &amp;'c y;
        }
    }
}
</code></pre>
<!--
Wow. That's... awful. Let's all take a moment to thank Rust for making this easier.
-->
<p>おっと。こんなふうに書かなければいけないとしたら・・・これはひどいですね。
ここでしばらく時間をとって、簡単な構文を許してくれる Rust に感謝を意を表しましょう。</p>
<!--
Actually passing references to outer scopes will cause Rust to infer
a larger lifetime:
-->
<p>参照を外のスコープに返す場合は、Rust はより大きいライフタイムを推論することになります。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 0;
let z;
let y = &amp;x;
z = y;
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-rust ignore">'a: {
    let x: i32 = 0;
    'b: {
        let z: &amp;'b i32;
        'c: {
            // ここでは 'b を使う必要があります。なぜならこの参照は
            // スコープ `b に渡されるからです。
            let y: &amp;'b i32 = &amp;'b x;
            z = y;
        }
    }
}
</code></pre>
<!--
# Example: references that outlive referents
-->
<h1><a class="header" href="#例参照先より長く生きる参照" id="例参照先より長く生きる参照">例：参照先より長く生きる参照</a></h1>
<!--
Alright, let's look at some of those examples from before:
-->
<p>それでは、以前に出した例を見てみましょう。</p>
<pre><code class="language-rust ignore">fn as_str(data: &amp;u32) -&gt; &amp;str {
    let s = format!(&quot;{}&quot;, data);
    &amp;s
}
</code></pre>
<!--
desugars to:
-->
<p>は次のように脱糖されます。</p>
<pre><code class="language-rust ignore">fn as_str&lt;'a&gt;(data: &amp;'a u32) -&gt; &amp;'a str {
    'b: {
        let s = format!(&quot;{}&quot;, data);
        return &amp;'a s;
    }
}
</code></pre>
<!--
This signature of `as_str` takes a reference to a u32 with *some* lifetime, and
promises that it can produce a reference to a str that can live *just as long*.
Already we can see why this signature might be trouble. That basically implies
that we're going to find a str somewhere in the scope the reference
to the u32 originated in, or somewhere *even earlier*. That's a bit of a tall
order.
-->
<p><code>as_str</code> のシグネチャは、<em>ある</em>ライフタイムを持つ u32 への参照をとり、
その参照と<em>同じ長さだけ</em>生きる str への参照を生成することを約束します。
このシグネチャが問題になるかもしれないと、すでに話しました。
このシグネチャは、引数の u32 を指す参照が生成されたスコープか、もしくは<em>それより以前のスコープ</em>で、str を探すことを意味します。これはなかなか難しい注文です。</p>
<!--
We then proceed to compute the string `s`, and return a reference to it. Since
the contract of our function says the reference must outlive `'a`, that's the
lifetime we infer for the reference. Unfortunately, `s` was defined in the
scope `'b`, so the only way this is sound is if `'b` contains `'a` -- which is
clearly false since `'a` must contain the function call itself. We have therefore
created a reference whose lifetime outlives its referent, which is *literally*
the first thing we said that references can't do. The compiler rightfully blows
up in our face.
-->
<p>それから文字列 <code>s</code> を計算し、その参照を返します。
この関数は、返される参照が <code>'a</code> より長生きすることを約束しているので、この参照のライフタイムとして <code>'a</code> を使うことを推論します。
残念なことに、<code>s</code> はスコープ <code>'b</code> の中で定義されているので、
この推論が妥当になるためには、<code>'b</code> が <code>'a</code> を含んでいなくてはなりません。
ところがこれは明らかに成立しません。<code>'a</code> はこの関数呼び出しそものを含んでいるからです。
結局、この関数は参照先より長生きする参照を生成してしまいました。
そしてこれは<em>文字通り</em>、参照がやってはいけないことの一番目でした。
コンパイラは正当に怒りだします。</p>
<!--
To make this more clear, we can expand the example:
-->
<p>よりわかりやすくするために、この例を拡張してみます。</p>
<pre><code class="language-rust ignore">fn as_str&lt;'a&gt;(data: &amp;'a u32) -&gt; &amp;'a str {
    'b: {
        let s = format!(&quot;{}&quot;, data);
        return &amp;'a s
    }
}

fn main() {
    'c: {
        let x: u32 = 0;
        'd: {
            // この x の借用は、x が有効な全期間より短くて良いので、無名スコープが導入されます。
            // as_str は、この呼び出しより前のどこかにある str を見つけなければいけませんが、
            // そのような str が無いのはあきらかです。
            println!(&quot;{}&quot;, as_str::&lt;'d&gt;(&amp;'d x));
        }
    }
}
</code></pre>
<!--
Shoot!
-->
<p>ちくしょう！</p>
<!--
Of course, the right way to write this function is as follows:
-->
<p>この関数を正しく書くと、当然次のようになります。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn to_string(data: &amp;u32) -&gt; String {
    format!(&quot;{}&quot;, data)
}
<span class="boring">}
</span></code></pre></pre>
<!--
We must produce an owned value inside the function to return it! The only way
we could have returned an `&'a str` would have been if it was in a field of the
`&'a u32`, which is obviously not the case.
-->
<p>この関数が所有する値を関数内で生成し、それを返さなくてはいけません！
str が <code>&amp;'a u32</code> のフィールドだとしたら、<code>&amp;'a str</code> を返せるのですが、
もちろんそれはありえません。</p>
<!--
(Actually we could have also just returned a string literal, which as a global
can be considered to reside at the bottom of the stack; though this limits
our implementation *just a bit*.)
-->
<p>（そういえば、単に文字列リテラルを返すこともできたかもしれません。
文字列リテラルはグローバルで、スタックの底に存在すると解釈できますから。
ただこれはこの関数の実装を<em>ほんの少しだけ</em>制限してしまいますね。）</p>
<!--
# Example: aliasing a mutable reference
-->
<h1><a class="header" href="#例可変参照の別名付け" id="例可変参照の別名付け">例：可変参照の別名付け</a></h1>
<!--
How about the other example:
-->
<p>もう一つの例はどうでしょう。</p>
<pre><code class="language-rust ignore">let mut data = vec![1, 2, 3];
let x = &amp;data[0];
data.push(4);
println!(&quot;{}&quot;, x);
</code></pre>
<pre><code class="language-rust ignore">'a: {
    let mut data: Vec&lt;i32&gt; = vec![1, 2, 3];
    'b: {
        // スコープ 'b は次の貸し出しに必要なだけ大きくなります。
        // （`println!` を含むまで大きくなります）
        let x: &amp;'b i32 = Index::index::&lt;'b&gt;(&amp;'b data, 0);
        'c: {
            // &amp;mut は長生きする必要が無いので、一時的なスコープ 'c が作られます。
            Vec::push(&amp;'c mut data, 4);
        }
        println!(&quot;{}&quot;, x);
    }
}
</code></pre>
<!--
The problem here is a bit more subtle and interesting. We want Rust to
reject this program for the following reason: We have a live shared reference `x`
to a descendant of `data` when we try to take a mutable reference to `data`
to `push`. This would create an aliased mutable reference, which would
violate the *second* rule of references.
-->
<p>これは、すこし分かりにくいですが面白い問題です。
私たちは、Rust が次のような理由で、このプログラムを拒否するだろうと思っています。
つまり、<code>push</code> するために <code>data</code> への可変参照を取ろうとするとき、
<code>data</code> の子孫への共有参照 <code>x</code> が生存中です。
これは可変参照の別名となり、参照の<em>二番目</em>のルールに違反します。</p>
<!--
However this is *not at all* how Rust reasons that this program is bad. Rust
doesn't understand that `x` is a reference to a subpath of `data`. It doesn't
understand Vec at all. What it *does* see is that `x` has to live for `'b` to
be printed. The signature of `Index::index` subsequently demands that the
reference we take to `data` has to survive for `'b`. When we try to call `push`,
it then sees us try to make an `&'c mut data`. Rust knows that `'c` is contained
within `'b`, and rejects our program because the `&'b data` must still be live!
-->
<p>ところが、Rust がこのプログラムを悪いと推論するやり方は<em>全く違う</em>のです。
Rust は、<code>x</code> が <code>data</code> の部分パスへの参照であることは理解しません。
Rust は Vec のことなど何も知らないのです。
Rust に<em>見えている</em>のは、<code>x</code> は println! のためにスコープ <code>'b</code> の中で生存しなくてはならないことです。
さらに、<code>Index::index</code> のシグネチャは、<code>data</code> を参照する参照が
スコープ <code>'b</code> の中で生存することを要求します。
<code>push</code> を呼び出すときに、<code>&amp;'c mut data</code> を取ろうとすることを Rust は理解します。
Rust はスコープ <code>'c</code> が スコープ <code>'b</code> に含まれていることを知っているので、
このプログラムを拒否します。
なぜなら、<code>&amp;'b data</code> はまだ生きているからです。</p>
<!--
Here we see that the lifetime system is much more coarse than the reference
semantics we're actually interested in preserving. For the most part, *that's
totally ok*, because it keeps us from spending all day explaining our program
to the compiler. However it does mean that several programs that are totally
correct with respect to Rust's *true* semantics are rejected because lifetimes
are too dumb.
-->
<p>ここでは、ライフタイムをチェックするシステムは、私たちが維持したい参照の意味論に比べて
とても荒いことを見てきました。
ほとんどの場合、<em>これで全く大丈夫</em>です。
私たちが書いたコードをコンパイラに説明するために丸一日費やさなくてもいいからです。
しかし、ライフタイムのチェックがとてもバカなために、Rust の<em>真の</em>意味論的には全く正しいプログラムでも拒否されることがあるのです。</p>
<!--
# Limits of Lifetimes
-->
<h1><a class="header" href="#ライフタイムシステムの限界" id="ライフタイムシステムの限界">ライフタイムシステムの限界</a></h1>
<!--
Given the following code:
-->
<p>次のコードを見てみましょう。</p>
<pre><code class="language-rust ignore">struct Foo;

impl Foo {
    fn mutate_and_share(&amp;mut self) -&gt; &amp;Self { &amp;*self }
    fn share(&amp;self) {}
}

fn main() {
    let mut foo = Foo;
    let loan = foo.mutate_and_share();
    foo.share();
}
</code></pre>
<!--
One might expect it to compile. We call `mutate_and_share`, which mutably borrows
`foo` temporarily, but then returns only a shared reference. Therefore we
would expect `foo.share()` to succeed as `foo` shouldn't be mutably borrowed.
-->
<p>このコードはコンパイルを通ると思うかもしれません。
<code>mutate_and_share</code> は、<code>foo</code> を一時的に変更可能に借用しますが、
共有参照を返します。
そうすると、<code>foo</code> は変更可能には借用されていないので、
<code>foo.share()</code> は成功すると思うでしょう。</p>
<!--
However when we try to compile it:
-->
<p>ところが、このコードをコンパイルすると・・・。</p>
<pre><code class="language-text">&lt;anon&gt;:11:5: 11:8 error: cannot borrow `foo` as immutable because it is also borrowed as mutable
(エラー: `foo`は可変で借用されているので、不変で借用できません)
&lt;anon&gt;:11     foo.share();
              ^~~
&lt;anon&gt;:10:16: 10:19 note: previous borrow of `foo` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `foo` until the borrow ends
(注釈: 以前の`foo`の借用はここで起きています。可変での借用は、その借用が終わるまで、その後のムーブや、借用、`foo`の変更を防ぎます)
&lt;anon&gt;:10     let loan = foo.mutate_and_share();
                         ^~~
&lt;anon&gt;:12:2: 12:2 note: previous borrow ends here
(注釈: 以前の借用はここで終了しています)
&lt;anon&gt;:8 fn main() {
&lt;anon&gt;:9     let mut foo = Foo;
&lt;anon&gt;:10     let loan = foo.mutate_and_share();
&lt;anon&gt;:11     foo.share();
&lt;anon&gt;:12 }
          ^
</code></pre>
<!--
What happened? Well, we got the exact same reasoning as we did for
[Example 2 in the previous section][ex2]. We desugar the program and we get
the following:
-->
<p>何が起こったのでしょう?
<a href="lifetimes.html#%E4%BE%8B%E5%8F%AF%E5%A4%89%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9%E3%81%AE%E5%88%A5%E5%90%8D%E4%BB%98%E3%81%91">前の節の 2 つ目のサンプル</a>と全く同じ推論を行ったのです。
このコードを脱糖すると、次のようになります。</p>
<pre><code class="language-rust ignore">struct Foo;

impl Foo {
    fn mutate_and_share&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a Self { &amp;'a *self }
    fn share&lt;'a&gt;(&amp;'a self) {}
}

fn main() {
	'b: {
    	let mut foo: Foo = Foo;
    	'c: {
    		let loan: &amp;'c Foo = Foo::mutate_and_share::&lt;'c&gt;(&amp;'c mut foo);
    		'd: {
    			Foo::share::&lt;'d&gt;(&amp;'d foo);
    		}
    	}
    }
}
</code></pre>
<!--
The lifetime system is forced to extend the `&mut foo` to have lifetime `'c`,
due to the lifetime of `loan` and mutate_and_share's signature. Then when we
try to call `share`, and it sees we're trying to alias that `&'c mut foo` and
blows up in our face!
-->
<p><code>loan</code> のライフタイムと mutate_and_share のシグネチャとのため、
<code>&amp;mut foo</code> のライフタイムは <code>'c</code> に延長されなくてはなりません。
そして、<code>share</code> を呼ぼうとするとき、<code>&amp;'c mut foo</code> の別名を取ろうとすると認識され、大失敗に終わるのです。</p>
<!--
This program is clearly correct according to the reference semantics we actually
care about, but the lifetime system is too coarse-grained to handle that.
-->
<p>このプログラムは、私たちにとって重要な参照の意味的には全く正しいのですが、
ライフタイムシステムはこのプログラムを処理するには粗すぎるのです。</p>
<!--
TODO: other common problems? SEME regions stuff, mostly?
-->
<p>TODO: その他のよくある問題は? 主に SEME 領域とか?</p>
<!--
# Lifetime Elision
-->
<h1><a class="header" href="#ライフタイムの省略" id="ライフタイムの省略">ライフタイムの省略</a></h1>
<!--
In order to make common patterns more ergonomic, Rust allows lifetimes to be
*elided* in function signatures.
-->
<p>よくあるパターンをより易しく書けるように、Rust では関数シグネチャのライフタイムを省略できます。</p>
<!--
A *lifetime position* is anywhere you can write a lifetime in a type:
-->
<p><em>ライフタイムポジション</em> とは、型の定義においてライフタイムを書ける場所のことです。</p>
<pre><code class="language-rust ignore">&amp;'a T
&amp;'a mut T
T&lt;'a&gt;
</code></pre>
<!--
Lifetime positions can appear as either "input" or "output":
-->
<p>ライフタイムポジションは、「入力」または「出力」という形で現れます。</p>
<!--
* For `fn` definitions, input refers to the types of the formal arguments
  in the `fn` definition, while output refers to
  result types. So `fn foo(s: &str) -> (&str, &str)` has elided one lifetime in
  input position and two lifetimes in output position.
  Note that the input positions of a `fn` method definition do not
  include the lifetimes that occur in the method's `impl` header
  (nor lifetimes that occur in the trait header, for a default method).
-->
<ul>
<li><code>fn</code> 定義では、入力とは仮引数の型のことで、出力とは結果の型のことです。
<code>fn foo(s: *str) -&gt; (&amp;str, &amp;str)</code> では、入力ポジションのライフタイムが一つ省略され、
出力ポジションのライフタイムが二つ省略されています。
<code>fn</code> メソッド定義の入力ポジションには、
メソッドの <code>impl</code> ヘッダに現れるライフタイムは含まれません。
（デフォルトメソッドの場合の trait ヘッダに現れるライフタイムも含まれません。）</li>
</ul>
<!--
* In the future, it should be possible to elide `impl` headers in the same manner.
-->
<ul>
<li>将来のバージョンでは、<code>impl</code> ヘッダのライフタイムの省略も同様に可能になるでしょう。</li>
</ul>
<!--
Elision rules are as follows:
-->
<p>省略のルールは次の通りです。</p>
<!--
* Each elided lifetime in input position becomes a distinct lifetime
  parameter.
-->
<ul>
<li>入力ポジションの省略されたライフタイムは、それぞれ別のライフタイムパラメータになります。</li>
</ul>
<!--
* If there is exactly one input lifetime position (elided or not), that lifetime
  is assigned to *all* elided output lifetimes.
-->
<ul>
<li>入力ポジションのライフタイム（省略されているかどうかに関わらず）が一つしか無い場合、
省略された出力ライフタイム全てにそのライフタイムが割り当てられます。</li>
</ul>
<!--
* If there are multiple input lifetime positions, but one of them is `&self` or
  `&mut self`, the lifetime of `self` is assigned to *all* elided output lifetimes.
-->
<ul>
<li>入力ポジションに複数のライフタイムがあって、そのうちの一つが <code>&amp;self</code> または <code>&amp;mut self</code> の場合、
省略された出力ライフタイム全てに <code>self</code> のライフタイムが割り当てられます。</li>
</ul>
<!--
* Otherwise, it is an error to elide an output lifetime.
-->
<ul>
<li>それ以外の場合は、出力のライフタイムを省略するとエラーになります。</li>
</ul>
<!--
Examples:
-->
<p>例：</p>
<pre><code class="language-rust ignore">fn print(s: &amp;str);                                      // 省略した場合
fn print&lt;'a&gt;(s: &amp;'a str);                               // 展開した場合

fn debug(lvl: uint, s: &amp;str);                           // 省略した場合
fn debug&lt;'a&gt;(lvl: uint, s: &amp;'a str);                    // 展開した場合

fn substr(s: &amp;str, until: uint) -&gt; &amp;str;                // 省略した場合
fn substr&lt;'a&gt;(s: &amp;'a str, until: uint) -&gt; &amp;'a str;      // 展開した場合

fn get_str() -&gt; &amp;str;                                   // エラー

fn frob(s: &amp;str, t: &amp;str) -&gt; &amp;str;                      // エラー

fn get_mut(&amp;mut self) -&gt; &amp;mut T;                        // 省略した場合
fn get_mut&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a mut T;              // 展開した場合

fn args&lt;T: ToCStr&gt;(&amp;mut self, args: &amp;[T]) -&gt; &amp;mut Command                  // 省略した場合
fn args&lt;'a, 'b, T: ToCStr&gt;(&amp;'a mut self, args: &amp;'b [T]) -&gt; &amp;'a mut Command // 展開した場合

fn new(buf: &amp;mut [u8]) -&gt; BufWriter;                    // 省略した場合
fn new&lt;'a&gt;(buf: &amp;'a mut [u8]) -&gt; BufWriter&lt;'a&gt;          // 展開した場合

</code></pre>
<!--
# Unbounded Lifetimes
-->
<h1><a class="header" href="#無制限のライフタイム" id="無制限のライフタイム">無制限のライフタイム</a></h1>
<!--
Unsafe code can often end up producing references or lifetimes out of thin air.
Such lifetimes come into the world as *unbounded*. The most common source of this
is dereferencing a raw pointer, which produces a reference with an unbounded lifetime.
Such a lifetime becomes as big as context demands. This is in fact more powerful
than simply becoming `'static`, because for instance `&'static &'a T`
will fail to typecheck, but the unbound lifetime will perfectly mold into
`&'a &'a T` as needed. However for most intents and purposes, such an unbounded
lifetime can be regarded as `'static`.
-->
<p>アンセーフなコードはときに、参照やライフタイムを何も無いところから生み出したりします。
そのようなライフタイムは、<em>無制限</em> なライフタイムとして世界に登場します。
最もよくあるのは、生ポインタの参照外しをし、無制限のライフタイムを持つ参照を作り出すというケースです。
このライフタイムは、そのコンテキストが必要とするだけ大きくなります。そしてこれは <code>'static</code> よりも強力なしくみです。
<code>&amp;'static &amp;'a T</code> は型チェックをパスしませんが、無制限のライフタイムを使うと必要に応じて <code>&amp;'a &amp;'a T</code> となるからです。
しかし、ほとんどの意図と目的においては、無制限のライフタイムを <code>'static</code> と解釈できます。</p>
<!--
Almost no reference is `'static`, so this is probably wrong. `transmute` and
`transmute_copy` are the two other primary offenders. One should endeavor to
bound an unbounded lifetime as quickly as possible, especially across function
boundaries.
-->
<p>参照が <code>'static</code> であることはまずありえないので、これはおそらく間違っていると言えるでしょう。
おもに <code>transmute</code> と <code>transmute_copy</code> とがこの状況を作り出します。
できるだけ速く、とくに関数の境界では、無制限のライフタイムに制限をつけるように気をつけて下さい。</p>
<!--
Given a function, any output lifetimes that don't derive from inputs are
unbounded. For instance:
-->
<p>関数の入力から導出されない出力のライフタイムは無制限となります。例えば、</p>
<pre><code class="language-rust ignore">fn get_str&lt;'a&gt;() -&gt; &amp;'a str;
</code></pre>
<!--
will produce an `&str` with an unbounded lifetime. The easiest way to avoid
unbounded lifetimes is to use lifetime elision at the function boundary.
If an output lifetime is elided, then it *must* be bounded by an input lifetime.
Of course it might be bounded by the *wrong* lifetime, but this will usually
just cause a compiler error, rather than allow memory safety to be trivially
violated.
-->
<p>このコードは無制限のライフタイムを持った <code>&amp;str</code> を生成します。
無制限のライフタイムを避ける最も簡単な方法は、関数境界でライフタイムを省略することです。
出力ライフタイムが省略された場合、入力ライフタイムで制限されなくては<em>いけません</em>。
もちろん、<em>間違った</em>ライフタイムで制限されるかもしれませんが、たいていの場合は、メモリ安全性が侵されるのではなく、コンパイルエラーにつながります。</p>
<!--
Within a function, bounding lifetimes is more error-prone. The safest and easiest
way to bound a lifetime is to return it from a function with a bound lifetime.
However if this is unacceptable, the reference can be placed in a location with
a specific lifetime. Unfortunately it's impossible to name all lifetimes involved
in a function.
-->
<p>関数内部でライフタイムを制限することは、エラーを生みやすくなります。
ライフタイムを制限する安全で簡単な方法は、制限つきライフタイムの関数から返される値を使うことです。
しかし、これができない場合は、その参照を特定のライフタイムがついた場所に置くと良いでしょう。
残念ながら、関数内のすべてのライフタイムに名前をつけるのは不可能です。</p>
<!--
# Higher-Rank Trait Bounds (HRTBs)
-->
<h1><a class="header" href="#高階トレイト境界" id="高階トレイト境界">高階トレイト境界</a></h1>
<!--
Rust's `Fn` traits are a little bit magic. For instance, we can write the
following code:
-->
<p>Rust の <code>Fn</code> トレイトはちょっとした魔法です。例えば、次のように書くことができます。</p>
<pre><pre class="playground"><code class="language-rust">struct Closure&lt;F&gt; {
    data: (u8, u16),
    func: F,
}

impl&lt;F&gt; Closure&lt;F&gt;
    where F: Fn(&amp;(u8, u16)) -&gt; &amp;u8,
{
    fn call(&amp;self) -&gt; &amp;u8 {
        (self.func)(&amp;self.data)
    }
}

fn do_it(data: &amp;(u8, u16)) -&gt; &amp;u8 { &amp;data.0 }

fn main() {
    let clo = Closure { data: (0, 1), func: do_it };
    println!(&quot;{}&quot;, clo.call());
}
</code></pre></pre>
<!--
If we try to naively desugar this code in the same way that we did in the
lifetimes section, we run into some trouble:
-->
<p>ライフタイムの節と同じように単純に脱糖しようとすると、問題が起こります。</p>
<pre><code class="language-rust ignore">struct Closure&lt;F&gt; {
    data: (u8, u16),
    func: F,
}

impl&lt;F&gt; Closure&lt;F&gt;
    // where F: Fn(&amp;'??? (u8, u16)) -&gt; &amp;'??? u8,
{
    fn call&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a u8 {
        (self.func)(&amp;self.data)
    }
}

fn do_it&lt;'b&gt;(data: &amp;'b (u8, u16)) -&gt; &amp;'b u8 { &amp;'b data.0 }

fn main() {
    'x: {
        let clo = Closure { data: (0, 1), func: do_it };
        println!(&quot;{}&quot;, clo.call());
    }
}
</code></pre>
<!--
How on earth are we supposed to express the lifetimes on `F`'s trait bound? We
need to provide some lifetime there, but the lifetime we care about can't be
named until we enter the body of `call`! Also, that isn't some fixed lifetime;
`call` works with *any* lifetime `&self` happens to have at that point.
-->
<p><code>F</code> のトレイト境界は、一体どうすれば表現できるのでしょう?
なんらかのライフタイムを提供する必要がありますが、問題のライフタイムは <code>call</code> 関数が呼ばれるまで名前が無いのです。さらに、ライフタイムは固定されていません。
<code>&amp;self</code> に<em>どんな</em>ライフタイムが割り当てられても、<code>call</code> は動作します。</p>
<!--
This job requires The Magic of Higher-Rank Trait Bounds (HRTBs). The way we
desugar this is as follows:
-->
<p>この問題は、高階トレイト境界（HRTB: Higher-Rank Trait Bounds）という魔法で解決できます。
HRTB を使うとつぎのように脱糖できます。</p>
<pre><code class="language-rust ignore">where for&lt;'a&gt; F: Fn(&amp;'a (u8, u16)) -&gt; &amp;'a u8,
</code></pre>
<!--
(Where `Fn(a, b, c) -> d` is itself just sugar for the unstable *real* `Fn`
trait)
-->
<p>（<code>Fn(a, b, c) -&gt; d</code> 自体が、まだ仕様が安定していない<em>本当の</em> <code>Fn</code> トレイトの糖衣構文です。）</p>
<!--
`for<'a>` can be read as "for all choices of `'a`", and basically produces an
*infinite list* of trait bounds that F must satisfy. Intense. There aren't many
places outside of the `Fn` traits where we encounter HRTBs, and even for
those we have a nice magic sugar for the common cases.
-->
<p><code>for&lt;'a&gt;</code> は、「<code>'a</code> に何を選んだとしても」という意味で、つまり F が満たさなくてはならないトレイト境界の<em>無限リスト</em>を生成します。強烈でしょう?
<code>Fn</code> トレイトを除けば、HRTB が使われる場所はほとんどありません。<code>Fn</code> トレイトにおいても、ほとんどの場合は魔法の糖衣構文が良いされています。</p>
<h1><a class="header" href="#subtyping-and-variance" id="subtyping-and-variance">Subtyping and Variance</a></h1>
<p>Although Rust doesn't have any notion of structural inheritance, it <em>does</em>
include subtyping. In Rust, subtyping derives entirely from lifetimes. Since
lifetimes are scopes, we can partially order them based on the <em>contains</em>
(outlives) relationship. We can even express this as a generic bound.</p>
<p>Subtyping on lifetimes is in terms of that relationship: if <code>'a: 'b</code> (&quot;a contains
b&quot; or &quot;a outlives b&quot;), then <code>'a</code> is a subtype of <code>'b</code>. This is a large source of
confusion, because it seems intuitively backwards to many: the bigger scope is a
<em>subtype</em> of the smaller scope.</p>
<p>This does in fact make sense, though. The intuitive reason for this is that if
you expect an <code>&amp;'a u8</code>, then it's totally fine for me to hand you an <code>&amp;'static u8</code>, in the same way that if you expect an Animal in Java, it's totally fine for
me to hand you a Cat. Cats are just Animals <em>and more</em>, just as <code>'static</code> is
just <code>'a</code> <em>and more</em>.</p>
<p>(Note, the subtyping relationship and typed-ness of lifetimes is a fairly
arbitrary construct that some disagree with. However it simplifies our analysis
to treat lifetimes and types uniformly.)</p>
<p>Higher-ranked lifetimes are also subtypes of every concrete lifetime. This is
because taking an arbitrary lifetime is strictly more general than taking a
specific one.</p>
<h1><a class="header" href="#variance" id="variance">Variance</a></h1>
<p>Variance is where things get a bit complicated.</p>
<p>Variance is a property that <em>type constructors</em> have with respect to their
arguments. A type constructor in Rust is a generic type with unbound arguments.
For instance <code>Vec</code> is a type constructor that takes a <code>T</code> and returns a
<code>Vec&lt;T&gt;</code>. <code>&amp;</code> and <code>&amp;mut</code> are type constructors that take two inputs: a
lifetime, and a type to point to.</p>
<p>A type constructor's <em>variance</em> is how the subtyping of its inputs affects the
subtyping of its outputs. There are two kinds of variance in Rust:</p>
<ul>
<li>F is <em>variant</em> over <code>T</code> if <code>T</code> being a subtype of <code>U</code> implies
<code>F&lt;T&gt;</code> is a subtype of <code>F&lt;U&gt;</code> (subtyping &quot;passes through&quot;)</li>
<li>F is <em>invariant</em> over <code>T</code> otherwise (no subtyping relation can be derived)</li>
</ul>
<p>(For those of you who are familiar with variance from other languages, what we
refer to as &quot;just&quot; variance is in fact <em>covariance</em>. Rust has <em>contravariance</em>
for functions. The future of contravariance is uncertain and it may be
scrapped. For now, <code>fn(T)</code> is contravariant in <code>T</code>, which is used in matching
methods in trait implementations to the trait definition. Traits don't have
inferred variance, so <code>Fn(T)</code> is invariant in <code>T</code>).</p>
<p>Some important variances:</p>
<ul>
<li><code>&amp;'a T</code> is variant over <code>'a</code> and <code>T</code> (as is <code>*const T</code> by metaphor)</li>
<li><code>&amp;'a mut T</code> is variant over <code>'a</code> but invariant over <code>T</code></li>
<li><code>Fn(T) -&gt; U</code> is invariant over <code>T</code>, but variant over <code>U</code></li>
<li><code>Box</code>, <code>Vec</code>, and all other collections are variant over the types of
their contents</li>
<li><code>UnsafeCell&lt;T&gt;</code>, <code>Cell&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code>, <code>Mutex&lt;T&gt;</code> and all other
interior mutability types are invariant over T (as is <code>*mut T</code> by metaphor)</li>
</ul>
<p>To understand why these variances are correct and desirable, we will consider
several examples.</p>
<p>We have already covered why <code>&amp;'a T</code> should be variant over <code>'a</code> when
introducing subtyping: it's desirable to be able to pass longer-lived things
where shorter-lived things are needed.</p>
<p>Similar reasoning applies to why it should be variant over T. It is reasonable
to be able to pass <code>&amp;&amp;'static str</code> where an <code>&amp;&amp;'a str</code> is expected. The
additional level of indirection does not change the desire to be able to pass
longer lived things where shorted lived things are expected.</p>
<p>However this logic doesn't apply to <code>&amp;mut</code>. To see why <code>&amp;mut</code> should
be invariant over T, consider the following code:</p>
<pre><code class="language-rust ignore">fn overwrite&lt;T: Copy&gt;(input: &amp;mut T, new: &amp;mut T) {
    *input = *new;
}

fn main() {
    let mut forever_str: &amp;'static str = &quot;hello&quot;;
    {
        let string = String::from(&quot;world&quot;);
        overwrite(&amp;mut forever_str, &amp;mut &amp;*string);
    }
    // Oops, printing free'd memory
    println!(&quot;{}&quot;, forever_str);
}
</code></pre>
<p>The signature of <code>overwrite</code> is clearly valid: it takes mutable references to
two values of the same type, and overwrites one with the other. If <code>&amp;mut T</code> was
variant over T, then <code>&amp;mut &amp;'static str</code> would be a subtype of <code>&amp;mut &amp;'a str</code>,
since <code>&amp;'static str</code> is a subtype of <code>&amp;'a str</code>. Therefore the lifetime of
<code>forever_str</code> would successfully be &quot;shrunk&quot; down to the shorter lifetime of
<code>string</code>, and <code>overwrite</code> would be called successfully. <code>string</code> would
subsequently be dropped, and <code>forever_str</code> would point to freed memory when we
print it! Therefore <code>&amp;mut</code> should be invariant.</p>
<p>This is the general theme of variance vs invariance: if variance would allow you
to store a short-lived value into a longer-lived slot, then you must be
invariant.</p>
<p>However it <em>is</em> sound for <code>&amp;'a mut T</code> to be variant over <code>'a</code>. The key difference
between <code>'a</code> and T is that <code>'a</code> is a property of the reference itself,
while T is something the reference is borrowing. If you change T's type, then
the source still remembers the original type. However if you change the
lifetime's type, no one but the reference knows this information, so it's fine.
Put another way: <code>&amp;'a mut T</code> owns <code>'a</code>, but only <em>borrows</em> T.</p>
<p><code>Box</code> and <code>Vec</code> are interesting cases because they're variant, but you can
definitely store values in them! This is where Rust gets really clever: it's
fine for them to be variant because you can only store values
in them <em>via a mutable reference</em>! The mutable reference makes the whole type
invariant, and therefore prevents you from smuggling a short-lived type into
them.</p>
<p>Being variant allows <code>Box</code> and <code>Vec</code> to be weakened when shared
immutably. So you can pass a <code>&amp;Box&lt;&amp;'static str&gt;</code> where a <code>&amp;Box&lt;&amp;'a str&gt;</code> is
expected.</p>
<p>However what should happen when passing <em>by-value</em> is less obvious. It turns out
that, yes, you can use subtyping when passing by-value. That is, this works:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_box&lt;'a&gt;(str: &amp;'a str) -&gt; Box&lt;&amp;'a str&gt; {
    // string literals are `&amp;'static str`s
    Box::new(&quot;hello&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<p>Weakening when you pass by-value is fine because there's no one else who
&quot;remembers&quot; the old lifetime in the Box. The reason a variant <code>&amp;mut</code> was
trouble was because there's always someone else who remembers the original
subtype: the actual owner.</p>
<p>The invariance of the cell types can be seen as follows: <code>&amp;</code> is like an <code>&amp;mut</code>
for a cell, because you can still store values in them through an <code>&amp;</code>. Therefore
cells must be invariant to avoid lifetime smuggling.</p>
<p><code>Fn</code> is the most subtle case because it has mixed variance. To see why
<code>Fn(T) -&gt; U</code> should be invariant over T, consider the following function
signature:</p>
<pre><code class="language-rust ignore">// 'a is derived from some parent scope
fn foo(&amp;'a str) -&gt; usize;
</code></pre>
<p>This signature claims that it can handle any <code>&amp;str</code> that lives at least as
long as <code>'a</code>. Now if this signature was variant over <code>&amp;'a str</code>, that
would mean</p>
<pre><code class="language-rust ignore">fn foo(&amp;'static str) -&gt; usize;
</code></pre>
<p>could be provided in its place, as it would be a subtype. However this function
has a stronger requirement: it says that it can only handle <code>&amp;'static str</code>s,
and nothing else. Giving <code>&amp;'a str</code>s to it would be unsound, as it's free to
assume that what it's given lives forever. Therefore functions are not variant
over their arguments.</p>
<p>To see why <code>Fn(T) -&gt; U</code> should be variant over U, consider the following
function signature:</p>
<pre><code class="language-rust ignore">// 'a is derived from some parent scope
fn foo(usize) -&gt; &amp;'a str;
</code></pre>
<p>This signature claims that it will return something that outlives <code>'a</code>. It is
therefore completely reasonable to provide</p>
<pre><code class="language-rust ignore">fn foo(usize) -&gt; &amp;'static str;
</code></pre>
<p>in its place. Therefore functions are variant over their return type.</p>
<p><code>*const</code> has the exact same semantics as <code>&amp;</code>, so variance follows. <code>*mut</code> on the
other hand can dereference to an <code>&amp;mut</code> whether shared or not, so it is marked
as invariant just like cells.</p>
<p>This is all well and good for the types the standard library provides, but
how is variance determined for type that <em>you</em> define? A struct, informally
speaking, inherits the variance of its fields. If a struct <code>Foo</code>
has a generic argument <code>A</code> that is used in a field <code>a</code>, then Foo's variance
over <code>A</code> is exactly <code>a</code>'s variance. However this is complicated if <code>A</code> is used
in multiple fields.</p>
<ul>
<li>If all uses of A are variant, then Foo is variant over A</li>
<li>Otherwise, Foo is invariant over A</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::Cell;

struct Foo&lt;'a, 'b, A: 'a, B: 'b, C, D, E, F, G, H&gt; {
    a: &amp;'a A,     // variant over 'a and A
    b: &amp;'b mut B, // variant over 'b and invariant over B
    c: *const C,  // variant over C
    d: *mut D,    // invariant over D
    e: Vec&lt;E&gt;,    // variant over E
    f: Cell&lt;F&gt;,   // invariant over F
    g: G,         // variant over G
    h1: H,        // would also be variant over H except...
    h2: Cell&lt;H&gt;,  // invariant over H, because invariance wins
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#drop-check" id="drop-check">Drop Check</a></h1>
<p>We have seen how lifetimes provide us some fairly simple rules for ensuring
that we never read dangling references. However up to this point we have only ever
interacted with the <em>outlives</em> relationship in an inclusive manner. That is,
when we talked about <code>'a: 'b</code>, it was ok for <code>'a</code> to live <em>exactly</em> as long as
<code>'b</code>. At first glance, this seems to be a meaningless distinction. Nothing ever
gets dropped at the same time as another, right? This is why we used the
following desugaring of <code>let</code> statements:</p>
<pre><code class="language-rust ignore">let x;
let y;
</code></pre>
<pre><code class="language-rust ignore">{
    let x;
    {
        let y;
    }
}
</code></pre>
<p>Each creates its own scope, clearly establishing that one drops before the
other. However, what if we do the following?</p>
<pre><code class="language-rust ignore">let (x, y) = (vec![], vec![]);
</code></pre>
<p>Does either value strictly outlive the other? The answer is in fact <em>no</em>,
neither value strictly outlives the other. Of course, one of x or y will be
dropped before the other, but the actual order is not specified. Tuples aren't
special in this regard; composite structures just don't guarantee their
destruction order as of Rust 1.0.</p>
<p>We <em>could</em> specify this for the fields of built-in composites like tuples and
structs. However, what about something like Vec? Vec has to manually drop its
elements via pure-library code. In general, anything that implements Drop has
a chance to fiddle with its innards during its final death knell. Therefore
the compiler can't sufficiently reason about the actual destruction order
of the contents of any type that implements Drop.</p>
<p>So why do we care? We care because if the type system isn't careful, it could
accidentally make dangling pointers. Consider the following simple program:</p>
<pre><pre class="playground"><code class="language-rust">struct Inspector&lt;'a&gt;(&amp;'a u8);

fn main() {
    let (inspector, days);
    days = Box::new(1);
    inspector = Inspector(&amp;days);
}
</code></pre></pre>
<p>This program is totally sound and compiles today. The fact that <code>days</code> does
not <em>strictly</em> outlive <code>inspector</code> doesn't matter. As long as the <code>inspector</code>
is alive, so is days.</p>
<p>However if we add a destructor, the program will no longer compile!</p>
<pre><code class="language-rust ignore">struct Inspector&lt;'a&gt;(&amp;'a u8);

impl&lt;'a&gt; Drop for Inspector&lt;'a&gt; {
    fn drop(&amp;mut self) {
        println!(&quot;I was only {} days from retirement!&quot;, self.0);
    }
}

fn main() {
    let (inspector, days);
    days = Box::new(1);
    inspector = Inspector(&amp;days);
    // Let's say `days` happens to get dropped first.
    // Then when Inspector is dropped, it will try to read free'd memory!
}
</code></pre>
<pre><code class="language-text">&lt;anon&gt;:12:28: 12:32 error: `days` does not live long enough
&lt;anon&gt;:12     inspector = Inspector(&amp;days);
                                     ^~~~
&lt;anon&gt;:9:11: 15:2 note: reference must be valid for the block at 9:10...
&lt;anon&gt;:9 fn main() {
&lt;anon&gt;:10     let (inspector, days);
&lt;anon&gt;:11     days = Box::new(1);
&lt;anon&gt;:12     inspector = Inspector(&amp;days);
&lt;anon&gt;:13     // Let's say `days` happens to get dropped first.
&lt;anon&gt;:14     // Then when Inspector is dropped, it will try to read free'd memory!
          ...
&lt;anon&gt;:10:27: 15:2 note: ...but borrowed value is only valid for the block suffix following statement 0 at 10:26
&lt;anon&gt;:10     let (inspector, days);
&lt;anon&gt;:11     days = Box::new(1);
&lt;anon&gt;:12     inspector = Inspector(&amp;days);
&lt;anon&gt;:13     // Let's say `days` happens to get dropped first.
&lt;anon&gt;:14     // Then when Inspector is dropped, it will try to read free'd memory!
&lt;anon&gt;:15 }
</code></pre>
<p>Implementing Drop lets the Inspector execute some arbitrary code during its
death. This means it can potentially observe that types that are supposed to
live as long as it does actually were destroyed first.</p>
<p>Interestingly, only generic types need to worry about this. If they aren't
generic, then the only lifetimes they can harbor are <code>'static</code>, which will truly
live <em>forever</em>. This is why this problem is referred to as <em>sound generic drop</em>.
Sound generic drop is enforced by the <em>drop checker</em>. As of this writing, some
of the finer details of how the drop checker validates types is totally up in
the air. However The Big Rule is the subtlety that we have focused on this whole
section:</p>
<p><strong>For a generic type to soundly implement drop, its generics arguments must
strictly outlive it.</strong></p>
<p>Obeying this rule is (usually) necessary to satisfy the borrow
checker; obeying it is sufficient but not necessary to be
sound. That is, if your type obeys this rule then it's definitely
sound to drop.</p>
<p>The reason that it is not always necessary to satisfy the above rule
is that some Drop implementations will not access borrowed data even
though their type gives them the capability for such access.</p>
<p>For example, this variant of the above <code>Inspector</code> example will never
access borrowed data:</p>
<pre><code class="language-rust ignore">struct Inspector&lt;'a&gt;(&amp;'a u8, &amp;'static str);

impl&lt;'a&gt; Drop for Inspector&lt;'a&gt; {
    fn drop(&amp;mut self) {
        println!(&quot;Inspector(_, {}) knows when *not* to inspect.&quot;, self.1);
    }
}

fn main() {
    let (inspector, days);
    days = Box::new(1);
    inspector = Inspector(&amp;days, &quot;gadget&quot;);
    // Let's say `days` happens to get dropped first.
    // Even when Inspector is dropped, its destructor will not access the
    // borrowed `days`.
}
</code></pre>
<p>Likewise, this variant will also never access borrowed data:</p>
<pre><code class="language-rust ignore">use std::fmt;

struct Inspector&lt;T: fmt::Display&gt;(T, &amp;'static str);

impl&lt;T: fmt::Display&gt; Drop for Inspector&lt;T&gt; {
    fn drop(&amp;mut self) {
        println!(&quot;Inspector(_, {}) knows when *not* to inspect.&quot;, self.1);
    }
}

fn main() {
    let (inspector, days): (Inspector&lt;&amp;u8&gt;, Box&lt;u8&gt;);
    days = Box::new(1);
    inspector = Inspector(&amp;days, &quot;gadget&quot;);
    // Let's say `days` happens to get dropped first.
    // Even when Inspector is dropped, its destructor will not access the
    // borrowed `days`.
}
</code></pre>
<p>However, <em>both</em> of the above variants are rejected by the borrow
checker during the analysis of <code>fn main</code>, saying that <code>days</code> does not
live long enough.</p>
<p>The reason is that the borrow checking analysis of <code>main</code> does not
know about the internals of each Inspector's Drop implementation.  As
far as the borrow checker knows while it is analyzing <code>main</code>, the body
of an inspector's destructor might access that borrowed data.</p>
<p>Therefore, the drop checker forces all borrowed data in a value to
strictly outlive that value.</p>
<h1><a class="header" href="#an-escape-hatch" id="an-escape-hatch">An Escape Hatch</a></h1>
<p>The precise rules that govern drop checking may be less restrictive in
the future.</p>
<p>The current analysis is deliberately conservative and trivial; it forces all
borrowed data in a value to outlive that value, which is certainly sound.</p>
<p>Future versions of the language may make the analysis more precise, to
reduce the number of cases where sound code is rejected as unsafe.
This would help address cases such as the two Inspectors above that
know not to inspect during destruction.</p>
<p>In the meantime, there is an unstable attribute that one can use to
assert (unsafely) that a generic type's destructor is <em>guaranteed</em> to
not access any expired data, even if its type gives it the capability
to do so.</p>
<p>That attribute is called <code>may_dangle</code> and was introduced in [RFC 1327]
(https://github.com/rust-lang/rfcs/blob/master/text/1327-dropck-param-eyepatch.md).
To deploy it on the Inspector example from above, we would write:</p>
<pre><code class="language-rust ignore">struct Inspector&lt;'a&gt;(&amp;'a u8, &amp;'static str);

unsafe impl&lt;#[may_dangle] 'a&gt; Drop for Inspector&lt;'a&gt; {
    fn drop(&amp;mut self) {
        println!(&quot;Inspector(_, {}) knows when *not* to inspect.&quot;, self.1);
    }
}
</code></pre>
<p>Use of this attribute requires the <code>Drop</code> impl to be marked <code>unsafe</code> because the
compiler is not checking the implicit assertion that no potentially expired data
(e.g. <code>self.0</code> above) is accessed.</p>
<p>The attribute can be applied to any number of lifetime and type parameters. In
the following example, we assert that we access no data behind a reference of
lifetime <code>'b</code> and that the only uses of <code>T</code> will be moves or drops, but omit
the attribute from <code>'a</code> and <code>U</code>, because we do access data with that lifetime
and that type:</p>
<pre><code class="language-rust ignore">use std::fmt::Display;

struct Inspector&lt;'a, 'b, T, U: Display&gt;(&amp;'a u8, &amp;'b u8, T, U);

unsafe impl&lt;'a, #[may_dangle] 'b, #[may_dangle] T, U: Display&gt; Drop for Inspector&lt;'a, 'b, T, U&gt; {
    fn drop(&amp;mut self) {
        println!(&quot;Inspector({}, _, _, {})&quot;, self.0, self.3);
    }
}
</code></pre>
<p>It is sometimes obvious that no such access can occur, like the case above.
However, when dealing with a generic type parameter, such access can
occur indirectly. Examples of such indirect access are:</p>
<ul>
<li>invoking a callback,</li>
<li>via a trait method call.</li>
</ul>
<p>(Future changes to the language, such as impl specialization, may add
other avenues for such indirect access.)</p>
<p>Here is an example of invoking a callback:</p>
<pre><code class="language-rust ignore">struct Inspector&lt;T&gt;(T, &amp;'static str, Box&lt;for &lt;'r&gt; fn(&amp;'r T) -&gt; String&gt;);

impl&lt;T&gt; Drop for Inspector&lt;T&gt; {
    fn drop(&amp;mut self) {
        // The `self.2` call could access a borrow e.g. if `T` is `&amp;'a _`.
        println!(&quot;Inspector({}, {}) unwittingly inspects expired data.&quot;,
                 (self.2)(&amp;self.0), self.1);
    }
}
</code></pre>
<p>Here is an example of a trait method call:</p>
<pre><code class="language-rust ignore">use std::fmt;

struct Inspector&lt;T: fmt::Display&gt;(T, &amp;'static str);

impl&lt;T: fmt::Display&gt; Drop for Inspector&lt;T&gt; {
    fn drop(&amp;mut self) {
        // There is a hidden call to `&lt;T as Display&gt;::fmt` below, which
        // could access a borrow e.g. if `T` is `&amp;'a _`
        println!(&quot;Inspector({}, {}) unwittingly inspects expired data.&quot;,
                 self.0, self.1);
    }
}
</code></pre>
<p>And of course, all of these accesses could be further hidden within
some other method invoked by the destructor, rather than being written
directly within it.</p>
<p>In all of the above cases where the <code>&amp;'a u8</code> is accessed in the
destructor, adding the <code>#[may_dangle]</code>
attribute makes the type vulnerable to misuse that the borrower
checker will not catch, inviting havoc. It is better to avoid adding
the attribute.</p>
<h1><a class="header" href="#is-that-all-about-drop-checker" id="is-that-all-about-drop-checker">Is that all about drop checker?</a></h1>
<p>It turns out that when writing unsafe code, we generally don't need to
worry at all about doing the right thing for the drop checker. However there
is one special case that you need to worry about, which we will look at in
the next section.</p>
<h1><a class="header" href="#phantomdata" id="phantomdata">PhantomData</a></h1>
<p>When working with unsafe code, we can often end up in a situation where
types or lifetimes are logically associated with a struct, but not actually
part of a field. This most commonly occurs with lifetimes. For instance, the
<code>Iter</code> for <code>&amp;'a [T]</code> is (approximately) defined as follows:</p>
<pre><code class="language-rust ignore">struct Iter&lt;'a, T: 'a&gt; {
    ptr: *const T,
    end: *const T,
}
</code></pre>
<p>However because <code>'a</code> is unused within the struct's body, it's <em>unbounded</em>.
Because of the troubles this has historically caused, unbounded lifetimes and
types are <em>forbidden</em> in struct definitions. Therefore we must somehow refer
to these types in the body. Correctly doing this is necessary to have
correct variance and drop checking.</p>
<p>We do this using <code>PhantomData</code>, which is a special marker type. <code>PhantomData</code>
consumes no space, but simulates a field of the given type for the purpose of
static analysis. This was deemed to be less error-prone than explicitly telling
the type-system the kind of variance that you want, while also providing other
useful such as the information needed by drop check.</p>
<p>Iter logically contains a bunch of <code>&amp;'a T</code>s, so this is exactly what we tell
the PhantomData to simulate:</p>
<pre><code>use std::marker;

struct Iter&lt;'a, T: 'a&gt; {
    ptr: *const T,
    end: *const T,
    _marker: marker::PhantomData&lt;&amp;'a T&gt;,
}
</code></pre>
<p>and that's it. The lifetime will be bounded, and your iterator will be variant
over <code>'a</code> and <code>T</code>. Everything Just Works.</p>
<p>Another important example is Vec, which is (approximately) defined as follows:</p>
<pre><code>struct Vec&lt;T&gt; {
    data: *const T, // *const for variance!
    len: usize,
    cap: usize,
}
</code></pre>
<p>Unlike the previous example, it <em>appears</em> that everything is exactly as we
want. Every generic argument to Vec shows up in at least one field.
Good to go!</p>
<p>Nope.</p>
<p>The drop checker will generously determine that <code>Vec&lt;T&gt;</code> does not own any values
of type T. This will in turn make it conclude that it doesn't need to worry
about Vec dropping any T's in its destructor for determining drop check
soundness. This will in turn allow people to create unsoundness using
Vec's destructor.</p>
<p>In order to tell dropck that we <em>do</em> own values of type T, and therefore may
drop some T's when <em>we</em> drop, we must add an extra PhantomData saying exactly
that:</p>
<pre><code>use std::marker;

struct Vec&lt;T&gt; {
    data: *const T, // *const for covariance!
    len: usize,
    cap: usize,
    _marker: marker::PhantomData&lt;T&gt;,
}
</code></pre>
<p>Raw pointers that own an allocation is such a pervasive pattern that the
standard library made a utility for itself called <code>Unique&lt;T&gt;</code> which:</p>
<ul>
<li>wraps a <code>*const T</code> for variance</li>
<li>includes a <code>PhantomData&lt;T&gt;</code></li>
<li>auto-derives Send/Sync as if T was contained</li>
<li>marks the pointer as NonZero for the null-pointer optimization</li>
</ul>
<!--
# Splitting Borrows
-->
<h1><a class="header" href="#借用の分割" id="借用の分割">借用の分割</a></h1>
<!--
The mutual exclusion property of mutable references can be very limiting when
working with a composite structure. The borrow checker understands some basic
stuff, but will fall over pretty easily. It does understand structs
sufficiently to know that it's possible to borrow disjoint fields of a struct
simultaneously. So this works today:
-->
<p>可変参照の相互排他性は、複合構造体を使用している時に非常に制限を課してくる存在となります。
借用チェッカはいくつか基本事項を理解していますが、本当に簡単にすっ転びます。
借用チェッカは構造体について十分理解しているため、構造体の別々のフィールドを同時に借用することは可能です。
ですから、このコードは今日動作します。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    a: i32,
    b: i32,
    c: i32,
}

let mut x = Foo {a: 0, b: 0, c: 0};
let a = &amp;mut x.a;
let b = &amp;mut x.b;
let c = &amp;x.c;
*b += 1;
let c2 = &amp;x.c;
*a += 10;
println!(&quot;{} {} {} {}&quot;, a, b, c, c2);
<span class="boring">}
</span></code></pre></pre>
<!--
However borrowck doesn't understand arrays or slices in any way, so this doesn't
work:
-->
<p>しかし借用チェッカは、配列やスライスについてはどんな状況でも理解しないため、
このコードは動きません。</p>
<pre><code class="language-rust ignore">let mut x = [1, 2, 3];
let a = &amp;mut x[0];
let b = &amp;mut x[1];
println!(&quot;{} {}&quot;, a, b);
</code></pre>
<pre><code class="language-text">&lt;anon&gt;:4:14: 4:18 error: cannot borrow `x[..]` as mutable more than once at a time
(エラー: 一度に `x[..]` を可変として 2 回以上借用することはできません)
&lt;anon&gt;:4 let b = &amp;mut x[1];
                      ^~~~
&lt;anon&gt;:3:14: 3:18 note: previous borrow of `x[..]` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x[..]` until the borrow ends
(注釈: 以前の `x[..]` の借用はここで起きています。可変での借用は、その借用が終わるまで、その後のムーブや、借用、 `x[..]` の変更を防ぎます)
&lt;anon&gt;:3 let a = &amp;mut x[0];
                      ^~~~
&lt;anon&gt;:6:2: 6:2 note: previous borrow ends here
(注釈: 以前の借用はここで終了しています)
&lt;anon&gt;:1 fn main() {
&lt;anon&gt;:2 let mut x = [1, 2, 3];
&lt;anon&gt;:3 let a = &amp;mut x[0];
&lt;anon&gt;:4 let b = &amp;mut x[1];
&lt;anon&gt;:5 println!(&quot;{} {}&quot;, a, b);
&lt;anon&gt;:6 }
         ^
error: aborting due to 2 previous errors
(エラー: 上記の 2 つのエラーのため中止)
</code></pre>
<!--
While it was plausible that borrowck could understand this simple case, it's
pretty clearly hopeless for borrowck to understand disjointness in general
container types like a tree, especially if distinct keys actually *do* map
to the same value.
-->
<p>仮に借用チェッカがこの単純なケースを理解しても良さそうに見えるかもしれませんが、
特に、異なるキーが<em>本当に</em>同じ値にマップされているときなど、
木のような一般的なコンテナ内の、各値の素集合性を借用チェッカが理解することを望むのは、
明らかに無駄です。</p>
<!--
In order to "teach" borrowck that what we're doing is ok, we need to drop down
to unsafe code. For instance, mutable slices expose a `split_at_mut` function
that consumes the slice and returns two mutable slices. One for everything to
the left of the index, and one for everything to the right. Intuitively we know
this is safe because the slices don't overlap, and therefore alias. However
the implementation requires some unsafety:
-->
<p>借用チェッカに我々が行なっていることが問題ないと &quot;教える&quot; ためには、
アンセーフなコードに落とす必要があります。例えば、可変スライスには、
スライスを消費し 2 つの可変スライスを返す <code>split_at_mut</code> 関数を使用します。
片方のスライスはインデックスの左側全てを、もう片方のスライスはインデックスの右側全てを
使用するためのものです。直感的に、これは安全と分かります。互いのスライスが重ならなず、それゆえ
これらのスライスは元のスライスのエイリアスとなるからです。
しかし、その実装には少しアンセーフなコードを必要とします。</p>
<pre><code class="language-rust ignore">fn split_at_mut(&amp;mut self, mid: usize) -&gt; (&amp;mut [T], &amp;mut [T]) {
    let len = self.len();
    let ptr = self.as_mut_ptr();
    assert!(mid &lt;= len);
    unsafe {
        (from_raw_parts_mut(ptr, mid),
         from_raw_parts_mut(ptr.offset(mid as isize), len - mid))
    }
}
</code></pre>
<!--
This is actually a bit subtle. So as to avoid ever making two `&mut`'s to the
same value, we explicitly construct brand-new slices through raw pointers.
-->
<p>これは実際、ちょっと微妙です。 同じ値に対する 2 つの <code>&amp;mut</code> を生成するのを
常に避けるため、生ポインタを通じて明確に完全に新しいスライスを構築します。</p>
<!--
However more subtle is how iterators that yield mutable references work.
The iterator trait is defined as follows:
-->
<p>しかし、もっと微妙なのは、可変参照を生成するイテレータが
どのように動作するかについてです。イテレータのトレイトは以下のように定義されます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<!--
Given this definition, Self::Item has *no* connection to `self`. This means that
we can call `next` several times in a row, and hold onto all the results
*concurrently*. This is perfectly fine for by-value iterators, which have
exactly these semantics. It's also actually fine for shared references, as they
admit arbitrarily many references to the same thing (although the iterator needs
to be a separate object from the thing being shared).
-->
<p>上記の定義によれば、 Self::Item は <code>self</code> と何のつながりも持ち<em>ません</em>。
これは、 <code>next</code> を続けて何回か呼ぶことができ、そしてそれらに対する全ての結果を
<em>同時に</em>保持することができることを意味します。これは、値渡しのイテレータに対しては
全く問題ありません。値渡しのイテレータも全く同じセマンティクスを持つからです。
そして、共有参照に対しても問題ありません。これらも同じものに対する任意の数の
参照を認めているからです (イテレータは共有されるオブジェクトと分離されている必要がありますが) 。</p>
<!--
But mutable references make this a mess. At first glance, they might seem
completely incompatible with this API, as it would produce multiple mutable
references to the same object!
-->
<p>しかし、可変参照はこれをごちゃごちゃにします。ひと目見ただけでも、可変参照は
この API に全く対応できないように見えるかもしれません。この API が同じオブジェクトに対する
複数の可変参照を生成するからです!</p>
<!--
However it actually *does* work, exactly because iterators are one-shot objects.
Everything an IterMut yields will be yielded at most once, so we don't
actually ever yield multiple mutable references to the same piece of data.
-->
<p>しかし、この API は<em>本当に</em>動作します。まさにイテレータがその場限りのオブジェクトであるからです。
IterMut が生成するすべてのものは高々 1 回しか生成されません。ですから実際には、
常に、何らかのひとかけらのデータに対する可変参照を、複数回生成していないのです。</p>
<!--
Perhaps surprisingly, mutable iterators don't require unsafe code to be
implemented for many types!
-->
<p>もしかすると驚くかもしれませんが、可変のイテレータは多くの型に対して
実装する際、アンセーフなコードを必要としないのです!</p>
<!--
For instance here's a singly linked list:
-->
<p>例えばこれは、片方向リストです。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {}
</span>type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

pub struct LinkedList&lt;T&gt; {
    head: Link&lt;T&gt;,
}

pub struct IterMut&lt;'a, T: 'a&gt;(Option&lt;&amp;'a mut Node&lt;T&gt;&gt;);

impl&lt;T&gt; LinkedList&lt;T&gt; {
    fn iter_mut(&amp;mut self) -&gt; IterMut&lt;T&gt; {
        IterMut(self.head.as_mut().map(|node| &amp;mut **node))
    }
}

impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    type Item = &amp;'a mut T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.0.take().map(|node| {
            self.0 = node.next.as_mut().map(|node| &amp;mut **node);
            &amp;mut node.elem
        })
    }
}
</code></pre></pre>
<!--
Here's a mutable slice:
-->
<p>これは可変スライスです。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {}
</span>use std::mem;

pub struct IterMut&lt;'a, T: 'a&gt;(&amp;'a mut[T]);

impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    type Item = &amp;'a mut T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let slice = mem::replace(&amp;mut self.0, &amp;mut []);
        if slice.is_empty() { return None; }

        let (l, r) = slice.split_at_mut(1);
        self.0 = r;
        l.get_mut(0)
    }
}

impl&lt;'a, T&gt; DoubleEndedIterator for IterMut&lt;'a, T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let slice = mem::replace(&amp;mut self.0, &amp;mut []);
        if slice.is_empty() { return None; }

        let new_len = slice.len() - 1;
        let (l, r) = slice.split_at_mut(new_len);
        self.0 = l;
        r.get_mut(0)
    }
}
</code></pre></pre>
<!--
And here's a binary tree:
-->
<p>そしてこれは二分木です。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {}
</span>use std::collections::VecDeque;

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    left: Link&lt;T&gt;,
    right: Link&lt;T&gt;,
}

pub struct Tree&lt;T&gt; {
    root: Link&lt;T&gt;,
}

struct NodeIterMut&lt;'a, T: 'a&gt; {
    elem: Option&lt;&amp;'a mut T&gt;,
    left: Option&lt;&amp;'a mut Node&lt;T&gt;&gt;,
    right: Option&lt;&amp;'a mut Node&lt;T&gt;&gt;,
}

enum State&lt;'a, T: 'a&gt; {
    Elem(&amp;'a mut T),
    Node(&amp;'a mut Node&lt;T&gt;),
}

pub struct IterMut&lt;'a, T: 'a&gt;(VecDeque&lt;NodeIterMut&lt;'a, T&gt;&gt;);

impl&lt;T&gt; Tree&lt;T&gt; {
    pub fn iter_mut(&amp;mut self) -&gt; IterMut&lt;T&gt; {
        let mut deque = VecDeque::new();
        self.root.as_mut().map(|root| deque.push_front(root.iter_mut()));
        IterMut(deque)
    }
}

impl&lt;T&gt; Node&lt;T&gt; {
    pub fn iter_mut(&amp;mut self) -&gt; NodeIterMut&lt;T&gt; {
        NodeIterMut {
            elem: Some(&amp;mut self.elem),
            left: self.left.as_mut().map(|node| &amp;mut **node),
            right: self.right.as_mut().map(|node| &amp;mut **node),
        }
    }
}


impl&lt;'a, T&gt; Iterator for NodeIterMut&lt;'a, T&gt; {
    type Item = State&lt;'a, T&gt;;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        match self.left.take() {
            Some(node) =&gt; Some(State::Node(node)),
            None =&gt; match self.elem.take() {
                Some(elem) =&gt; Some(State::Elem(elem)),
                None =&gt; match self.right.take() {
                    Some(node) =&gt; Some(State::Node(node)),
                    None =&gt; None,
                }
            }
        }
    }
}

impl&lt;'a, T&gt; DoubleEndedIterator for NodeIterMut&lt;'a, T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        match self.right.take() {
            Some(node) =&gt; Some(State::Node(node)),
            None =&gt; match self.elem.take() {
                Some(elem) =&gt; Some(State::Elem(elem)),
                None =&gt; match self.left.take() {
                    Some(node) =&gt; Some(State::Node(node)),
                    None =&gt; None,
                }
            }
        }
    }
}

impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    type Item = &amp;'a mut T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        loop {
            match self.0.front_mut().and_then(|node_it| node_it.next()) {
                Some(State::Elem(elem)) =&gt; return Some(elem),
                Some(State::Node(node)) =&gt; self.0.push_front(node.iter_mut()),
                None =&gt; if let None = self.0.pop_front() { return None },
            }
        }
    }
}

impl&lt;'a, T&gt; DoubleEndedIterator for IterMut&lt;'a, T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        loop {
            match self.0.back_mut().and_then(|node_it| node_it.next_back()) {
                Some(State::Elem(elem)) =&gt; return Some(elem),
                Some(State::Node(node)) =&gt; self.0.push_back(node.iter_mut()),
                None =&gt; if let None = self.0.pop_back() { return None },
            }
        }
    }
}
</code></pre></pre>
<!--
All of these are completely safe and work on stable Rust! This ultimately
falls out of the simple struct case we saw before: Rust understands that you
can safely split a mutable reference into subfields. We can then encode
permanently consuming a reference via Options (or in the case of slices,
replacing with an empty slice).
-->
<p>これらは全て、完全に安全で、安定版の Rust で動作します! これは究極には、
前に見た単純な構造体のケースから外れています。すなわち、 Rust は、
可変参照を複数の副フィールドに安全に分割できると理解しているのです。
ですから Option を通じて、参照を消費することで、永続的にエンコードすることができます。
(あるいはスライスの場合、空のスライスで置き換えます)</p>
<!--
# Type Conversions
-->
<h1><a class="header" href="#型変換" id="型変換">型変換</a></h1>
<!--
At the end of the day, everything is just a pile of bits somewhere, and type
systems are just there to help us use those bits right. There are two common
problems with typing bits: needing to reinterpret those exact bits as a
different type, and needing to change the bits to have equivalent meaning for
a different type. Because Rust encourages encoding important properties in the
type system, these problems are incredibly pervasive. As such, Rust
consequently gives you several ways to solve them.
-->
<p>結局の所、全ては単に、どこかにあるビットの山なだけであり、型システムはただただ
これらのビットを正しく扱えるように手助けするためにあるのです。ビットを型付けする事には、 2 つの
問題があります。すなわち、ビットを異なる型として解釈する必要性と、同じ意味を異なる型で持たせるために
ビットを変更する必要性です。 Rust は型システム内の重要な特性をエンコードすることを奨励しているため、
これらの問題は信じられないほど蔓延しています。ですから、 Rust では結果的に、
これらの問題を解決する複数の方法があります。</p>
<!--
First we'll look at the ways that Safe Rust gives you to reinterpret values.
The most trivial way to do this is to just destructure a value into its
constituent parts and then build a new type out of them. e.g.
-->
<p>まず、安全な Rust が提供する、値を再解釈する方法について見ていきます。
最も平凡なやり方は、単に値をその構成要素に分配し、そしてそれらを用いて
新しい型の値を構築する方法です。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    x: u32,
    y: u16,
}

struct Bar {
    a: u32,
    b: u16,
}

fn reinterpret(foo: Foo) -&gt; Bar {
    let Foo { x, y } = foo;
    Bar { a: x, b: y }
}
<span class="boring">}
</span></code></pre></pre>
<!--
But this is, at best, annoying. For common conversions, Rust provides
more ergonomic alternatives.
-->
<p>しかしこれは、たとえ最良の方法だとしても、煩わしいです。
一般的な変換に関しては、 Rust はよりエルゴノミックな方法を提供しています。</p>
<!--
# Coercions
-->
<h1><a class="header" href="#型強制" id="型強制">型強制</a></h1>
<!--
Types can implicitly be coerced to change in certain contexts. These changes are
generally just *weakening* of types, largely focused around pointers and
lifetimes. They mostly exist to make Rust "just work" in more cases, and are
largely harmless.
-->
<p>特定の状況では、暗黙に型変換を強制することが出来ます。これらの変換は、一般には
単に型を<em>弱く</em>していて、主にポインタやライフタイム周りに着目されます。
これらはほとんどが、より多くのケースで Rust が &quot;単に動く&quot; ようにするために存在し、
そして大部分において、ほとんど害はありません。</p>
<!--
Here's all the kinds of coercion:
-->
<p>これらは全ての種類の型強制です:</p>
<!--
Coercion is allowed between the following types:
-->
<p>型強制は以下の型の間で認められています:</p>
<!--
* Transitivity: `T_1` to `T_3` where `T_1` coerces to `T_2` and `T_2` coerces to
  `T_3`
* Pointer Weakening:
    * `&mut T` to `&T`
    * `*mut T` to `*const T`
    * `&T` to `*const T`
    * `&mut T` to `*mut T`
* Unsizing: `T` to `U` if `T` implements `CoerceUnsized<U>`
* Deref coercion: Expression `&x` of type `&T` to `&*x` of type `&U` if `T` derefs to `U` (i.e. `T: Deref<Target=U>`)
-->
<ul>
<li>推移性: <code>T_1</code> から <code>T_3</code> 但し <code>T_1</code> が <code>T_2</code> に型強制可能で、 <code>T_2</code> が <code>T_3</code> に型強制可能な場合</li>
<li>ポインタの弱化:
<ul>
<li><code>&amp;mut T</code> から <code>&amp;T</code></li>
<li><code>*mut T</code> から <code>*const T</code></li>
<li><code>&amp;T</code> から <code>*const T</code></li>
<li><code>&amp;mut T</code> から <code>*mut T</code></li>
</ul>
</li>
<li>アンサイジング: <code>T</code> から <code>U</code> 但し <code>T</code> が <code>CoerceUnsized&lt;U&gt;</code> を実装している場合</li>
<li>参照外しの型強制: 型 <code>&amp;T</code> の式 <code>&amp;x</code> から型 <code>&amp;U</code> の式 <code>&amp;'x</code> 但し <code>T</code> が <code>U</code> に参照外しされる場合 (例: <code>T: Deref&lt;Target=U&gt;</code>)</li>
</ul>
<!--
`CoerceUnsized<Pointer<U>> for Pointer<T> where T: Unsize<U>` is implemented
for all pointer types (including smart pointers like Box and Rc). Unsize is
only implemented automatically, and enables the following transformations:
-->
<p><code>CoerceUnsized&lt;Pointer&lt;U&gt;&gt; for Pointer&lt;T&gt; where T: Unsize&lt;U&gt;</code> は
全てのポインタ型 (Box や Rc のようなスマートポインタを含む) で実装されています。
アンサイズは自動的にのみ実装され、以下の変換を有効にします。</p>
<!--
* `[T; n]` => `[T]`
* `T` => `Trait` where `T: Trait`
* `Foo<..., T, ...>` => `Foo<..., U, ...>` where:
    * `T: Unsize<U>`
    * `Foo` is a struct
    * Only the last field of `Foo` has type involving `T`
    * `T` is not part of the type of any other fields
    * `Bar<T>: Unsize<Bar<U>>`, if the last field of `Foo` has type `Bar<T>`
-->
<ul>
<li><code>[T; n]</code> =&gt; <code>[T]</code></li>
<li><code>T</code> =&gt; <code>Trait</code> 但し <code>T: Trait</code></li>
<li><code>Foo&lt;..., T, ...&gt;</code> =&gt; <code>Foo&lt;..., U, ...&gt;</code> 但し
<ul>
<li><code>T: Unsize&lt;U&gt;</code></li>
<li><code>Foo</code> は構造体</li>
<li><code>Foo</code> の最後のフィールドだけが <code>T</code> を含む型である</li>
<li><code>T</code> は他のフィールドの一部となっていない</li>
<li><code>Bar&lt;T&gt;: Unsize&lt;Bar&lt;U&gt;&gt;</code> 但し <code>Foo</code> の最後のフィールドが <code>Bar&lt;T&gt;</code> の型である場合</li>
</ul>
</li>
</ul>
<!--
Coercions occur at a *coercion site*. Any location that is explicitly typed
will cause a coercion to its type. If inference is necessary, the coercion will
not be performed. Exhaustively, the coercion sites for an expression `e` to
type `U` are:
-->
<p>型強制は、<em>型強制サイト</em>で起こります。明確に型が指定されている全ての場所で、
その型への型強制が発生します。もし推論が必要ならば、型強制は行われません。
余すことなく言えば、式 <code>e</code> に対する型 <code>U</code> への型強制サイトは以下の通りです。</p>
<!--
* let statements, statics, and consts: `let x: U = e`
* Arguments to functions: `takes_a_U(e)`
* Any expression that will be returned: `fn foo() -> U { e }`
* Struct literals: `Foo { some_u: e }`
* Array literals: `let x: [U; 10] = [e, ..]`
* Tuple literals: `let x: (U, ..) = (e, ..)`
* The last expression in a block: `let x: U = { ..; e }`
-->
<ul>
<li>let 文、 static、 const: <code>let x: U = e</code></li>
<li>関数に対する引数: <code>takes_a_U(e)</code></li>
<li>返される全ての式: <code>fn foo() -&gt; U { e }</code></li>
<li>構造体リテラル: <code>Foo { some_u: e }</code></li>
<li>配列リテラル: <code>let x: [U; 10] = [e, ..]</code></li>
<li>タプルリテラル: <code>let x: (U, ..) = (e, ..)</code></li>
<li>ブロックの最後の式: <code>let x: U = { ..; e }</code></li>
</ul>
<!--
Note that we do not perform coercions when matching traits (except for
receivers, see below). If there is an impl for some type `U` and `T` coerces to
`U`, that does not constitute an implementation for `T`. For example, the
following will not type check, even though it is OK to coerce `t` to `&T` and
there is an impl for `&T`:
-->
<p>トレイトをマッチさせる場合、型強制が行われないことに注意してください (レシーバは例外です、
以下を見てください) 。もしある型 <code>U</code> に対する impl が存在し、 <code>T</code> が <code>U</code> に型強制される場合、 <code>T</code> に対しては
実装が構成されません。例えば、以下の例では <code>t</code> が <code>&amp;T</code> に型強制されても問題なく、 <code>&amp;T</code> に対する impl が存在するにも関わらず、
型チェックに通りません。</p>
<pre><code class="language-rust ignore">trait Trait {}

fn foo&lt;X: Trait&gt;(t: X) {}

impl&lt;'a&gt; Trait for &amp;'a i32 {}


fn main() {
    let t: &amp;mut i32 = &amp;mut 0;
    foo(t);
}
</code></pre>
<pre><code class="language-text">&lt;anon&gt;:10:5: 10:8 error: the trait bound `&amp;mut i32 : Trait` is not satisfied [E0277]
(エラー: トレイト境界 `&amp;mut i32: Trait` が満たされていません)
&lt;anon&gt;:10     foo(t);
              ^~~
</code></pre>
<!--
# The Dot Operator
-->
<h1><a class="header" href="#ドットオペレータ" id="ドットオペレータ">ドットオペレータ</a></h1>
<!--
The dot operator will perform a lot of magic to convert types. It will perform
auto-referencing, auto-dereferencing, and coercion until types match.
-->
<p>ドットオペレータは型を変換するため、沢山の魔法を使います。
型がマッチするまで、自動参照、自動参照外し、そして型強制を行ないます。</p>
<!--
TODO: steal information from http://stackoverflow.com/questions/28519997/what-are-rusts-exact-auto-dereferencing-rules/28552082#28552082
-->
<p>TODO: http://stackoverflow.com/questions/28519997/what-are-rusts-exact-auto-dereferencing-rules/28552082#28552082 から情報を盗ってくる。</p>
<!--
# Casts
-->
<h1><a class="header" href="#キャスト" id="キャスト">キャスト</a></h1>
<!--
Casts are a superset of coercions: every coercion can be explicitly
invoked via a cast. However some conversions require a cast.
While coercions are pervasive and largely harmless, these "true casts"
are rare and potentially dangerous. As such, casts must be explicitly invoked
using the `as` keyword: `expr as Type`.
-->
<p>キャストは型強制のスーパーセットです。すなわち、全ての型強制は、キャストを通じて
明示的に引き起こすことが出来ます。しかし、いくつかの変換はキャストを必要とします。
型強制は普及していて、大体の場合、害はないのですが、これらの &quot;真のキャスト&quot; は稀で、
潜在的に危険です。ですから、キャストは <code>as</code> キーワードを用いて、明示的に
実行しなければなりません: <code>expr as Type</code></p>
<!--
True casts generally revolve around raw pointers and the primitive numeric
types. Even though they're dangerous, these casts are infallible at runtime.
If a cast triggers some subtle corner case no indication will be given that
this occurred. The cast will simply succeed. That said, casts must be valid
at the type level, or else they will be prevented statically. For instance,
`7u8 as bool` will not compile.
-->
<p>真のキャストは一般的に、生ポインタやプリミティブ型の数値型に関係します。
真のキャストは危険ですが、これらのキャストは実行時に失敗しません。
もしキャストが何か微妙なコーナーケースを引き起こしたとしても、
何の指摘もされないでしょう。キャストは単に成功します。そうは言ったものの、
キャストは型レベルで正しくなければなりません。でなければそのキャストは静的に
防がれます。例えば、 <code>7u8 as bool</code> はコンパイルできません。</p>
<!--
That said, casts aren't `unsafe` because they generally can't violate memory
safety *on their own*. For instance, converting an integer to a raw pointer can
very easily lead to terrible things. However the act of creating the pointer
itself is safe, because actually using a raw pointer is already marked as
`unsafe`.
-->
<p>そうは言っていますが、キャストは <code>unsafe</code> ではありません。なぜなら、
キャストは一般的に、<em>それ自体で</em>メモリ安全性を侵害しないからです。
例えば、整数を生ポインタに変換すると、非常に簡単にひどい問題を引き起しうるでしょう。
しかしながら、ポインタを生成する事自体は安全です。なぜなら、実際に生ポインタを使用すること
が既に <code>unsafe</code> としてマークされているからです。</p>
<!--
Here's an exhaustive list of all the true casts. For brevity, we will use `*`
to denote either a `*const` or `*mut`, and `integer` to denote any integral
primitive:
-->
<p>これは、全ての真のキャストを網羅しているリストです。簡潔にするため、 <code>*</code> を <code>*const</code> か <code>*mut</code> の
どちらかとして使い、 <code>integer</code> を整数型プリミティブの何かとして用います。</p>
<!--
 * `*T as *U` where `T, U: Sized`
 * `*T as *U` TODO: explain unsized situation
 * `*T as integer`
 * `integer as *T`
 * `number as number`
 * `C-like-enum as integer`
 * `bool as integer`
 * `char as integer`
 * `u8 as char`
 * `&[T; n] as *const T`
 * `fn as *T` where `T: Sized`
 * `fn as integer`
 -->
<ul>
<li><code>*T as *U</code> 但し <code>T, U: Sized</code></li>
<li><code>*T as *U</code> TODO: サイズが不定の場合について説明する</li>
<li><code>*T as integer</code></li>
<li><code>integer as *T</code></li>
<li><code>number as number</code></li>
<li><code>C-like-enum as integer</code></li>
<li><code>bool as integer</code></li>
<li><code>char as integer</code></li>
<li><code>u8 as char</code></li>
<li><code>&amp;[T; n] as *const T</code></li>
<li><code>fn as *T</code> 但し <code>T: Sized</code></li>
<li><code>fn as integer</code></li>
</ul>
<!--
Note that lengths are not adjusted when casting raw slices -
`*const [u16] as *const [u8]` creates a slice that only includes
half of the original memory.
-->
<p>生スライスをキャストする時、その長さは調整されないことに注意してください。 <code>*const [u16] as *const [u8]</code> は、
元のメモリの半分しか含まないスライスを生成します。</p>
<!--
Casting is not transitive, that is, even if `e as U1 as U2` is a valid
expression, `e as U2` is not necessarily so.
-->
<p>キャストは推移的ではありません。つまり、 <code>e as U1 as U2</code> が有効な式だとしても、 <code>e as U2</code> は
必ずしも有効とは限りません。</p>
<!--
For numeric casts, there are quite a few cases to consider:
-->
<p>数値のキャストに関しては、かなり多くの事項について考える必要があります。</p>
<!--
* casting between two integers of the same size (e.g. i32 -> u32) is a no-op
* casting from a larger integer to a smaller integer (e.g. u32 -> u8) will
  truncate
* casting from a smaller integer to a larger integer (e.g. u8 -> u32) will
    * zero-extend if the source is unsigned
    * sign-extend if the source is signed
* casting from a float to an integer will round the float towards zero
    * **[NOTE: currently this will cause Undefined Behavior if the rounded
      value cannot be represented by the target integer type][float-int]**.
      This includes Inf and NaN. This is a bug and will be fixed.
* casting from an integer to float will produce the floating point
  representation of the integer, rounded if necessary (rounding strategy
  unspecified)
* casting from an f32 to an f64 is perfect and lossless
* casting from an f64 to an f32 will produce the closest possible value
  (rounding strategy unspecified)
    * **[NOTE: currently this will cause Undefined Behavior if the value
      is finite but larger or smaller than the largest or smallest finite
      value representable by f32][float-float]**. This is a bug and will
      be fixed.
-->
<ul>
<li>同じ大きさの 2 つの整数の間でのキャスト (例: i32 -&gt; u32) は no-op です</li>
<li>大きい方の整数から小さい方の整数へのキャスト (例: u32 -&gt; u8) は切り捨てが発生します</li>
<li>小さい方の整数から大きい方の整数へのキャスト (例: u8 -&gt; u32) は
<ul>
<li>もし小さい方の整数が符号なしの場合、ゼロ拡張されます</li>
<li>もし小さい方の整数が符号ありの場合、符号拡張されます</li>
</ul>
</li>
<li>浮動小数点数から整数へのキャストは、小数点以下が切り捨てられます
<ul>
<li><strong><a href="https://github.com/rust-lang/rust/issues/10184">注意: 現在もし丸められた値が、キャスト先の整数型で表現できない場合、未定義動作を引き起こします</a></strong>。
これはバグで、将来修正されます。</li>
</ul>
</li>
<li>整数から浮動小数点数へのキャストは、整数を浮動小数点数で表現します。必要ならば丸められます (丸めの方針は指定されていません)</li>
<li>f32 から f64 へのキャストは完全で、損失はありません</li>
<li>f64 から f32 へのキャストは、最も近い表現可能な値となります (丸めの方針は指定されていません)
<ul>
<li><strong><a href="https://github.com/rust-lang/rust/issues/15536">注意: 現在もし値が f32 で表現可能な最大の値より大きい、あるいは最小の値より小さい有限の値である場合、未定義動作を引き起こします</a></strong>。
これはバグで、将来修正されます。</li>
</ul>
</li>
</ul>
<!--
# Transmutes
-->
<h1><a class="header" href="#トランスミュート" id="トランスミュート">トランスミュート</a></h1>
<!--
Get out of our way type system! We're going to reinterpret these bits or die
trying! Even though this book is all about doing things that are unsafe, I
really can't emphasize that you should deeply think about finding Another Way
than the operations covered in this section. This is really, truly, the most
horribly unsafe thing you can do in Rust. The railguards here are dental floss.
-->
<p>型システムから抜け出しましょう! 何がなんでもビットを再解釈します! この本は
アンセーフなもの全てについて書かれていますが、この章でカバーされている操作を
やるよりも、他の方法を見つけるよう深刻に考えるべきだということは、
いくら強調しようとも、強調しきれません。これは本当に、マジで、 Rust で出来る
最も恐ろしいアンセーフなことです。ここではガードレールは爪楊枝のように脆いです。</p>
<!--
`mem::transmute<T, U>` takes a value of type `T` and reinterprets it to have
type `U`. The only restriction is that the `T` and `U` are verified to have the
same size. The ways to cause Undefined Behavior with this are mind boggling.
-->
<p><code>mem::transmute&lt;T, U&gt;</code> は型 <code>T</code> の値を受け取り、その値が型 <code>U</code> であると再解釈します。
唯一の制約は、 <code>T</code> と <code>U</code> が同じサイズを持つとされていることです。
この操作によって未定義動作が起こる方法を考えると、気が遠くなります。</p>
<!--
* First and foremost, creating an instance of *any* type with an invalid state
  is going to cause arbitrary chaos that can't really be predicted.
* Transmute has an overloaded return type. If you do not specify the return type
  it may produce a surprising type to satisfy inference.
* Making a primitive with an invalid value is UB
* Transmuting between non-repr(C) types is UB
* Transmuting an & to &mut is UB
    * Transmuting an & to &mut is *always* UB
    * No you can't do it
    * No you're not special
* Transmuting to a reference without an explicitly provided lifetime
  produces an [unbounded lifetime]
-->
<ul>
<li>まず真っ先に、<em>いかなる</em>型においても、無効状態のインスタンスを作ることは、本当に予測不可能な混沌状態を引き起こすでしょう。</li>
<li>transmute はオーバーロードされたリターン型を持ちます。もしリターン型を指定しなかった場合、
推論を満たす、びっくりするような型を生成するかもしれません。</li>
<li>無効なプリミティブを生成することは未定義動作を引き起こします。</li>
<li>repr(C) でない型の間でのトランスミュートは未定義動作を引き起こします。</li>
<li>&amp; から &amp;mut へのトランスミュートは未定義動作を引き起こします。
<ul>
<li>&amp; から &amp;mut へのトランスミュートは<em>いつも</em>未定義動作を引き起こします。</li>
<li>いいえ、これは出来ません。</li>
<li>いいか、君は特別じゃないんだ。</li>
</ul>
</li>
<li>明確にライフタイムが指定されていない参照へのトランスミュートは<a href="unbounded-lifetimes.html">無制限のライフタイム</a>を生成します。</li>
</ul>
<!--
`mem::transmute_copy<T, U>` somehow manages to be *even more* wildly unsafe than
this. It copies `size_of<U>` bytes out of an `&T` and interprets them as a `U`.
The size check that `mem::transmute` has is gone (as it may be valid to copy
out a prefix), though it is Undefined Behavior for `U` to be larger than `T`.
-->
<p><code>mem::transmute_copy&lt;T, U&gt;</code> は、どうにかして transmute よりも<em>本当に更に</em>アンセーフな事をしようとします。
この関数は <code>&amp;T</code> から <code>size_of&lt;U&gt;</code> バイトコピーし、これらを <code>U</code> として解釈します。
もし <code>U</code> が <code>T</code> よりも大きい場合、未定義動作を引き起こしますが、 <code>mem::transmute</code> の
サイズチェックはなくなっています ( <code>T</code> の先頭部分をコピーすることが有効である場合があるためです) 。</p>
<!--
Also of course you can get most of the functionality of these functions using
pointer casts.
-->
<p>そしてもちろん、これらの関数の機能のほとんどを、ポインタのキャストを利用することで
得ることができます。</p>
<!--
# Working With Uninitialized Memory
-->
<h1><a class="header" href="#初期化されないメモリを扱う" id="初期化されないメモリを扱う">初期化されないメモリを扱う</a></h1>
<!--
All runtime-allocated memory in a Rust program begins its life as
*uninitialized*. In this state the value of the memory is an indeterminate pile
of bits that may or may not even reflect a valid state for the type that is
supposed to inhabit that location of memory. Attempting to interpret this memory
as a value of *any* type will cause Undefined Behavior. Do Not Do This.
-->
<p>すべての Rust の、実行時にアロケートされるメモリは、最初に<em>初期化されません</em>。
この状態では、メモリ上の値は、そのメモリ番地にあると想定される型の、正しい状態を
反映しているかもしれないし、していないかもしれないビットの無限の山です。
このメモリを<em>いかなる</em>型の値として解釈しようとしても、未定義動作を引き起こすでしょう。
絶対にしないでください。</p>
<!--
Rust provides mechanisms to work with uninitialized memory in checked (safe) and
unchecked (unsafe) ways.
-->
<p>Rust では、初期化されていないメモリを扱う、チェックが入る (安全な) 方法と、
チェックされない (アンセーフな) やり方があります。</p>
<!--
# Checked Uninitialized Memory
-->
<h1><a class="header" href="#チェックされる初期化されていないメモリ" id="チェックされる初期化されていないメモリ">チェックされる初期化されていないメモリ</a></h1>
<!--
Like C, all stack variables in Rust are uninitialized until a value is
explicitly assigned to them. Unlike C, Rust statically prevents you from ever
reading them until you do:
-->
<p>C のように、 Rust の全てのスタック上の変数は、値が明示的に代入されるまでは初期化されません。 C とは違い、 Rust では、
値が代入されるまで、初期化されていない変数を読み込もうとするのを静的に防ぎます。</p>
<pre><code class="language-rust ignore">fn main() {
    let x: i32;
    println!(&quot;{}&quot;, x);
}
</code></pre>
<pre><code class="language-text">src/main.rs:3:20: 3:21 error: use of possibly uninitialized variable: `x`
(エラー: 初期化されていないかもしれない変数 `x` を使用しています)
src/main.rs:3     println!(&quot;{}&quot;, x);
                                 ^
</code></pre>
<!--
This is based off of a basic branch analysis: every branch must assign a value
to `x` before it is first used. Interestingly, Rust doesn't require the variable
to be mutable to perform a delayed initialization if every branch assigns
exactly once. However the analysis does not take advantage of constant analysis
or anything like that. So this compiles:
-->
<p>これは、基本的な分岐分析に基づいています。すなわち、全ての分岐は、 <code>x</code> が初めに
使用される前に、値を代入しなければなりません。興味深いことに、 Rust では、もし全ての分岐の中で
値がちょうど一回しか代入されない場合、遅延初期化を行なうために変数をミュータブルにする必要がありません。
しかし、この分析は定数の分析や、それに似たものを利用していないため、このコードはコンパイルできます。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: i32;

    if true {
        x = 1;
    } else {
        x = 2;
    }

    println!(&quot;{}&quot;, x);
}
</code></pre></pre>
<!--
but this doesn't:
-->
<p>しかし、このコードはコンパイルできません。</p>
<pre><code class="language-rust ignore">fn main() {
    let x: i32;
    if true {
        x = 1;
    }
    println!(&quot;{}&quot;, x);
}
</code></pre>
<pre><code class="language-text">src/main.rs:6:17: 6:18 error: use of possibly uninitialized variable: `x`
(エラー: 初期化されていないかもしれない変数 `x` を使用しています)
src/main.rs:6   println!(&quot;{}&quot;, x);
</code></pre>
<!--
while this does:
-->
<p>一方でこのコードはコンパイルできます。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: i32;
    if true {
        x = 1;
        println!(&quot;{}&quot;, x);
    }
    // 初期化されない分岐があっても構いません。
    // 値をその分岐で使用しないからです。
}
</code></pre></pre>
<!--
Of course, while the analysis doesn't consider actual values, it does
have a relatively sophisticated understanding of dependencies and control
flow. For instance, this works:
-->
<p>もちろん、分析では実際の値は考慮されませんが、比較的洗練された、依存関係や制御フローに関する
分析は行われます。例えば、このコードは動作します。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: i32;

loop {
    // Rust は、この分岐が状況によらず選択されることは理解しません。
    // なぜならこれは、実際の値に依存するためです。
    if true {
        // しかし Rust は、この分岐がたった一回しか選択されないと理解しています。
        // なぜなら、状況によらず、この分岐を抜け出すからです。
        // それゆえ、`x` はミュータブルとしてマークされる必要がないのです。
        x = 0;
        break;
    }
}
// Rust はまた、 break に到達せずに、ここに来ることが不可能だということを知っています。
// そしてそれゆえに、 `x` はこの場所において初期化されなければならないと知っているのです!
println!(&quot;{}&quot;, x);
<span class="boring">}
</span></code></pre></pre>
<!--
If a value is moved out of a variable, that variable becomes logically
uninitialized if the type of the value isn't Copy. That is:
-->
<p>もし値の型が Copy を実装しておらず、値が変数からムーブされたら、
論理的にはその変数は初期化されていない事になります。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 0;
    let y = Box::new(0);
    let z1 = x; // i32 は Copy を実装しているため、 x はまだ有効です
    let z2 = y; // Box は Copy を実装していないため、もはや y は論理的には初期化されていません
}
</code></pre></pre>
<!--
However reassigning `y` in this example *would* require `y` to be marked as
mutable, as a Safe Rust program could observe that the value of `y` changed:
-->
<p>しかしながらこの例では、 <code>y</code> に値を再代入しようとするのであれば、 <code>y</code> を
ミュータブルとしてマークする必要が<em>あるでしょう</em>。
安全な Rust のプログラムは <code>y</code> の値が変わったと認識出来るからです。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut y = Box::new(0);
    let z = y; // Box が Copy を実装していないため、もはや y は論理的には初期化されていません
    y = Box::new(1); // y を再初期化します
}
</code></pre></pre>
<!--
Otherwise it's like `y` is a brand new variable.
-->
<p>そうでなければ、 <code>y</code> は全く新しい変数のようなものです。</p>
<!--
# Drop Flags
-->
<h1><a class="header" href="#ドロップフラグ" id="ドロップフラグ">ドロップフラグ</a></h1>
<!--
The examples in the previous section introduce an interesting problem for Rust.
We have seen that it's possible to conditionally initialize, deinitialize, and
reinitialize locations of memory totally safely. For Copy types, this isn't
particularly notable since they're just a random pile of bits. However types
with destructors are a different story: Rust needs to know whether to call a
destructor whenever a variable is assigned to, or a variable goes out of scope.
How can it do this with conditional initialization?
-->
<p>前章の例では、 Rust における興味深い問題を紹介しました。
状況によって、メモリの場所を初期化したり、初期化されていない状態に戻したり、
再初期化したりすることを、完全に安全に行なうことが可能だということを
確認してきました。 Copy を実装している型に関しては、メモリの場所にあるものは
単なるビットのランダムな山であるため、これは特に重要なことではありません。
しかし、デストラクタを備えている型に関しては話が違います。 Rust は変数が代入されたときや、
あるいは変数がスコープを外れたときは毎回、デストラクタを呼ぶかを知る必要があります。
これを、状況に応じた初期化と共に、どのように行えばよいのでしょうか?</p>
<!--
Note that this is not a problem that all assignments need worry about. In
particular, assigning through a dereference unconditionally drops, and assigning
in a `let` unconditionally doesn't drop:
-->
<p>全ての代入において心配する必要がある問題ではないことに注意してください。
特に、参照外しを通した代入では、状況によらずドロップしますし、 <code>let</code> を使用した
代入では、状況によらずドロップしません。</p>
<pre><code>let mut x = Box::new(0); // let によって新しい変数が生成されるので、ドロップの必要はありません
let y = &amp;mut x;
*y = Box::new(1); // 参照外しでは、参照される側の変数は初期化されていると見なされているため、この参照されている変数はいつもドロップします
</code></pre>
<!--
This is only a problem when overwriting a previously initialized variable or
one of its subfields.
-->
<p>これは、以前に初期化された変数や、その副フィールドの 1 つを上書きする時のみ問題となります。</p>
<!--
It turns out that Rust actually tracks whether a type should be dropped or not
*at runtime*. As a variable becomes initialized and uninitialized, a *drop flag*
for that variable is toggled. When a variable might need to be dropped, this
flag is evaluated to determine if it should be dropped.
-->
<p>実際には Rust は<em>実行時に</em>、型がドロップされるべきかそうでないかを追っていると分かります。
変数が初期化されたり、初期化されてない状態になったりすると、その変数に対する<em>ドロップフラグ</em>が
切り替わります。もし変数がドロップされる必要があるかもしれない状況になると、
本当にドロップされるべきかを決定するため、このフラグが評価されます。</p>
<!--
Of course, it is often the case that a value's initialization state can be
statically known at every point in the program. If this is the case, then the
compiler can theoretically generate more efficient code! For instance, straight-
line code has such *static drop semantics*:
-->
<p>勿論、しばしば値の初期化に関する状態は、プログラムのどの地点においても
知ることが出来ます。もしこれが本当なら、コンパイラは理論的には、
もっと効率的なコードを生成できます! 例えば、分岐のない真っ直ぐなコードは、
このような<em>静的ドロップセマンティクス</em>を持っています。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = Box::new(0); // x は初期化されていないので、単に上書きします。
let mut y = x;           // y は初期化されていないので、単に上書きします。そして x を初期化前の状態にします。
x = Box::new(0);         // x は初期化されていないので、単に上書きします。
y = x;                   // y は初期化されているので、 y をドロップし、上書きし、そして x を初期化前の状態にします!
                         // y はスコープを抜けました。 y は初期化されているので、 y をドロップします!
                         // x はスコープを抜けました。 x は初期化されていないので、何もしません。
<span class="boring">}
</span></code></pre></pre>
<!--
Similarly, branched code where all branches have the same behavior with respect
to initialization has static drop semantics:
-->
<p>同じように、全ての分岐が初期化の点において、同一のことをする分岐があるコードでは、
静的ドロップセマンティクスを持っています。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let condition = true;
</span>let mut x = Box::new(0);    // x は初期化されていないので、単に上書きします。
if condition {
    drop(x)                 // x はムーブされたので、 x を初期化前の状態にします。
} else {
    println!(&quot;{}&quot;, x);
    drop(x)                 // x はムーブされたので、 x を初期化前の状態にします。
}
x = Box::new(0);            // x は初期化されていない状態なので、単に上書きします。
                            // x はスコープを抜けました。 x は初期化されているので、 x をドロップします!
<span class="boring">}
</span></code></pre></pre>
<!--
However code like this *requires* runtime information to correctly Drop:
-->
<p>しかしながら以下のようなコードでは、正しくドロップするために実行時の情報が必要となります。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let condition = true;
</span>let x;
if condition {
    x = Box::new(0);        // x は初期化されていないので、単に上書きします。
    println!(&quot;{}&quot;, x);
}
                            // x はスコープを抜けました。 x は初期化されていないかもしれません。
                            // フラグを確認!
<span class="boring">}
</span></code></pre></pre>
<!--
Of course, in this case it's trivial to retrieve static drop semantics:
-->
<p>勿論この場合、静的ドロップセマンティクスを復活させるのは些細なことです。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let condition = true;
</span>if condition {
    let x = Box::new(0);
    println!(&quot;{}&quot;, x);
}
<span class="boring">}
</span></code></pre></pre>
<!--
The drop flags are tracked on the stack and no longer stashed in types that
implement drop.
-->
<p>ドロップフラグはスタック上で追跡され、ドロップを実装している型に
隠されることはもはやありません。</p>
<!--
# Unchecked Uninitialized Memory
-->
<h1><a class="header" href="#チェックされない初期化されていないメモリ" id="チェックされない初期化されていないメモリ">チェックされない初期化されていないメモリ</a></h1>
<!--
One interesting exception to this rule is working with arrays. Safe Rust doesn't
permit you to partially initialize an array. When you initialize an array, you
can either set every value to the same thing with `let x = [val; N]`, or you can
specify each member individually with `let x = [val1, val2, val3]`.
Unfortunately this is pretty rigid, especially if you need to initialize your
array in a more incremental or dynamic way.
-->
<p>この規則の興味深い例外に、配列があります。安全な Rust は、配列を部分的に初期化することを
認めません。配列を初期化するとき、 <code>let x = [val; N]</code> を用いて
全ての値を初期化するか、 <code>let x = [val1, val2, val3]</code> を用いて、
それぞれの要素の値を個別に指定するかのどちらかが出来ます。残念ながら、
特によりインクリメンタルなやり方や、動的な方法で配列を初期化する必要がある場合、
これは非常に融通が利きません。</p>
<!--
Unsafe Rust gives us a powerful tool to handle this problem:
`mem::uninitialized`. This function pretends to return a value when really
it does nothing at all. Using it, we can convince Rust that we have initialized
a variable, allowing us to do trickier things with conditional and incremental
initialization.
-->
<p>アンセーフな Rust では、この問題に対処するパワフルなツールが用意されています。 <code>mem::uninitialized</code> です。
この関数は本当に何もせず、値を返すふりをします。これを利用することで、 Rust に
変数が初期化されたと見なさせることができ、状況に応じた、インクリメンタルな初期化を
行ないトリッキーなことが出来ます。</p>
<!--
Unfortunately, this opens us up to all kinds of problems. Assignment has a
different meaning to Rust based on whether it believes that a variable is
initialized or not. If it's believed uninitialized, then Rust will semantically
just memcopy the bits over the uninitialized ones, and do nothing else. However
if Rust believes a value to be initialized, it will try to `Drop` the old value!
Since we've tricked Rust into believing that the value is initialized, we can no
longer safely use normal assignment.
-->
<p>残念ながら、これによってあらゆる種類の問題が浮かび上がります。
変数が初期化されていると Rust が思っているか、思っていないかによって、
代入は異なる意味を持ちます。もし初期化していないと思っている場合、 Rust は、
セマンティクス的には単にビットを初期化していないメモリにコピーし、他には
何もしません。しかし、もし値が初期化していると思っている場合、 Rust は
古い値を <code>Drop</code> しようとします! Rust に、値が初期化されていると信じ込ませるよう
トリックをしたので、もはや安全には普通の代入は使えません。</p>
<!--
This is also a problem if you're working with a raw system allocator, which
returns a pointer to uninitialized memory.
-->
<p>生のシステムアロケータを使用している場合も問題となります。このアロケータは、
初期化されていないメモリへのポインタを返すからです。</p>
<!--
To handle this, we must use the `ptr` module. In particular, it provides
three functions that allow us to assign bytes to a location in memory without
dropping the old value: `write`, `copy`, and `copy_nonoverlapping`.
-->
<p>これに対処するには、 <code>ptr</code> モジュールを使用しなければなりません。
特にこのモジュールは、古い値をドロップせずに、メモリ上の場所に値を代入することが
可能となる 3 つの関数を提供しています: <code>write</code>、<code>copy</code>、<code>copy_nonoverlapping</code>です。</p>
<!--
* `ptr::write(ptr, val)` takes a `val` and moves it into the address pointed
  to by `ptr`.
* `ptr::copy(src, dest, count)` copies the bits that `count` T's would occupy
  from src to dest. (this is equivalent to memmove -- note that the argument
  order is reversed!)
* `ptr::copy_nonoverlapping(src, dest, count)` does what `copy` does, but a
  little faster on the assumption that the two ranges of memory don't overlap.
  (this is equivalent to memcpy -- note that the argument order is reversed!)
-->
<ul>
<li><code>ptr::write(ptr, val)</code> は <code>val</code> を受け取り、 <code>ptr</code> が指し示すアドレスに受け取った値を
移します。</li>
<li><code>ptr::copy(src, dest, count)</code> は、 T 型の <code>count</code> が占有するビット数だけ、 src から dest に
コピーします。 (これは memmove と同じです -- 引数の順序が逆転していることに注意してください!)</li>
<li><code>ptr::copy_nonoverlapping(src, dest, count)</code> は <code>copy</code> と同じことをしますが、 2 つのメモリ領域が
重なっていないと見なしているため、若干高速です。 (これは memcpy と同じです -- 引数の
順序が逆転していることに注意してください!)</li>
</ul>
<!--
It should go without saying that these functions, if misused, will cause serious
havoc or just straight up Undefined Behavior. The only things that these
functions *themselves* require is that the locations you want to read and write
are allocated. However the ways writing arbitrary bits to arbitrary
locations of memory can break things are basically uncountable!
-->
<p>言うまでもないのですが、もしこれらの関数が誤用されると、甚大な被害を引き起こしたり、
未定義動作を引き起こすでしょう。これらの関数<em>自体</em>が必要とする唯一のものは、
読み書きしたい場所がアロケートされているということです。しかし、
任意のビットを任意のメモリの場所に書き込むことでものを壊すようなやり方は数え切れません!</p>
<!--
Putting this all together, we get the following:
-->
<p>これらを全部一緒にすると、以下のようなコードとなります。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem;
use std::ptr;

// 配列の大きさはハードコードされていますが，簡単に変えられます。
// これは、配列を初期化するのに [a, b, c] という構文を使えないことを意味しますがね!
const SIZE: usize = 10;

let mut x: [Box&lt;u32&gt;; SIZE];

unsafe {
	// Rust に x が完全に初期化されたと思わせます
	x = mem::uninitialized();
	for i in 0..SIZE {
		// 非常に注意深く、それぞれのインデックスを読み込まずに上書きします
		// 注意: 例外安全性は考慮されていません。 Box はパニックできません
		ptr::write(&amp;mut x[i], Box::new(i as u32));
	}
}

println!(&quot;{:?}&quot;, x);
<span class="boring">}
</span></code></pre></pre>
<!--
It's worth noting that you don't need to worry about `ptr::write`-style
shenanigans with types which don't implement `Drop` or contain `Drop` types,
because Rust knows not to try to drop them. Similarly you should be able to
assign to fields of partially initialized structs directly if those fields don't
contain any `Drop` types.
-->
<p><code>Drop</code> を実装していない型や、 <code>Drop</code> を実装する型を含まない型との、<code>ptr::write</code> スタイルの
いたずらを心配しなくてよいということは注目に値します。なぜなら Rust は、これらをドロップしようと
しないと知っているからです。同じように、もし部分的に初期化されている構造体のフィールドに <code>Drop</code> を
実装しているものが存在しない場合、このフィールド群に直接代入できるようにするべきです。</p>
<!--
However when working with uninitialized memory you need to be ever-vigilant for
Rust trying to drop values you make like this before they're fully initialized.
Every control path through that variable's scope must initialize the value
before it ends, if it has a destructor.
*[This includes code panicking](unwinding.html)*.
-->
<p>しかし、初期化されていないメモリを扱うとき、生成した値を Rust が、以前に
完全に初期化されたものと見なしてドロップしようとしてしまわないか、常に警戒する必要があります。
値がデストラクタを持つ場合、変数のスコープを通り抜ける全てのコントロールパスは、終了時までに
その値を初期化する必要があります。<em><a href="unwinding.html">これはコードパニックを含みます</a></em></p>
<!--
And that's about it for working with uninitialized memory! Basically nothing
anywhere expects to be handed uninitialized memory, so if you're going to pass
it around at all, be sure to be *really* careful.
-->
<p>まあ、初期化されていないメモリを扱うことに関してはこんなものです。
基本的にどのような場所でも、初期化されていないメモリが渡されることは予期していません。
ですからもしそのようなメモリを分配する場合、確実に<em>本当に</em>注意深く行なってください。</p>
<!-- # The Perils Of Ownership Based Resource Management (OBRM) -->
<h1><a class="header" href="#所有権に基づいたリソース管理ownership-based-resource-management-obrmの危険性について" id="所有権に基づいたリソース管理ownership-based-resource-management-obrmの危険性について">所有権に基づいたリソース管理(Ownership Based Resource Management, OBRM)の危険性について</a></h1>
<!--
OBRM (AKA RAII: Resource Acquisition Is Initialization) is something you'll
interact with a lot in Rust. Especially if you use the standard library.
-->
<p>OBRM(またの名をRAII: Resource Acquisition Is Initialization)とは、Rustにおいて
関連性の深い概念です。特に標準ライブラリと密接に関与します。</p>
<!--
Roughly speaking the pattern is as follows: to acquire a resource, you create an
object that manages it. To release the resource, you simply destroy the object,
and it cleans up the resource for you. The most common "resource" this pattern
manages is simply *memory*. `Box`, `Rc`, and basically everything in
`std::collections` is a convenience to enable correctly managing memory. This is
particularly important in Rust because we have no pervasive GC to rely on for
memory management. Which is the point, really: Rust is about control. However we
are not limited to just memory. Pretty much every other system resource like a
thread, file, or socket is exposed through this kind of API.
-->
<p>このパターンを簡単に説明すると次のようになります。「リソースを獲得するには
そのリソースを管理するオブジェクトを作成し、リソースを解放するにはその
オブジェクトを単に破棄すればリソースがクリーンアップされる。」
いうものです。このように管理される最も一般的な「リソース」は単なる<strong>メモリ</strong>です。
<code>Box</code>、<code>Rc</code>、その他<code>std::collections</code>の諸々全ては、メモリの管理を便利にするためのものです。
Rustの場合、メモリの管理において一貫したGCに頼るということができないので、これら
は特に重要になります。大事なことなので強調しましょう。この「管理」という考え方は
Rustの根幹です。それは何もメモリに限った話ではありません。スレッド、ファイル、
ソケットといったほぼ全てのリソースがこういった考え方に基づくAPIを通して扱うように
できています。</p>
<!--
# Constructors
-->
<h1><a class="header" href="#コンストラクタ" id="コンストラクタ">コンストラクタ</a></h1>
<!--
There is exactly one way to create an instance of a user-defined type: name it,
and initialize all its fields at once:
-->
<p>ユーザが定義した型のインスタンスを作る方法はただ一つしかありません: 型名を決めて、
全てのフィールドをいっぺんに初期化することです。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    a: u8,
    b: u32,
    c: bool,
}

enum Bar {
    X(u32),
    Y(bool),
}

struct Unit;

let foo = Foo { a: 0, b: 1, c: false };
let bar = Bar::X(0);
let empty = Unit;
<span class="boring">}
</span></code></pre></pre>
<!--
That's it. Every other way you make an instance of a type is just calling a
totally vanilla function that does some stuff and eventually bottoms out to The
One True Constructor.
-->
<p>以上。これ以外の型のインスタンスを作る方法は皆、単にいくつかのことを行なう全く普通の
関数を呼び、結局 1 つの真のコンストラクタに辿り着くのです。</p>
<!--
Unlike C++, Rust does not come with a slew of built-in kinds of constructor.
There are no Copy, Default, Assignment, Move, or whatever constructors. The
reasons for this are varied, but it largely boils down to Rust's philosophy of
*being explicit*.
-->
<p>C++ と違い、 Rust は沢山の組み込みコンストラクタを備えていません。
Rust には、 Copy、 Default、 Assignment、 Moveやその他諸々のコンストラクタが
ありません。理由は様々ですが、大体 Rust の考え方である、<em>明確であること</em>、という事に
落ち着きます。</p>
<!--
Move constructors are meaningless in Rust because we don't enable types to
"care" about their location in memory. Every type must be ready for it to be
blindly memcopied to somewhere else in memory. This means pure on-the-stack-but-
still-movable intrusive linked lists are simply not happening in Rust (safely).
-->
<p>Move コンストラクタは Rust においては意味がありません。なぜなら、型が、自身の
メモリ上の場所を &quot;気にする&quot; ようにはしないからです。すべての型は何もしなくても、
メモリ中のどこか別の場所にコピー出来るよう準備されなければなりません。
これは、純粋な、スタック上にあるけれどもそれでも動かすことの出来る、
あるノードの次のノードへのポインタをそのノード自身が保持する線形リストは (安全には) 存在し得ない
事を意味します。</p>
<!--
Assignment and copy constructors similarly don't exist because move semantics
are the only semantics in Rust. At most `x = y` just moves the bits of y into
the x variable. Rust does provide two facilities for providing C++'s copy-
oriented semantics: `Copy` and `Clone`. Clone is our moral equivalent of a copy
constructor, but it's never implicitly invoked. You have to explicitly call
`clone` on an element you want to be cloned. Copy is a special case of Clone
where the implementation is just "copy the bits". Copy types *are* implicitly
cloned whenever they're moved, but because of the definition of Copy this just
means not treating the old copy as uninitialized -- a no-op.
-->
<p>Assignment コンストラクタや Copy コンストラクタも同様に存在しません。
なぜなら、ムーブセマンティクスは Rust における唯一のセマンティクスだからです。
せいぜい <code>x = y</code> が単に y のビットを変数 x に移すくらいです。 Rust では C++ の
コピー指向のセマンティクスを提供する、 2 つの機能があります。 <code>Copy</code> と <code>Clone</code> です。 Clone は Copy コンストラクタと
同じようなものですが、暗黙に呼び出されることは一切ありません。クローンを生成したい要素に対して、
明示的に <code>clone</code> を呼び出す必要があります。 Copy は Clone の特別なケースで、
実装は単純に &quot;ビットをコピーする&quot; ことです。 Copy を実装する型は、
ムーブが発生すると毎回クローンを生成<em>します</em>。しかし、 Copy の定義によって、
これは、古いコピーを初期化されていないとは扱わない事を単に意味します。つまり no-op なのです。</p>
<!--
While Rust provides a `Default` trait for specifying the moral equivalent of a
default constructor, it's incredibly rare for this trait to be used. This is
because variables [aren't implicitly initialized][uninit]. Default is basically
only useful for generic programming. In concrete contexts, a type will provide a
static `new` method for any kind of "default" constructor. This has no relation
to `new` in other languages and has no special meaning. It's just a naming
convention.
-->
<p>Rust は Default コンストラクタと同等のものを指定する、 <code>Default</code> トレイトを
提供していますが、このトレイトが使用されるのは驚くほど稀です。なぜなら、
変数は<a href="uninitialized.html">暗黙には初期化されない</a>からです。 Default は、
基本的にはジェネリックプログラミングでのみ有用です。具体例では、
あらゆる種類の &quot;デフォルトの&quot; コンストラクタに対して、このトレイトを実装する型が静的な <code>new</code> メソッドを
提供します。これは他の言語における <code>new</code> とは関係がなく、特に意味はありません。
これはただの命名規則です。</p>
<!--
TODO: talk about "placement new"?
-->
<p>TODO: &quot;placement new&quot; について話す?</p>
<h1><a class="header" href="#destructors" id="destructors">Destructors</a></h1>
<p>What the language <em>does</em> provide is full-blown automatic destructors through the
<code>Drop</code> trait, which provides the following method:</p>
<pre><code class="language-rust ignore">fn drop(&amp;mut self);
</code></pre>
<p>This method gives the type time to somehow finish what it was doing.</p>
<p><strong>After <code>drop</code> is run, Rust will recursively try to drop all of the fields
of <code>self</code>.</strong></p>
<p>This is a convenience feature so that you don't have to write &quot;destructor
boilerplate&quot; to drop children. If a struct has no special logic for being
dropped other than dropping its children, then it means <code>Drop</code> doesn't need to
be implemented at all!</p>
<p><strong>There is no stable way to prevent this behavior in Rust 1.0.</strong></p>
<p>Note that taking <code>&amp;mut self</code> means that even if you could suppress recursive
Drop, Rust will prevent you from e.g. moving fields out of self. For most types,
this is totally fine.</p>
<p>For instance, a custom implementation of <code>Box</code> might write <code>Drop</code> like this:</p>
<pre><pre class="playground"><code class="language-rust">#![feature(alloc, heap_api, unique)]

extern crate alloc;

use std::ptr::{drop_in_place, Unique};
use std::mem;

use alloc::heap;

struct Box&lt;T&gt;{ ptr: Unique&lt;T&gt; }

impl&lt;T&gt; Drop for Box&lt;T&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            drop_in_place(*self.ptr);
            heap::deallocate((*self.ptr) as *mut u8,
                             mem::size_of::&lt;T&gt;(),
                             mem::align_of::&lt;T&gt;());
        }
    }
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>and this works fine because when Rust goes to drop the <code>ptr</code> field it just sees
a <a href="phantom-data.html">Unique</a> that has no actual <code>Drop</code> implementation. Similarly nothing can
use-after-free the <code>ptr</code> because when drop exits, it becomes inaccessible.</p>
<p>However this wouldn't work:</p>
<pre><pre class="playground"><code class="language-rust">#![feature(alloc, heap_api, unique)]

extern crate alloc;

use std::ptr::{drop_in_place, Unique};
use std::mem;

use alloc::heap;

struct Box&lt;T&gt;{ ptr: Unique&lt;T&gt; }

impl&lt;T&gt; Drop for Box&lt;T&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            drop_in_place(*self.ptr);
            heap::deallocate((*self.ptr) as *mut u8,
                             mem::size_of::&lt;T&gt;(),
                             mem::align_of::&lt;T&gt;());
        }
    }
}

struct SuperBox&lt;T&gt; { my_box: Box&lt;T&gt; }

impl&lt;T&gt; Drop for SuperBox&lt;T&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            // Hyper-optimized: deallocate the box's contents for it
            // without `drop`ing the contents
            heap::deallocate((*self.my_box.ptr) as *mut u8,
                             mem::size_of::&lt;T&gt;(),
                             mem::align_of::&lt;T&gt;());
        }
    }
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>After we deallocate the <code>box</code>'s ptr in SuperBox's destructor, Rust will
happily proceed to tell the box to Drop itself and everything will blow up with
use-after-frees and double-frees.</p>
<p>Note that the recursive drop behavior applies to all structs and enums
regardless of whether they implement Drop. Therefore something like</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Boxy&lt;T&gt; {
    data1: Box&lt;T&gt;,
    data2: Box&lt;T&gt;,
    info: u32,
}
<span class="boring">}
</span></code></pre></pre>
<p>will have its data1 and data2's fields destructors whenever it &quot;would&quot; be
dropped, even though it itself doesn't implement Drop. We say that such a type
<em>needs Drop</em>, even though it is not itself Drop.</p>
<p>Similarly,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Link {
    Next(Box&lt;Link&gt;),
    None,
}
<span class="boring">}
</span></code></pre></pre>
<p>will have its inner Box field dropped if and only if an instance stores the
Next variant.</p>
<p>In general this works really nicely because you don't need to worry about
adding/removing drops when you refactor your data layout. Still there's
certainly many valid usecases for needing to do trickier things with
destructors.</p>
<p>The classic safe solution to overriding recursive drop and allowing moving out
of Self during <code>drop</code> is to use an Option:</p>
<pre><pre class="playground"><code class="language-rust">#![feature(alloc, heap_api, unique)]

extern crate alloc;

use std::ptr::{drop_in_place, Unique};
use std::mem;

use alloc::heap;

struct Box&lt;T&gt;{ ptr: Unique&lt;T&gt; }

impl&lt;T&gt; Drop for Box&lt;T&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            drop_in_place(*self.ptr);
            heap::deallocate((*self.ptr) as *mut u8,
                             mem::size_of::&lt;T&gt;(),
                             mem::align_of::&lt;T&gt;());
        }
    }
}

struct SuperBox&lt;T&gt; { my_box: Option&lt;Box&lt;T&gt;&gt; }

impl&lt;T&gt; Drop for SuperBox&lt;T&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            // Hyper-optimized: deallocate the box's contents for it
            // without `drop`ing the contents. Need to set the `box`
            // field as `None` to prevent Rust from trying to Drop it.
            let my_box = self.my_box.take().unwrap();
            heap::deallocate((*my_box.ptr) as *mut u8,
                             mem::size_of::&lt;T&gt;(),
                             mem::align_of::&lt;T&gt;());
            mem::forget(my_box);
        }
    }
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>However this has fairly odd semantics: you're saying that a field that <em>should</em>
always be Some <em>may</em> be None, just because that happens in the destructor. Of
course this conversely makes a lot of sense: you can call arbitrary methods on
self during the destructor, and this should prevent you from ever doing so after
deinitializing the field. Not that it will prevent you from producing any other
arbitrarily invalid state in there.</p>
<p>On balance this is an ok choice. Certainly what you should reach for by default.
However, in the future we expect there to be a first-class way to announce that
a field shouldn't be automatically dropped.</p>
<h1><a class="header" href="#leaking" id="leaking">Leaking</a></h1>
<p>Ownership-based resource management is intended to simplify composition. You
acquire resources when you create the object, and you release the resources when
it gets destroyed. Since destruction is handled for you, it means you can't
forget to release the resources, and it happens as soon as possible! Surely this
is perfect and all of our problems are solved.</p>
<p>Everything is terrible and we have new and exotic problems to try to solve.</p>
<p>Many people like to believe that Rust eliminates resource leaks. In practice,
this is basically true. You would be surprised to see a Safe Rust program
leak resources in an uncontrolled way.</p>
<p>However from a theoretical perspective this is absolutely not the case, no
matter how you look at it. In the strictest sense, &quot;leaking&quot; is so abstract as
to be unpreventable. It's quite trivial to initialize a collection at the start
of a program, fill it with tons of objects with destructors, and then enter an
infinite event loop that never refers to it. The collection will sit around
uselessly, holding on to its precious resources until the program terminates (at
which point all those resources would have been reclaimed by the OS anyway).</p>
<p>We may consider a more restricted form of leak: failing to drop a value that is
unreachable. Rust also doesn't prevent this. In fact Rust <em>has a function for
doing this</em>: <code>mem::forget</code>. This function consumes the value it is passed <em>and
then doesn't run its destructor</em>.</p>
<p>In the past <code>mem::forget</code> was marked as unsafe as a sort of lint against using
it, since failing to call a destructor is generally not a well-behaved thing to
do (though useful for some special unsafe code). However this was generally
determined to be an untenable stance to take: there are many ways to fail to
call a destructor in safe code. The most famous example is creating a cycle of
reference-counted pointers using interior mutability.</p>
<p>It is reasonable for safe code to assume that destructor leaks do not happen, as
any program that leaks destructors is probably wrong. However <em>unsafe</em> code
cannot rely on destructors to be run in order to be safe. For most types this
doesn't matter: if you leak the destructor then the type is by definition
inaccessible, so it doesn't matter, right? For instance, if you leak a <code>Box&lt;u8&gt;</code>
then you waste some memory but that's hardly going to violate memory-safety.</p>
<p>However where we must be careful with destructor leaks are <em>proxy</em> types. These
are types which manage access to a distinct object, but don't actually own it.
Proxy objects are quite rare. Proxy objects you'll need to care about are even
rarer. However we'll focus on three interesting examples in the standard
library:</p>
<ul>
<li><code>vec::Drain</code></li>
<li><code>Rc</code></li>
<li><code>thread::scoped::JoinGuard</code></li>
</ul>
<h2><a class="header" href="#drain" id="drain">Drain</a></h2>
<p><code>drain</code> is a collections API that moves data out of the container without
consuming the container. This enables us to reuse the allocation of a <code>Vec</code>
after claiming ownership over all of its contents. It produces an iterator
(Drain) that returns the contents of the Vec by-value.</p>
<p>Now, consider Drain in the middle of iteration: some values have been moved out,
and others haven't. This means that part of the Vec is now full of logically
uninitialized data! We could backshift all the elements in the Vec every time we
remove a value, but this would have pretty catastrophic performance
consequences.</p>
<p>Instead, we would like Drain to fix the Vec's backing storage when it is
dropped. It should run itself to completion, backshift any elements that weren't
removed (drain supports subranges), and then fix Vec's <code>len</code>. It's even
unwinding-safe! Easy!</p>
<p>Now consider the following:</p>
<pre><code class="language-rust ignore">let mut vec = vec![Box::new(0); 4];

{
    // start draining, vec can no longer be accessed
    let mut drainer = vec.drain(..);

    // pull out two elements and immediately drop them
    drainer.next();
    drainer.next();

    // get rid of drainer, but don't call its destructor
    mem::forget(drainer);
}

// Oops, vec[0] was dropped, we're reading a pointer into free'd memory!
println!(&quot;{}&quot;, vec[0]);
</code></pre>
<p>This is pretty clearly Not Good. Unfortunately, we're kind of stuck between a
rock and a hard place: maintaining consistent state at every step has an
enormous cost (and would negate any benefits of the API). Failing to maintain
consistent state gives us Undefined Behavior in safe code (making the API
unsound).</p>
<p>So what can we do? Well, we can pick a trivially consistent state: set the Vec's
len to be 0 when we start the iteration, and fix it up if necessary in the
destructor. That way, if everything executes like normal we get the desired
behavior with minimal overhead. But if someone has the <em>audacity</em> to
mem::forget us in the middle of the iteration, all that does is <em>leak even more</em>
(and possibly leave the Vec in an unexpected but otherwise consistent state).
Since we've accepted that mem::forget is safe, this is definitely safe. We call
leaks causing more leaks a <em>leak amplification</em>.</p>
<h2><a class="header" href="#rc" id="rc">Rc</a></h2>
<p>Rc is an interesting case because at first glance it doesn't appear to be a
proxy value at all. After all, it manages the data it points to, and dropping
all the Rcs for a value will drop that value. Leaking an Rc doesn't seem like it
would be particularly dangerous. It will leave the refcount permanently
incremented and prevent the data from being freed or dropped, but that seems
just like Box, right?</p>
<p>Nope.</p>
<p>Let's consider a simplified implementation of Rc:</p>
<pre><code class="language-rust ignore">struct Rc&lt;T&gt; {
    ptr: *mut RcBox&lt;T&gt;,
}

struct RcBox&lt;T&gt; {
    data: T,
    ref_count: usize,
}

impl&lt;T&gt; Rc&lt;T&gt; {
    fn new(data: T) -&gt; Self {
        unsafe {
            // Wouldn't it be nice if heap::allocate worked like this?
            let ptr = heap::allocate::&lt;RcBox&lt;T&gt;&gt;();
            ptr::write(ptr, RcBox {
                data: data,
                ref_count: 1,
            });
            Rc { ptr: ptr }
        }
    }

    fn clone(&amp;self) -&gt; Self {
        unsafe {
            (*self.ptr).ref_count += 1;
        }
        Rc { ptr: self.ptr }
    }
}

impl&lt;T&gt; Drop for Rc&lt;T&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            (*self.ptr).ref_count -= 1;
            if (*self.ptr).ref_count == 0 {
                // drop the data and then free it
                ptr::read(self.ptr);
                heap::deallocate(self.ptr);
            }
        }
    }
}
</code></pre>
<p>This code contains an implicit and subtle assumption: <code>ref_count</code> can fit in a
<code>usize</code>, because there can't be more than <code>usize::MAX</code> Rcs in memory. However
this itself assumes that the <code>ref_count</code> accurately reflects the number of Rcs
in memory, which we know is false with <code>mem::forget</code>. Using <code>mem::forget</code> we can
overflow the <code>ref_count</code>, and then get it down to 0 with outstanding Rcs. Then
we can happily use-after-free the inner data. Bad Bad Not Good.</p>
<p>This can be solved by just checking the <code>ref_count</code> and doing <em>something</em>. The
standard library's stance is to just abort, because your program has become
horribly degenerate. Also <em>oh my gosh</em> it's such a ridiculous corner case.</p>
<h2><a class="header" href="#threadscopedjoinguard" id="threadscopedjoinguard">thread::scoped::JoinGuard</a></h2>
<p>The thread::scoped API intends to allow threads to be spawned that reference
data on their parent's stack without any synchronization over that data by
ensuring the parent joins the thread before any of the shared data goes out
of scope.</p>
<pre><code class="language-rust ignore">pub fn scoped&lt;'a, F&gt;(f: F) -&gt; JoinGuard&lt;'a&gt;
    where F: FnOnce() + Send + 'a
</code></pre>
<p>Here <code>f</code> is some closure for the other thread to execute. Saying that
<code>F: Send +'a</code> is saying that it closes over data that lives for <code>'a</code>, and it
either owns that data or the data was Sync (implying <code>&amp;data</code> is Send).</p>
<p>Because JoinGuard has a lifetime, it keeps all the data it closes over
borrowed in the parent thread. This means the JoinGuard can't outlive
the data that the other thread is working on. When the JoinGuard <em>does</em> get
dropped it blocks the parent thread, ensuring the child terminates before any
of the closed-over data goes out of scope in the parent.</p>
<p>Usage looked like:</p>
<pre><code class="language-rust ignore">let mut data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
{
    let guards = vec![];
    for x in &amp;mut data {
        // Move the mutable reference into the closure, and execute
        // it on a different thread. The closure has a lifetime bound
        // by the lifetime of the mutable reference `x` we store in it.
        // The guard that is returned is in turn assigned the lifetime
        // of the closure, so it also mutably borrows `data` as `x` did.
        // This means we cannot access `data` until the guard goes away.
        let guard = thread::scoped(move || {
            *x *= 2;
        });
        // store the thread's guard for later
        guards.push(guard);
    }
    // All guards are dropped here, forcing the threads to join
    // (this thread blocks here until the others terminate).
    // Once the threads join, the borrow expires and the data becomes
    // accessible again in this thread.
}
// data is definitely mutated here.
</code></pre>
<p>In principle, this totally works! Rust's ownership system perfectly ensures it!
...except it relies on a destructor being called to be safe.</p>
<pre><code class="language-rust ignore">let mut data = Box::new(0);
{
    let guard = thread::scoped(|| {
        // This is at best a data race. At worst, it's also a use-after-free.
        *data += 1;
    });
    // Because the guard is forgotten, expiring the loan without blocking this
    // thread.
    mem::forget(guard);
}
// So the Box is dropped here while the scoped thread may or may not be trying
// to access it.
</code></pre>
<p>Dang. Here the destructor running was pretty fundamental to the API, and it had
to be scrapped in favor of a completely different design.</p>
<!--
# Unwinding
-->
<h1><a class="header" href="#巻き戻し" id="巻き戻し">巻き戻し</a></h1>
<!--
Rust has a *tiered* error-handling scheme:
-->
<p>Rustのエラーハンドリングには<strong>階層的な</strong>スキームが存在します。</p>
<!--
* If something might reasonably be absent, Option is used.
* If something goes wrong and can reasonably be handled, Result is used.
* If something goes wrong and cannot reasonably be handled, the thread panics.
* If something catastrophic happens, the program aborts.
-->
<ul>
<li>もし何かが、明確な理由があって欠如しうる場合、Optionが使われます</li>
<li>もし何かおかしなことが起こった際に合理的な対処方法がある場合、Resultが使われます</li>
<li>もし何かおかしなことが起こった際に合理的な対処方法がない場合、そのスレッドはパニックします</li>
<li>もし何か破滅的な出来事が起こった場合、プログラムはアボートします</li>
</ul>
<!--
Option and Result are overwhelmingly preferred in most situations, especially
since they can be promoted into a panic or abort at the API user's discretion.
Panics cause the thread to halt normal execution and unwind its stack, calling
destructors as if every function instantly returned.
-->
<p>大抵の状況では圧倒的にOptionとResultが好まれます。というのもAPIのユーザーの
裁量次第でパニックやアボートさせることも可能だからです。パニックはスレッドの正常処理を
停止し、スタックを巻き戻し、全ての関数が即座にリターンしたかのようにデストラクタ
を呼び出します。</p>
<!--
As of 1.0, Rust is of two minds when it comes to panics. In the long-long-ago,
Rust was much more like Erlang. Like Erlang, Rust had lightweight tasks,
and tasks were intended to kill themselves with a panic when they reached an
untenable state. Unlike an exception in Java or C++, a panic could not be
caught at any time. Panics could only be caught by the owner of the task, at which
point they had to be handled or *that* task would itself panic.
-->
<p>バージョン1.0以降のRustはパニック時に２種類の対処法を用いるようになりました。
大昔、Rustは今よりもErlangによく似ていました。Erlangと同様、Rustには軽量のタスク
が存在し、タスクが続行不可能な状態に陥った際にはタスクが自分自身をパニックによって
killすることを意図して設計されていました。JavaやC++の例外と違い、パニックはいかなる
場合においても捕捉することはできませんでした。パニックを捕捉できるのはタスクの
オーナーのみであり、その時点で適切にハンドリングされるか、<strong>その</strong>タスク
(訳注: オーナーとなるタスク)自体がパニックするかのどちらかでした。</p>
<!--
Unwinding was important to this story because if a task's
destructors weren't called, it would cause memory and other system resources to
leak. Since tasks were expected to die during normal execution, this would make
Rust very poor for long-running systems!
-->
<p>この一連の流れの中では、タスクのデスクトラクタが呼ばれなかった場合にメモリ及び
その他のシステムリソースがリークを起こす可能性があったため、巻き戻しが重要でした。
タスクは通常の実行中にも死ぬ可能性があると想定されていたため、Rustのこういった
特徴は長期間実行されるシステムを作る上でとても不適切でした。</p>
<!--
As the Rust we know today came to be, this style of programming grew out of
fashion in the push for less-and-less abstraction. Light-weight tasks were
killed in the name of heavy-weight OS threads. Still, on stable Rust as of 1.0
panics can only be caught by the parent thread. This means catching a panic
requires spinning up an entire OS thread! This unfortunately stands in conflict
to Rust's philosophy of zero-cost abstractions.
-->
<p>Rustが現在の形に近づく過程で、より抽象化を少なくしたいという時流に押された
スタイルのプログラミングが確立していき、その過程で軽量のタスクは重量級の
OSスレッドに駆逐・統一されました
（訳注: いわゆるグリーンスレッドとネイティブスレッドの話）。しかしながら
Rust1.0の時点ではパニックはその親スレッドによってのみ補足が可能という仕様であった
ため、 パニックの補足時にOSのスレッドを丸ごと巻き戻してしまう必要
があったのです！不幸なことにこれはゼロコスト抽象化というRustの思想と
真っ向からぶつかってしまいました。</p>
<!--
There is an unstable API called `catch_panic` that enables catching a panic
without spawning a thread. Still, we would encourage you to only do this
sparingly. In particular, Rust's current unwinding implementation is heavily
optimized for the "doesn't unwind" case. If a program doesn't unwind, there
should be no runtime cost for the program being *ready* to unwind. As a
consequence, actually unwinding will be more expensive than in e.g. Java.
Don't build your programs to unwind under normal circumstances. Ideally, you
should only panic for programming errors or *extreme* problems.
-->
<p>一応 <code>catch_panic</code> というunstableなAPIが存在し、これによってスレッドをspawn
することなくパニックを補足することはできます。</p>
<blockquote>
<p>訳注: その後 <code>recover</code> -&gt; <code>catch_unwind</code> と変更され、Rust1.9でstableになりました。</p>
</blockquote>
<p>とはいえあくまでこれは代替手段として用いることを推奨します。現在のRustの巻き戻し
は「巻き戻ししない」ケースに偏った最適化をしています。巻き戻しが発生しないとわかって
いれば、プログラムが巻き戻しの<strong>準備</strong>をするためのランタイムコストも無くなるためです。
結果として、実際にはJavaのような言語よりも巻き戻しのコストは高くなっています。
したがって通常の状況では巻き戻ししないようなプログラムの作成を心がけるべきです。
<strong>非常に大きな</strong>問題の発生時やプログラミングエラーに対してのみパニックすべきです。</p>
<!--
Rust's unwinding strategy is not specified to be fundamentally compatible
with any other language's unwinding. As such, unwinding into Rust from another
language, or unwinding into another language from Rust is Undefined Behavior.
You must *absolutely* catch any panics at the FFI boundary! What you do at that
point is up to you, but *something* must be done. If you fail to do this,
at best, your application will crash and burn. At worst, your application *won't*
crash and burn, and will proceed with completely clobbered state.
-->
<p>Rustの巻き戻しの取り扱い方針は、他の言語のそれと根本から同等になるように設計されて
はいません。したがって他の言語で発生した巻き戻しがRustに波及したり、逆にRustから
多言語に波及したりといった動作は未定義となっています。
FFIの構築時には<strong>絶対に</strong>全てのパニックを境界部でキャッチしなくてはなりません。
キャッチの結果どのように対処するかはプログラマ次第ですが、とにかく<strong>何か</strong>を
しなくてはなりません。そうしなければ、良くてアプリケーションがクラッシュ・炎上します。
最悪のケースではアプリケーションがクラッシュ・炎上<strong>しません</strong>。完全にボロボロの状態
のまま走り続けます。</p>
<h1><a class="header" href="#exception-safety" id="exception-safety">Exception Safety</a></h1>
<p>Although programs should use unwinding sparingly, there's a lot of code that
<em>can</em> panic. If you unwrap a None, index out of bounds, or divide by 0, your
program will panic. On debug builds, every arithmetic operation can panic
if it overflows. Unless you are very careful and tightly control what code runs,
pretty much everything can unwind, and you need to be ready for it.</p>
<p>Being ready for unwinding is often referred to as <em>exception safety</em>
in the broader programming world. In Rust, there are two levels of exception
safety that one may concern themselves with:</p>
<ul>
<li>
<p>In unsafe code, we <em>must</em> be exception safe to the point of not violating
memory safety. We'll call this <em>minimal</em> exception safety.</p>
</li>
<li>
<p>In safe code, it is <em>good</em> to be exception safe to the point of your program
doing the right thing. We'll call this <em>maximal</em> exception safety.</p>
</li>
</ul>
<p>As is the case in many places in Rust, Unsafe code must be ready to deal with
bad Safe code when it comes to unwinding. Code that transiently creates
unsound states must be careful that a panic does not cause that state to be
used. Generally this means ensuring that only non-panicking code is run while
these states exist, or making a guard that cleans up the state in the case of
a panic. This does not necessarily mean that the state a panic witnesses is a
fully coherent state. We need only guarantee that it's a <em>safe</em> state.</p>
<p>Most Unsafe code is leaf-like, and therefore fairly easy to make exception-safe.
It controls all the code that runs, and most of that code can't panic. However
it is not uncommon for Unsafe code to work with arrays of temporarily
uninitialized data while repeatedly invoking caller-provided code. Such code
needs to be careful and consider exception safety.</p>
<h2><a class="header" href="#vecpush_all" id="vecpush_all">Vec::push_all</a></h2>
<p><code>Vec::push_all</code> is a temporary hack to get extending a Vec by a slice reliably
efficient without specialization. Here's a simple implementation:</p>
<pre><code class="language-rust ignore">impl&lt;T: Clone&gt; Vec&lt;T&gt; {
    fn push_all(&amp;mut self, to_push: &amp;[T]) {
        self.reserve(to_push.len());
        unsafe {
            // can't overflow because we just reserved this
            self.set_len(self.len() + to_push.len());

            for (i, x) in to_push.iter().enumerate() {
                self.ptr().offset(i as isize).write(x.clone());
            }
        }
    }
}
</code></pre>
<p>We bypass <code>push</code> in order to avoid redundant capacity and <code>len</code> checks on the
Vec that we definitely know has capacity. The logic is totally correct, except
there's a subtle problem with our code: it's not exception-safe! <code>set_len</code>,
<code>offset</code>, and <code>write</code> are all fine; <code>clone</code> is the panic bomb we over-looked.</p>
<p>Clone is completely out of our control, and is totally free to panic. If it
does, our function will exit early with the length of the Vec set too large. If
the Vec is looked at or dropped, uninitialized memory will be read!</p>
<p>The fix in this case is fairly simple. If we want to guarantee that the values
we <em>did</em> clone are dropped, we can set the <code>len</code> every loop iteration. If we
just want to guarantee that uninitialized memory can't be observed, we can set
the <code>len</code> after the loop.</p>
<h2><a class="header" href="#binaryheapsift_up" id="binaryheapsift_up">BinaryHeap::sift_up</a></h2>
<p>Bubbling an element up a heap is a bit more complicated than extending a Vec.
The pseudocode is as follows:</p>
<pre><code class="language-text">bubble_up(heap, index):
    while index != 0 &amp;&amp; heap[index] &lt; heap[parent(index)]:
        heap.swap(index, parent(index))
        index = parent(index)

</code></pre>
<p>A literal transcription of this code to Rust is totally fine, but has an annoying
performance characteristic: the <code>self</code> element is swapped over and over again
uselessly. We would rather have the following:</p>
<pre><code class="language-text">bubble_up(heap, index):
    let elem = heap[index]
    while index != 0 &amp;&amp; element &lt; heap[parent(index)]:
        heap[index] = heap[parent(index)]
        index = parent(index)
    heap[index] = elem
</code></pre>
<p>This code ensures that each element is copied as little as possible (it is in
fact necessary that elem be copied twice in general). However it now exposes
some exception safety trouble! At all times, there exists two copies of one
value. If we panic in this function something will be double-dropped.
Unfortunately, we also don't have full control of the code: that comparison is
user-defined!</p>
<p>Unlike Vec, the fix isn't as easy here. One option is to break the user-defined
code and the unsafe code into two separate phases:</p>
<pre><code class="language-text">bubble_up(heap, index):
    let end_index = index;
    while end_index != 0 &amp;&amp; heap[end_index] &lt; heap[parent(end_index)]:
        end_index = parent(end_index)

    let elem = heap[index]
    while index != end_index:
        heap[index] = heap[parent(index)]
        index = parent(index)
    heap[index] = elem
</code></pre>
<p>If the user-defined code blows up, that's no problem anymore, because we haven't
actually touched the state of the heap yet. Once we do start messing with the
heap, we're working with only data and functions that we trust, so there's no
concern of panics.</p>
<p>Perhaps you're not happy with this design. Surely it's cheating! And we have
to do the complex heap traversal <em>twice</em>! Alright, let's bite the bullet. Let's
intermix untrusted and unsafe code <em>for reals</em>.</p>
<p>If Rust had <code>try</code> and <code>finally</code> like in Java, we could do the following:</p>
<pre><code class="language-text">bubble_up(heap, index):
    let elem = heap[index]
    try:
        while index != 0 &amp;&amp; element &lt; heap[parent(index)]:
            heap[index] = heap[parent(index)]
            index = parent(index)
    finally:
        heap[index] = elem
</code></pre>
<p>The basic idea is simple: if the comparison panics, we just toss the loose
element in the logically uninitialized index and bail out. Anyone who observes
the heap will see a potentially <em>inconsistent</em> heap, but at least it won't
cause any double-drops! If the algorithm terminates normally, then this
operation happens to coincide precisely with the how we finish up regardless.</p>
<p>Sadly, Rust has no such construct, so we're going to need to roll our own! The
way to do this is to store the algorithm's state in a separate struct with a
destructor for the &quot;finally&quot; logic. Whether we panic or not, that destructor
will run and clean up after us.</p>
<pre><code class="language-rust ignore">struct Hole&lt;'a, T: 'a&gt; {
    data: &amp;'a mut [T],
    /// `elt` is always `Some` from new until drop.
    elt: Option&lt;T&gt;,
    pos: usize,
}

impl&lt;'a, T&gt; Hole&lt;'a, T&gt; {
    fn new(data: &amp;'a mut [T], pos: usize) -&gt; Self {
        unsafe {
            let elt = ptr::read(&amp;data[pos]);
            Hole {
                data: data,
                elt: Some(elt),
                pos: pos,
            }
        }
    }

    fn pos(&amp;self) -&gt; usize { self.pos }

    fn removed(&amp;self) -&gt; &amp;T { self.elt.as_ref().unwrap() }

    unsafe fn get(&amp;self, index: usize) -&gt; &amp;T { &amp;self.data[index] }

    unsafe fn move_to(&amp;mut self, index: usize) {
        let index_ptr: *const _ = &amp;self.data[index];
        let hole_ptr = &amp;mut self.data[self.pos];
        ptr::copy_nonoverlapping(index_ptr, hole_ptr, 1);
        self.pos = index;
    }
}

impl&lt;'a, T&gt; Drop for Hole&lt;'a, T&gt; {
    fn drop(&amp;mut self) {
        // fill the hole again
        unsafe {
            let pos = self.pos;
            ptr::write(&amp;mut self.data[pos], self.elt.take().unwrap());
        }
    }
}

impl&lt;T: Ord&gt; BinaryHeap&lt;T&gt; {
    fn sift_up(&amp;mut self, pos: usize) {
        unsafe {
            // Take out the value at `pos` and create a hole.
            let mut hole = Hole::new(&amp;mut self.data, pos);

            while hole.pos() != 0 {
                let parent = parent(hole.pos());
                if hole.removed() &lt;= hole.get(parent) { break }
                hole.move_to(parent);
            }
            // Hole will be unconditionally filled here; panic or not!
        }
    }
}
</code></pre>
<h1><a class="header" href="#poisoning" id="poisoning">Poisoning</a></h1>
<!--
Although all unsafe code *must* ensure it has minimal exception safety, not all
types ensure *maximal* exception safety. Even if the type does, your code may
ascribe additional meaning to it. For instance, an integer is certainly
exception-safe, but has no semantics on its own. It's possible that code that
panics could fail to correctly update the integer, producing an inconsistent
program state.
-->
<p>全てのunsafeな型は最低限の例外安全性を満たしていることが<strong>必要です</strong>が、全ての
unsafeな型が<strong>最大限</strong>の例外安全性を満たしている必要はありません。
仮に型自体が満たしていたとしても、実装が別の意味を暗黙に付与してしまう場合も
あります。例えば整数型は間違いなく例外安全ですが、その(訳注: 最大限の例外安全性
を担保する)セマンティクスを独自に持つわけではないため、整数をアップデートする
際にpanicを起こすと、プログラムが一貫性のない状態に陥る可能性があります。</p>
<!--
This is *usually* fine, because anything that witnesses an exception is about
to get destroyed. For instance, if you send a Vec to another thread and that
thread panics, it doesn't matter if the Vec is in a weird state. It will be
dropped and go away forever. However some types are especially good at smuggling
values across the panic boundary.
-->
<p>これは<strong>通常は</strong>問題になることはありません。というのも例外を発見した処理は直後に
死ぬためです。例えばVecを別のスレッドに送り、そのスレッドがパニックし、結果として
Vecが奇妙な状態に陥ったとしても、dropされて永久に闇の彼方に葬られてしまうためです。
とはいえ型によってはpanicの境界をまたいでくる場合もあります。</p>
<!--
These types may choose to explicitly *poison* themselves if they witness a panic.
Poisoning doesn't entail anything in particular. Generally it just means
preventing normal usage from proceeding. The most notable example of this is the
standard library's Mutex type. A Mutex will poison itself if one of its
MutexGuards (the thing it returns when a lock is obtained) is dropped during a
panic. Any future attempts to lock the Mutex will return an `Err` or panic.
-->
<p>こういった型は、panicに直面した際に、意図的に自分自身を<strong>poison</strong>する可能性があり
ます。poisoningは自体は特に何か別の事態を引き起こすわけではありません。一般的に
通常の手続きの継続を止めるべきであることを表しています。よく知られた例として
標準ライブラリのMutex型があります。この型は対応するMutexGuards(lockを取得した際に
返るもの)が、panicによってdropされた際に自分自身をpoisonします。以後Mutexをlock
しようとすると<code>Err</code>を返すかpanicします。</p>
<!--
Mutex poisons not for true safety in the sense that Rust normally cares about. It
poisons as a safety-guard against blindly using the data that comes out of a Mutex
that has witnessed a panic while locked. The data in such a Mutex was likely in the
middle of being modified, and as such may be in an inconsistent or incomplete state.
It is important to note that one cannot violate memory safety with such a type
if it is correctly written. After all, it must be minimally exception-safe!
-->
<p>Mutexのpoisonは、通常の文脈で語られるRustの安全性とは異なる用途のためのものです。
Mutexを扱うスレッドがlock中にパニックを引き起こした場合、Mutexの中のデータは変更中
であった可能性が高く、一貫性を欠いていたり変更が未完了の状態であったりするため、
そのようなデータを盲目的に扱う危険性に対する安全装置として動作します。
注意しておきたいのはそのような型が適切に実装されていた場合、メモリ安全性<strong>は</strong>確実
に満たしているという点です。つまるところ、最低限の例外安全性は満たしていなくては
ならないということです。</p>
<!--
However if the Mutex contained, say, a BinaryHeap that does not actually have the
heap property, it's unlikely that any code that uses it will do
what the author intended. As such, the program should not proceed normally.
Still, if you're double-plus-sure that you can do *something* with the value,
the Mutex exposes a method to get the lock anyway. It *is* safe, after all.
Just maybe nonsense.
-->
<p>しかしながら、Mutexが例えばBinaryHeapを持っていたとして、その値が実際にはヒープ
として要件を満たさなかったような場合、そのデータ構造を利用するプログラムが作成者の
意図通りの挙動をするということは考えにくいです。通常とは異なる振る舞いをする
でしょう。とはいえ、十分に注意すればそのような場合でもその値が<strong>何かに</strong>使える
可能性はあります。safe<strong>では</strong>あるのです。ただ、ナンセンスかもしれませんが。</p>
<!--
# Concurrency and Parallelism
-->
<h1><a class="header" href="#並行性と並列性" id="並行性と並列性">並行性と並列性</a></h1>
<!--
Rust as a language doesn't *really* have an opinion on how to do concurrency or
parallelism. The standard library exposes OS threads and blocking sys-calls
because everyone has those, and they're uniform enough that you can provide
an abstraction over them in a relatively uncontroversial way. Message passing,
green threads, and async APIs are all diverse enough that any abstraction over
them tends to involve trade-offs that we weren't willing to commit to for 1.0.
-->
<p>言語としての Rust には、<em>本当に</em>、どのように並行性や並列性を実現するかについての
信条がありません。標準ライブラリは、 OS のスレッドやシステムコールのブロックを
公開しています。なぜなら皆これらを持っていて、そして十分統一されているために、
比較的反論の起きないような、これらに対する抽象化を提供できるからです。メッセージパッシング、
グリーンスレッド、そして async の API はすべて、本当に異なっているため、
これらに対するいかなる抽象化においても、バージョン 1.0 に対するコミットを
行ないたくないようなトレードオフを巻き込む傾向にあります。</p>
<!--
However the way Rust models concurrency makes it relatively easy to design your own
concurrency paradigm as a library and have everyone else's code Just Work
with yours. Just require the right lifetimes and Send and Sync where appropriate
and you're off to the races. Or rather, off to the... not... having... races.
-->
<p>しかしながら、 Rust の並行性のモデルは比較的簡単に、ライブラリとして、自分自身の並行パラダイムを
設計することができ、そして、自分のコードと同じように、他の人のコードもちゃんと動かすことも出来ます。
必要なのは正しいライフタイムと、必要に応じて Send と Sync で、これですぐに書くことが出来ます。
あるいは... 競合を... 起こさずに... 済みます。</p>
<h1><a class="header" href="#data-races-and-race-conditions" id="data-races-and-race-conditions">Data Races and Race Conditions</a></h1>
<p>Safe Rust guarantees an absence of data races, which are defined as:</p>
<ul>
<li>two or more threads concurrently accessing a location of memory</li>
<li>one of them is a write</li>
<li>one of them is unsynchronized</li>
</ul>
<p>A data race has Undefined Behavior, and is therefore impossible to perform
in Safe Rust. Data races are <em>mostly</em> prevented through rust's ownership system:
it's impossible to alias a mutable reference, so it's impossible to perform a
data race. Interior mutability makes this more complicated, which is largely why
we have the Send and Sync traits (see below).</p>
<p><strong>However Rust does not prevent general race conditions.</strong></p>
<p>This is pretty fundamentally impossible, and probably honestly undesirable. Your
hardware is racy, your OS is racy, the other programs on your computer are racy,
and the world this all runs in is racy. Any system that could genuinely claim to
prevent <em>all</em> race conditions would be pretty awful to use, if not just
incorrect.</p>
<p>So it's perfectly &quot;fine&quot; for a Safe Rust program to get deadlocked or do
something nonsensical with incorrect synchronization. Obviously such a program
isn't very good, but Rust can only hold your hand so far. Still, a race
condition can't violate memory safety in a Rust program on its own. Only in
conjunction with some other unsafe code can a race condition actually violate
memory safety. For instance:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::Arc;

let data = vec![1, 2, 3, 4];
// Arc so that the memory the AtomicUsize is stored in still exists for
// the other thread to increment, even if we completely finish executing
// before it. Rust won't compile the program without it, because of the
// lifetime requirements of thread::spawn!
let idx = Arc::new(AtomicUsize::new(0));
let other_idx = idx.clone();

// `move` captures other_idx by-value, moving it into this thread
thread::spawn(move || {
    // It's ok to mutate idx because this value
    // is an atomic, so it can't cause a Data Race.
    other_idx.fetch_add(10, Ordering::SeqCst);
});

// Index with the value loaded from the atomic. This is safe because we
// read the atomic memory only once, and then pass a copy of that value
// to the Vec's indexing implementation. This indexing will be correctly
// bounds checked, and there's no chance of the value getting changed
// in the middle. However our program may panic if the thread we spawned
// managed to increment before this ran. A race condition because correct
// program execution (panicking is rarely correct) depends on order of
// thread execution.
println!(&quot;{}&quot;, data[idx.load(Ordering::SeqCst)]);
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::Arc;

let data = vec![1, 2, 3, 4];

let idx = Arc::new(AtomicUsize::new(0));
let other_idx = idx.clone();

// `move` captures other_idx by-value, moving it into this thread
thread::spawn(move || {
    // It's ok to mutate idx because this value
    // is an atomic, so it can't cause a Data Race.
    other_idx.fetch_add(10, Ordering::SeqCst);
});

if idx.load(Ordering::SeqCst) &lt; data.len() {
    unsafe {
        // Incorrectly loading the idx after we did the bounds check.
        // It could have changed. This is a race condition, *and dangerous*
        // because we decided to do `get_unchecked`, which is `unsafe`.
        println!(&quot;{}&quot;, data.get_unchecked(idx.load(Ordering::SeqCst)));
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#send-and-sync" id="send-and-sync">Send and Sync</a></h1>
<p>Not everything obeys inherited mutability, though. Some types allow you to
multiply alias a location in memory while mutating it. Unless these types use
synchronization to manage this access, they are absolutely not thread safe. Rust
captures this through the <code>Send</code> and <code>Sync</code> traits.</p>
<ul>
<li>A type is Send if it is safe to send it to another thread.</li>
<li>A type is Sync if it is safe to share between threads (<code>&amp;T</code> is Send).</li>
</ul>
<p>Send and Sync are fundamental to Rust's concurrency story. As such, a
substantial amount of special tooling exists to make them work right. First and
foremost, they're <a href="safe-unsafe-meaning.html">unsafe traits</a>. This means that they are unsafe to
implement, and other unsafe code can assume that they are correctly
implemented. Since they're <em>marker traits</em> (they have no associated items like
methods), correctly implemented simply means that they have the intrinsic
properties an implementor should have. Incorrectly implementing Send or Sync can
cause Undefined Behavior.</p>
<p>Send and Sync are also automatically derived traits. This means that, unlike
every other trait, if a type is composed entirely of Send or Sync types, then it
is Send or Sync. Almost all primitives are Send and Sync, and as a consequence
pretty much all types you'll ever interact with are Send and Sync.</p>
<p>Major exceptions include:</p>
<ul>
<li>raw pointers are neither Send nor Sync (because they have no safety guards).</li>
<li><code>UnsafeCell</code> isn't Sync (and therefore <code>Cell</code> and <code>RefCell</code> aren't).</li>
<li><code>Rc</code> isn't Send or Sync (because the refcount is shared and unsynchronized).</li>
</ul>
<p><code>Rc</code> and <code>UnsafeCell</code> are very fundamentally not thread-safe: they enable
unsynchronized shared mutable state. However raw pointers are, strictly
speaking, marked as thread-unsafe as more of a <em>lint</em>. Doing anything useful
with a raw pointer requires dereferencing it, which is already unsafe. In that
sense, one could argue that it would be &quot;fine&quot; for them to be marked as thread
safe.</p>
<p>However it's important that they aren't thread safe to prevent types that
contain them from being automatically marked as thread safe. These types have
non-trivial untracked ownership, and it's unlikely that their author was
necessarily thinking hard about thread safety. In the case of Rc, we have a nice
example of a type that contains a <code>*mut</code> that is definitely not thread safe.</p>
<p>Types that aren't automatically derived can simply implement them if desired:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyBox(*mut u8);

unsafe impl Send for MyBox {}
unsafe impl Sync for MyBox {}
<span class="boring">}
</span></code></pre></pre>
<p>In the <em>incredibly rare</em> case that a type is inappropriately automatically
derived to be Send or Sync, then one can also unimplement Send and Sync:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![feature(optin_builtin_traits)]

<span class="boring">fn main() {
</span>// I have some magic semantics for some synchronization primitive!
struct SpecialThreadToken(u8);

impl !Send for SpecialThreadToken {}
impl !Sync for SpecialThreadToken {}
<span class="boring">}
</span></code></pre></pre>
<p>Note that <em>in and of itself</em> it is impossible to incorrectly derive Send and
Sync. Only types that are ascribed special meaning by other unsafe code can
possible cause trouble by being incorrectly Send or Sync.</p>
<p>Most uses of raw pointers should be encapsulated behind a sufficient abstraction
that Send and Sync can be derived. For instance all of Rust's standard
collections are Send and Sync (when they contain Send and Sync types) in spite
of their pervasive use of raw pointers to manage allocations and complex ownership.
Similarly, most iterators into these collections are Send and Sync because they
largely behave like an <code>&amp;</code> or <code>&amp;mut</code> into the collection.</p>
<p>TODO: better explain what can or can't be Send or Sync. Sufficient to appeal
only to data races?</p>
<h1><a class="header" href="#atomics" id="atomics">Atomics</a></h1>
<p>Rust pretty blatantly just inherits C11's memory model for atomics. This is not
due to this model being particularly excellent or easy to understand. Indeed,
this model is quite complex and known to have <a href="http://plv.mpi-sws.org/c11comp/popl15.pdf">several flaws</a>.
Rather, it is a pragmatic concession to the fact that <em>everyone</em> is pretty bad
at modeling atomics. At very least, we can benefit from existing tooling and
research around C.</p>
<p>Trying to fully explain the model in this book is fairly hopeless. It's defined
in terms of madness-inducing causality graphs that require a full book to
properly understand in a practical way. If you want all the nitty-gritty
details, you should check out <a href="http://www.open-std.org/jtc1/sc22/wg14/www/standards.html#9899">C's specification (Section 7.17)</a>.
Still, we'll try to cover the basics and some of the problems Rust developers
face.</p>
<p>The C11 memory model is fundamentally about trying to bridge the gap between the
semantics we want, the optimizations compilers want, and the inconsistent chaos
our hardware wants. <em>We</em> would like to just write programs and have them do
exactly what we said but, you know, fast. Wouldn't that be great?</p>
<h1><a class="header" href="#compiler-reordering" id="compiler-reordering">Compiler Reordering</a></h1>
<p>Compilers fundamentally want to be able to do all sorts of complicated
transformations to reduce data dependencies and eliminate dead code. In
particular, they may radically change the actual order of events, or make events
never occur! If we write something like</p>
<pre><code class="language-rust ignore">x = 1;
y = 3;
x = 2;
</code></pre>
<p>The compiler may conclude that it would be best if your program did</p>
<pre><code class="language-rust ignore">x = 2;
y = 3;
</code></pre>
<p>This has inverted the order of events and completely eliminated one event.
From a single-threaded perspective this is completely unobservable: after all
the statements have executed we are in exactly the same state. But if our
program is multi-threaded, we may have been relying on <code>x</code> to actually be
assigned to 1 before <code>y</code> was assigned. We would like the compiler to be
able to make these kinds of optimizations, because they can seriously improve
performance. On the other hand, we'd also like to be able to depend on our
program <em>doing the thing we said</em>.</p>
<h1><a class="header" href="#hardware-reordering" id="hardware-reordering">Hardware Reordering</a></h1>
<p>On the other hand, even if the compiler totally understood what we wanted and
respected our wishes, our hardware might instead get us in trouble. Trouble
comes from CPUs in the form of memory hierarchies. There is indeed a global
shared memory space somewhere in your hardware, but from the perspective of each
CPU core it is <em>so very far away</em> and <em>so very slow</em>. Each CPU would rather work
with its local cache of the data and only go through all the anguish of
talking to shared memory only when it doesn't actually have that memory in
cache.</p>
<p>After all, that's the whole point of the cache, right? If every read from the
cache had to run back to shared memory to double check that it hadn't changed,
what would the point be? The end result is that the hardware doesn't guarantee
that events that occur in the same order on <em>one</em> thread, occur in the same
order on <em>another</em> thread. To guarantee this, we must issue special instructions
to the CPU telling it to be a bit less smart.</p>
<p>For instance, say we convince the compiler to emit this logic:</p>
<pre><code class="language-text">initial state: x = 0, y = 1

THREAD 1        THREAD2
y = 3;          if x == 1 {
x = 1;              y *= 2;
                }
</code></pre>
<p>Ideally this program has 2 possible final states:</p>
<ul>
<li><code>y = 3</code>: (thread 2 did the check before thread 1 completed)</li>
<li><code>y = 6</code>: (thread 2 did the check after thread 1 completed)</li>
</ul>
<p>However there's a third potential state that the hardware enables:</p>
<ul>
<li><code>y = 2</code>: (thread 2 saw <code>x = 1</code>, but not <code>y = 3</code>, and then overwrote <code>y = 3</code>)</li>
</ul>
<p>It's worth noting that different kinds of CPU provide different guarantees. It
is common to separate hardware into two categories: strongly-ordered and weakly-
ordered. Most notably x86/64 provides strong ordering guarantees, while ARM
provides weak ordering guarantees. This has two consequences for concurrent
programming:</p>
<ul>
<li>
<p>Asking for stronger guarantees on strongly-ordered hardware may be cheap or
even free because they already provide strong guarantees unconditionally.
Weaker guarantees may only yield performance wins on weakly-ordered hardware.</p>
</li>
<li>
<p>Asking for guarantees that are too weak on strongly-ordered hardware is
more likely to <em>happen</em> to work, even though your program is strictly
incorrect. If possible, concurrent algorithms should be tested on
weakly-ordered hardware.</p>
</li>
</ul>
<h1><a class="header" href="#data-accesses" id="data-accesses">Data Accesses</a></h1>
<p>The C11 memory model attempts to bridge the gap by allowing us to talk about the
<em>causality</em> of our program. Generally, this is by establishing a <em>happens
before</em> relationship between parts of the program and the threads that are
running them. This gives the hardware and compiler room to optimize the program
more aggressively where a strict happens-before relationship isn't established,
but forces them to be more careful where one is established. The way we
communicate these relationships are through <em>data accesses</em> and <em>atomic
accesses</em>.</p>
<p>Data accesses are the bread-and-butter of the programming world. They are
fundamentally unsynchronized and compilers are free to aggressively optimize
them. In particular, data accesses are free to be reordered by the compiler on
the assumption that the program is single-threaded. The hardware is also free to
propagate the changes made in data accesses to other threads as lazily and
inconsistently as it wants. Most critically, data accesses are how data races
happen. Data accesses are very friendly to the hardware and compiler, but as
we've seen they offer <em>awful</em> semantics to try to write synchronized code with.
Actually, that's too weak.</p>
<p><strong>It is literally impossible to write correct synchronized code using only data
accesses.</strong></p>
<p>Atomic accesses are how we tell the hardware and compiler that our program is
multi-threaded. Each atomic access can be marked with an <em>ordering</em> that
specifies what kind of relationship it establishes with other accesses. In
practice, this boils down to telling the compiler and hardware certain things
they <em>can't</em> do. For the compiler, this largely revolves around re-ordering of
instructions. For the hardware, this largely revolves around how writes are
propagated to other threads. The set of orderings Rust exposes are:</p>
<ul>
<li>Sequentially Consistent (SeqCst)</li>
<li>Release</li>
<li>Acquire</li>
<li>Relaxed</li>
</ul>
<p>(Note: We explicitly do not expose the C11 <em>consume</em> ordering)</p>
<p>TODO: negative reasoning vs positive reasoning? TODO: &quot;can't forget to
synchronize&quot;</p>
<h1><a class="header" href="#sequentially-consistent" id="sequentially-consistent">Sequentially Consistent</a></h1>
<p>Sequentially Consistent is the most powerful of all, implying the restrictions
of all other orderings. Intuitively, a sequentially consistent operation
cannot be reordered: all accesses on one thread that happen before and after a
SeqCst access stay before and after it. A data-race-free program that uses
only sequentially consistent atomics and data accesses has the very nice
property that there is a single global execution of the program's instructions
that all threads agree on. This execution is also particularly nice to reason
about: it's just an interleaving of each thread's individual executions. This
does not hold if you start using the weaker atomic orderings.</p>
<p>The relative developer-friendliness of sequential consistency doesn't come for
free. Even on strongly-ordered platforms sequential consistency involves
emitting memory fences.</p>
<p>In practice, sequential consistency is rarely necessary for program correctness.
However sequential consistency is definitely the right choice if you're not
confident about the other memory orders. Having your program run a bit slower
than it needs to is certainly better than it running incorrectly! It's also
mechanically trivial to downgrade atomic operations to have a weaker
consistency later on. Just change <code>SeqCst</code> to <code>Relaxed</code> and you're done! Of
course, proving that this transformation is <em>correct</em> is a whole other matter.</p>
<h1><a class="header" href="#acquire-release" id="acquire-release">Acquire-Release</a></h1>
<p>Acquire and Release are largely intended to be paired. Their names hint at their
use case: they're perfectly suited for acquiring and releasing locks, and
ensuring that critical sections don't overlap.</p>
<p>Intuitively, an acquire access ensures that every access after it stays after
it. However operations that occur before an acquire are free to be reordered to
occur after it. Similarly, a release access ensures that every access before it
stays before it. However operations that occur after a release are free to be
reordered to occur before it.</p>
<p>When thread A releases a location in memory and then thread B subsequently
acquires <em>the same</em> location in memory, causality is established. Every write
that happened before A's release will be observed by B after its release.
However no causality is established with any other threads. Similarly, no
causality is established if A and B access <em>different</em> locations in memory.</p>
<p>Basic use of release-acquire is therefore simple: you acquire a location of
memory to begin the critical section, and then release that location to end it.
For instance, a simple spinlock might look like:</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Arc;
use std::sync::atomic::{AtomicBool, Ordering};
use std::thread;

fn main() {
    let lock = Arc::new(AtomicBool::new(false)); // value answers &quot;am I locked?&quot;

    // ... distribute lock to threads somehow ...

    // Try to acquire the lock by setting it to true
    while lock.compare_and_swap(false, true, Ordering::Acquire) { }
    // broke out of the loop, so we successfully acquired the lock!

    // ... scary data accesses ...

    // ok we're done, release the lock
    lock.store(false, Ordering::Release);
}
</code></pre></pre>
<p>On strongly-ordered platforms most accesses have release or acquire semantics,
making release and acquire often totally free. This is not the case on
weakly-ordered platforms.</p>
<h1><a class="header" href="#relaxed" id="relaxed">Relaxed</a></h1>
<p>Relaxed accesses are the absolute weakest. They can be freely re-ordered and
provide no happens-before relationship. Still, relaxed operations are still
atomic. That is, they don't count as data accesses and any read-modify-write
operations done to them occur atomically. Relaxed operations are appropriate for
things that you definitely want to happen, but don't particularly otherwise care
about. For instance, incrementing a counter can be safely done by multiple
threads using a relaxed <code>fetch_add</code> if you're not using the counter to
synchronize any other accesses.</p>
<p>There's rarely a benefit in making an operation relaxed on strongly-ordered
platforms, since they usually provide release-acquire semantics anyway. However
relaxed operations can be cheaper on weakly-ordered platforms.</p>
<h1><a class="header" href="#example-implementing-vec" id="example-implementing-vec">Example: Implementing Vec</a></h1>
<p>To bring everything together, we're going to write <code>std::Vec</code> from scratch.
Because all the best tools for writing unsafe code are unstable, this
project will only work on nightly (as of Rust 1.9.0). With the exception of the
allocator API, much of the unstable code we'll use is expected to be stabilized
in a similar form as it is today.</p>
<p>However we will generally try to avoid unstable code where possible. In
particular we won't use any intrinsics that could make a code a little
bit nicer or efficient because intrinsics are permanently unstable. Although
many intrinsics <em>do</em> become stabilized elsewhere (<code>std::ptr</code> and <code>str::mem</code>
consist of many intrinsics).</p>
<p>Ultimately this means our implementation may not take advantage of all
possible optimizations, though it will be by no means <em>naive</em>. We will
definitely get into the weeds over nitty-gritty details, even
when the problem doesn't <em>really</em> merit it.</p>
<p>You wanted advanced. We're gonna go advanced.</p>
<h1><a class="header" href="#layout" id="layout">Layout</a></h1>
<p>First off, we need to come up with the struct layout. A Vec has three parts:
a pointer to the allocation, the size of the allocation, and the number of
elements that have been initialized.</p>
<p>Naively, this means we just want this design:</p>
<pre><pre class="playground"><code class="language-rust">pub struct Vec&lt;T&gt; {
    ptr: *mut T,
    cap: usize,
    len: usize,
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>And indeed this would compile. Unfortunately, it would be incorrect. First, the
compiler will give us too strict variance. So a <code>&amp;Vec&lt;&amp;'static str&gt;</code>
couldn't be used where an <code>&amp;Vec&lt;&amp;'a str&gt;</code> was expected. More importantly, it
will give incorrect ownership information to the drop checker, as it will
conservatively assume we don't own any values of type <code>T</code>. See <a href="ownership.html">the chapter
on ownership and lifetimes</a> for all the details on variance and
drop check.</p>
<p>As we saw in the ownership chapter, we should use <code>Unique&lt;T&gt;</code> in place of
<code>*mut T</code> when we have a raw pointer to an allocation we own. Unique is unstable,
so we'd like to not use it if possible, though.</p>
<p>As a recap, Unique is a wrapper around a raw pointer that declares that:</p>
<ul>
<li>We are variant over <code>T</code></li>
<li>We may own a value of type <code>T</code> (for drop check)</li>
<li>We are Send/Sync if <code>T</code> is Send/Sync</li>
<li>We deref to <code>*mut T</code> (so it largely acts like a <code>*mut</code> in our code)</li>
<li>Our pointer is never null (so <code>Option&lt;Vec&lt;T&gt;&gt;</code> is null-pointer-optimized)</li>
</ul>
<p>We can implement all of the above requirements except for the last
one in stable Rust:</p>
<pre><pre class="playground"><code class="language-rust">use std::marker::PhantomData;
use std::ops::Deref;
use std::mem;

struct Unique&lt;T&gt; {
    ptr: *const T,              // *const for variance
    _marker: PhantomData&lt;T&gt;,    // For the drop checker
}

// Deriving Send and Sync is safe because we are the Unique owners
// of this data. It's like Unique&lt;T&gt; is &quot;just&quot; T.
unsafe impl&lt;T: Send&gt; Send for Unique&lt;T&gt; {}
unsafe impl&lt;T: Sync&gt; Sync for Unique&lt;T&gt; {}

impl&lt;T&gt; Unique&lt;T&gt; {
    pub fn new(ptr: *mut T) -&gt; Self {
        Unique { ptr: ptr, _marker: PhantomData }
    }
}

impl&lt;T&gt; Deref for Unique&lt;T&gt; {
    type Target = *mut T;
    fn deref(&amp;self) -&gt; &amp;*mut T {
        // There's no way to cast the *const to a *mut
        // while also taking a reference. So we just
        // transmute it since it's all &quot;just pointers&quot;.
        unsafe { mem::transmute(&amp;self.ptr) }
    }
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>Unfortunately the mechanism for stating that your value is non-zero is
unstable and unlikely to be stabilized soon. As such we're just going to
take the hit and use std's Unique:</p>
<pre><pre class="playground"><code class="language-rust">#![feature(unique)]

use std::ptr::{Unique, self};

pub struct Vec&lt;T&gt; {
    ptr: Unique&lt;T&gt;,
    cap: usize,
    len: usize,
}

<span class="boring">fn main() {}
</span></code></pre></pre>
<p>If you don't care about the null-pointer optimization, then you can use the
stable code. However we will be designing the rest of the code around enabling
the optimization. In particular, <code>Unique::new</code> is unsafe to call, because
putting <code>null</code> inside of it is Undefined Behavior. Our stable Unique doesn't
need <code>new</code> to be unsafe because it doesn't make any interesting guarantees about
its contents.</p>
<h1><a class="header" href="#allocating-memory" id="allocating-memory">Allocating Memory</a></h1>
<p>Using Unique throws a wrench in an important feature of Vec (and indeed all of
the std collections): an empty Vec doesn't actually allocate at all. So if we
can't allocate, but also can't put a null pointer in <code>ptr</code>, what do we do in
<code>Vec::new</code>? Well, we just put some other garbage in there!</p>
<p>This is perfectly fine because we already have <code>cap == 0</code> as our sentinel for no
allocation. We don't even need to handle it specially in almost any code because
we usually need to check if <code>cap &gt; len</code> or <code>len &gt; 0</code> anyway. The traditional
Rust value to put here is <code>0x01</code>. The standard library actually exposes this
as <code>alloc::heap::EMPTY</code>. There are quite a few places where we'll
want to use <code>heap::EMPTY</code> because there's no real allocation to talk about but
<code>null</code> would make the compiler do bad things.</p>
<p>All of the <code>heap</code> API is totally unstable under the <code>heap_api</code> feature, though.
We could trivially define <code>heap::EMPTY</code> ourselves, but we'll want the rest of
the <code>heap</code> API anyway, so let's just get that dependency over with.</p>
<p>So:</p>
<pre><code class="language-rust ignore">#![feature(alloc, heap_api)]

use std::mem;

use alloc::heap::EMPTY;

impl&lt;T&gt; Vec&lt;T&gt; {
    fn new() -&gt; Self {
        assert!(mem::size_of::&lt;T&gt;() != 0, &quot;We're not ready to handle ZSTs&quot;);
        unsafe {
            // need to cast EMPTY to the actual ptr type we want, let
            // inference handle it.
            Vec { ptr: Unique::new(heap::EMPTY as *mut _), len: 0, cap: 0 }
        }
    }
}
</code></pre>
<p>I slipped in that assert there because zero-sized types will require some
special handling throughout our code, and I want to defer the issue for now.
Without this assert, some of our early drafts will do some Very Bad Things.</p>
<p>Next we need to figure out what to actually do when we <em>do</em> want space. For
that, we'll need to use the rest of the heap APIs. These basically allow us to
talk directly to Rust's allocator (jemalloc by default).</p>
<p>We'll also need a way to handle out-of-memory (OOM) conditions. The standard
library calls the <code>abort</code> intrinsic, which just calls an illegal instruction to
crash the whole program. The reason we abort and don't panic is because
unwinding can cause allocations to happen, and that seems like a bad thing to do
when your allocator just came back with &quot;hey I don't have any more memory&quot;.</p>
<p>Of course, this is a bit silly since most platforms don't actually run out of
memory in a conventional way. Your operating system will probably kill the
application by another means if you legitimately start using up all the memory.
The most likely way we'll trigger OOM is by just asking for ludicrous quantities
of memory at once (e.g. half the theoretical address space). As such it's
<em>probably</em> fine to panic and nothing bad will happen. Still, we're trying to be
like the standard library as much as possible, so we'll just kill the whole
program.</p>
<p>We said we don't want to use intrinsics, so doing exactly what <code>std</code> does is
out. Instead, we'll call <code>std::process::exit</code> with some random number.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn oom() {
    ::std::process::exit(-9999);
}
<span class="boring">}
</span></code></pre></pre>
<p>Okay, now we can write growing. Roughly, we want to have this logic:</p>
<pre><code class="language-text">if cap == 0:
    allocate()
    cap = 1
else:
    reallocate()
    cap *= 2
</code></pre>
<p>But Rust's only supported allocator API is so low level that we'll need to do a
fair bit of extra work. We also need to guard against some special
conditions that can occur with really large allocations or empty allocations.</p>
<p>In particular, <code>ptr::offset</code> will cause us a lot of trouble, because it has
the semantics of LLVM's GEP inbounds instruction. If you're fortunate enough to
not have dealt with this instruction, here's the basic story with GEP: alias
analysis, alias analysis, alias analysis. It's super important to an optimizing
compiler to be able to reason about data dependencies and aliasing.</p>
<p>As a simple example, consider the following fragment of code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let x = &amp;mut 0;
</span><span class="boring">let y = &amp;mut 0;
</span>*x *= 7;
*y *= 3;
<span class="boring">}
</span></code></pre></pre>
<p>If the compiler can prove that <code>x</code> and <code>y</code> point to different locations in
memory, the two operations can in theory be executed in parallel (by e.g.
loading them into different registers and working on them independently).
However the compiler can't do this in general because if x and y point to
the same location in memory, the operations need to be done to the same value,
and they can't just be merged afterwards.</p>
<p>When you use GEP inbounds, you are specifically telling LLVM that the offsets
you're about to do are within the bounds of a single &quot;allocated&quot; entity. The
ultimate payoff being that LLVM can assume that if two pointers are known to
point to two disjoint objects, all the offsets of those pointers are <em>also</em>
known to not alias (because you won't just end up in some random place in
memory). LLVM is heavily optimized to work with GEP offsets, and inbounds
offsets are the best of all, so it's important that we use them as much as
possible.</p>
<p>So that's what GEP's about, how can it cause us trouble?</p>
<p>The first problem is that we index into arrays with unsigned integers, but
GEP (and as a consequence <code>ptr::offset</code>) takes a signed integer. This means
that half of the seemingly valid indices into an array will overflow GEP and
actually go in the wrong direction! As such we must limit all allocations to
<code>isize::MAX</code> elements. This actually means we only need to worry about
byte-sized objects, because e.g. <code>&gt; isize::MAX</code> <code>u16</code>s will truly exhaust all of
the system's memory. However in order to avoid subtle corner cases where someone
reinterprets some array of <code>&lt; isize::MAX</code> objects as bytes, std limits all
allocations to <code>isize::MAX</code> bytes.</p>
<p>On all 64-bit targets that Rust currently supports we're artificially limited
to significantly less than all 64 bits of the address space (modern x64
platforms only expose 48-bit addressing), so we can rely on just running out of
memory first. However on 32-bit targets, particularly those with extensions to
use more of the address space (PAE x86 or x32), it's theoretically possible to
successfully allocate more than <code>isize::MAX</code> bytes of memory.</p>
<p>However since this is a tutorial, we're not going to be particularly optimal
here, and just unconditionally check, rather than use clever platform-specific
<code>cfg</code>s.</p>
<p>The other corner-case we need to worry about is empty allocations. There will
be two kinds of empty allocations we need to worry about: <code>cap = 0</code> for all T,
and <code>cap &gt; 0</code> for zero-sized types.</p>
<p>These cases are tricky because they come
down to what LLVM means by &quot;allocated&quot;. LLVM's notion of an
allocation is significantly more abstract than how we usually use it. Because
LLVM needs to work with different languages' semantics and custom allocators,
it can't really intimately understand allocation. Instead, the main idea behind
allocation is &quot;doesn't overlap with other stuff&quot;. That is, heap allocations,
stack allocations, and globals don't randomly overlap. Yep, it's about alias
analysis. As such, Rust can technically play a bit fast and loose with the notion of
an allocation as long as it's <em>consistent</em>.</p>
<p>Getting back to the empty allocation case, there are a couple of places where
we want to offset by 0 as a consequence of generic code. The question is then:
is it consistent to do so? For zero-sized types, we have concluded that it is
indeed consistent to do a GEP inbounds offset by an arbitrary number of
elements. This is a runtime no-op because every element takes up no space,
and it's fine to pretend that there's infinite zero-sized types allocated
at <code>0x01</code>. No allocator will ever allocate that address, because they won't
allocate <code>0x00</code> and they generally allocate to some minimal alignment higher
than a byte. Also generally the whole first page of memory is
protected from being allocated anyway (a whole 4k, on many platforms).</p>
<p>However what about for positive-sized types? That one's a bit trickier. In
principle, you can argue that offsetting by 0 gives LLVM no information: either
there's an element before the address or after it, but it can't know which.
However we've chosen to conservatively assume that it may do bad things. As
such we will guard against this case explicitly.</p>
<p><em>Phew</em></p>
<p>Ok with all the nonsense out of the way, let's actually allocate some memory:</p>
<pre><code class="language-rust ignore">fn grow(&amp;mut self) {
    // this is all pretty delicate, so let's say it's all unsafe
    unsafe {
        // current API requires us to specify size and alignment manually.
        let align = mem::align_of::&lt;T&gt;();
        let elem_size = mem::size_of::&lt;T&gt;();

        let (new_cap, ptr) = if self.cap == 0 {
            let ptr = heap::allocate(elem_size, align);
            (1, ptr)
        } else {
            // as an invariant, we can assume that `self.cap &lt; isize::MAX`,
            // so this doesn't need to be checked.
            let new_cap = self.cap * 2;
            // Similarly this can't overflow due to previously allocating this
            let old_num_bytes = self.cap * elem_size;

            // check that the new allocation doesn't exceed `isize::MAX` at all
            // regardless of the actual size of the capacity. This combines the
            // `new_cap &lt;= isize::MAX` and `new_num_bytes &lt;= usize::MAX` checks
            // we need to make. We lose the ability to allocate e.g. 2/3rds of
            // the address space with a single Vec of i16's on 32-bit though.
            // Alas, poor Yorick -- I knew him, Horatio.
            assert!(old_num_bytes &lt;= (::std::isize::MAX as usize) / 2,
                    &quot;capacity overflow&quot;);

            let new_num_bytes = old_num_bytes * 2;
            let ptr = heap::reallocate(*self.ptr as *mut _,
                                        old_num_bytes,
                                        new_num_bytes,
                                        align);
            (new_cap, ptr)
        };

        // If allocate or reallocate fail, we'll get `null` back
        if ptr.is_null() { oom(); }

        self.ptr = Unique::new(ptr as *mut _);
        self.cap = new_cap;
    }
}
</code></pre>
<p>Nothing particularly tricky here. Just computing sizes and alignments and doing
some careful multiplication checks.</p>
<h1><a class="header" href="#push-and-pop" id="push-and-pop">Push and Pop</a></h1>
<p>Alright. We can initialize. We can allocate. Let's actually implement some
functionality! Let's start with <code>push</code>. All it needs to do is check if we're
full to grow, unconditionally write to the next index, and then increment our
length.</p>
<p>To do the write we have to be careful not to evaluate the memory we want to write
to. At worst, it's truly uninitialized memory from the allocator. At best it's the
bits of some old value we popped off. Either way, we can't just index to the memory
and dereference it, because that will evaluate the memory as a valid instance of
T. Worse, <code>foo[idx] = x</code> will try to call <code>drop</code> on the old value of <code>foo[idx]</code>!</p>
<p>The correct way to do this is with <code>ptr::write</code>, which just blindly overwrites the
target address with the bits of the value we provide. No evaluation involved.</p>
<p>For <code>push</code>, if the old len (before push was called) is 0, then we want to write
to the 0th index. So we should offset by the old len.</p>
<pre><code class="language-rust ignore">pub fn push(&amp;mut self, elem: T) {
    if self.len == self.cap { self.grow(); }

    unsafe {
        ptr::write(self.ptr.offset(self.len as isize), elem);
    }

    // Can't fail, we'll OOM first.
    self.len += 1;
}
</code></pre>
<p>Easy! How about <code>pop</code>? Although this time the index we want to access is
initialized, Rust won't just let us dereference the location of memory to move
the value out, because that would leave the memory uninitialized! For this we
need <code>ptr::read</code>, which just copies out the bits from the target address and
interprets it as a value of type T. This will leave the memory at this address
logically uninitialized, even though there is in fact a perfectly good instance
of T there.</p>
<p>For <code>pop</code>, if the old len is 1, we want to read out of the 0th index. So we
should offset by the new len.</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
    if self.len == 0 {
        None
    } else {
        self.len -= 1;
        unsafe {
            Some(ptr::read(self.ptr.offset(self.len as isize)))
        }
    }
}
</code></pre>
<h1><a class="header" href="#deallocating" id="deallocating">Deallocating</a></h1>
<p>Next we should implement Drop so that we don't massively leak tons of resources.
The easiest way is to just call <code>pop</code> until it yields None, and then deallocate
our buffer. Note that calling <code>pop</code> is unneeded if <code>T: !Drop</code>. In theory we can
ask Rust if <code>T</code> <code>needs_drop</code> and omit the calls to <code>pop</code>. However in practice
LLVM is <em>really</em> good at removing simple side-effect free code like this, so I
wouldn't bother unless you notice it's not being stripped (in this case it is).</p>
<p>We must not call <code>heap::deallocate</code> when <code>self.cap == 0</code>, as in this case we
haven't actually allocated any memory.</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Drop for Vec&lt;T&gt; {
    fn drop(&amp;mut self) {
        if self.cap != 0 {
            while let Some(_) = self.pop() { }

            let align = mem::align_of::&lt;T&gt;();
            let elem_size = mem::size_of::&lt;T&gt;();
            let num_bytes = elem_size * self.cap;
            unsafe {
                heap::deallocate(*self.ptr as *mut _, num_bytes, align);
            }
        }
    }
}
</code></pre>
<h1><a class="header" href="#deref" id="deref">Deref</a></h1>
<p>Alright! We've got a decent minimal stack implemented. We can push, we can
pop, and we can clean up after ourselves. However there's a whole mess of
functionality we'd reasonably want. In particular, we have a proper array, but
none of the slice functionality. That's actually pretty easy to solve: we can
implement <code>Deref&lt;Target=[T]&gt;</code>. This will magically make our Vec coerce to, and
behave like, a slice in all sorts of conditions.</p>
<p>All we need is <code>slice::from_raw_parts</code>. It will correctly handle empty slices
for us. Later once we set up zero-sized type support it will also Just Work
for those too.</p>
<pre><code class="language-rust ignore">use std::ops::Deref;

impl&lt;T&gt; Deref for Vec&lt;T&gt; {
    type Target = [T];
    fn deref(&amp;self) -&gt; &amp;[T] {
        unsafe {
            ::std::slice::from_raw_parts(*self.ptr, self.len)
        }
    }
}
</code></pre>
<p>And let's do DerefMut too:</p>
<pre><code class="language-rust ignore">use std::ops::DerefMut;

impl&lt;T&gt; DerefMut for Vec&lt;T&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut [T] {
        unsafe {
            ::std::slice::from_raw_parts_mut(*self.ptr, self.len)
        }
    }
}
</code></pre>
<p>Now we have <code>len</code>, <code>first</code>, <code>last</code>, indexing, slicing, sorting, <code>iter</code>,
<code>iter_mut</code>, and all other sorts of bells and whistles provided by slice. Sweet!</p>
<h1><a class="header" href="#insert-and-remove" id="insert-and-remove">Insert and Remove</a></h1>
<p>Something <em>not</em> provided by slice is <code>insert</code> and <code>remove</code>, so let's do those
next.</p>
<p>Insert needs to shift all the elements at the target index to the right by one.
To do this we need to use <code>ptr::copy</code>, which is our version of C's <code>memmove</code>.
This copies some chunk of memory from one location to another, correctly
handling the case where the source and destination overlap (which will
definitely happen here).</p>
<p>If we insert at index <code>i</code>, we want to shift the <code>[i .. len]</code> to <code>[i+1 .. len+1]</code>
using the old len.</p>
<pre><code class="language-rust ignore">pub fn insert(&amp;mut self, index: usize, elem: T) {
    // Note: `&lt;=` because it's valid to insert after everything
    // which would be equivalent to push.
    assert!(index &lt;= self.len, &quot;index out of bounds&quot;);
    if self.cap == self.len { self.grow(); }

    unsafe {
        if index &lt; self.len {
            // ptr::copy(src, dest, len): &quot;copy from source to dest len elems&quot;
            ptr::copy(self.ptr.offset(index as isize),
                      self.ptr.offset(index as isize + 1),
                      self.len - index);
        }
        ptr::write(self.ptr.offset(index as isize), elem);
        self.len += 1;
    }
}
</code></pre>
<p>Remove behaves in the opposite manner. We need to shift all the elements from
<code>[i+1 .. len + 1]</code> to <code>[i .. len]</code> using the <em>new</em> len.</p>
<pre><code class="language-rust ignore">pub fn remove(&amp;mut self, index: usize) -&gt; T {
    // Note: `&lt;` because it's *not* valid to remove after everything
    assert!(index &lt; self.len, &quot;index out of bounds&quot;);
    unsafe {
        self.len -= 1;
        let result = ptr::read(self.ptr.offset(index as isize));
        ptr::copy(self.ptr.offset(index as isize + 1),
                  self.ptr.offset(index as isize),
                  self.len - index);
        result
    }
}
</code></pre>
<h1><a class="header" href="#intoiter" id="intoiter">IntoIter</a></h1>
<p>Let's move on to writing iterators. <code>iter</code> and <code>iter_mut</code> have already been
written for us thanks to The Magic of Deref. However there's two interesting
iterators that Vec provides that slices can't: <code>into_iter</code> and <code>drain</code>.</p>
<p>IntoIter consumes the Vec by-value, and can consequently yield its elements
by-value. In order to enable this, IntoIter needs to take control of Vec's
allocation.</p>
<p>IntoIter needs to be DoubleEnded as well, to enable reading from both ends.
Reading from the back could just be implemented as calling <code>pop</code>, but reading
from the front is harder. We could call <code>remove(0)</code> but that would be insanely
expensive. Instead we're going to just use ptr::read to copy values out of
either end of the Vec without mutating the buffer at all.</p>
<p>To do this we're going to use a very common C idiom for array iteration. We'll
make two pointers; one that points to the start of the array, and one that
points to one-element past the end. When we want an element from one end, we'll
read out the value pointed to at that end and move the pointer over by one. When
the two pointers are equal, we know we're done.</p>
<p>Note that the order of read and offset are reversed for <code>next</code> and <code>next_back</code>
For <code>next_back</code> the pointer is always after the element it wants to read next,
while for <code>next</code> the pointer is always at the element it wants to read next.
To see why this is, consider the case where every element but one has been
yielded.</p>
<p>The array looks like this:</p>
<pre><code class="language-text">          S  E
[X, X, X, O, X, X, X]
</code></pre>
<p>If E pointed directly at the element it wanted to yield next, it would be
indistinguishable from the case where there are no more elements to yield.</p>
<p>Although we don't actually care about it during iteration, we also need to hold
onto the Vec's allocation information in order to free it once IntoIter is
dropped.</p>
<p>So we're going to use the following struct:</p>
<pre><code class="language-rust ignore">struct IntoIter&lt;T&gt; {
    buf: Unique&lt;T&gt;,
    cap: usize,
    start: *const T,
    end: *const T,
}
</code></pre>
<p>And this is what we end up with for initialization:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Vec&lt;T&gt; {
    fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        // Can't destructure Vec since it's Drop
        let ptr = self.ptr;
        let cap = self.cap;
        let len = self.len;

        // Make sure not to drop Vec since that will free the buffer
        mem::forget(self);

        unsafe {
            IntoIter {
                buf: ptr,
                cap: cap,
                start: *ptr,
                end: if cap == 0 {
                    // can't offset off this pointer, it's not allocated!
                    *ptr
                } else {
                    ptr.offset(len as isize)
                }
            }
        }
    }
}
</code></pre>
<p>Here's iterating forward:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.start == self.end {
            None
        } else {
            unsafe {
                let result = ptr::read(self.start);
                self.start = self.start.offset(1);
                Some(result)
            }
        }
    }

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        let len = (self.end as usize - self.start as usize)
                  / mem::size_of::&lt;T&gt;();
        (len, Some(len))
    }
}
</code></pre>
<p>And here's iterating backwards.</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; DoubleEndedIterator for IntoIter&lt;T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.start == self.end {
            None
        } else {
            unsafe {
                self.end = self.end.offset(-1);
                Some(ptr::read(self.end))
            }
        }
    }
}
</code></pre>
<p>Because IntoIter takes ownership of its allocation, it needs to implement Drop
to free it. However it also wants to implement Drop to drop any elements it
contains that weren't yielded.</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Drop for IntoIter&lt;T&gt; {
    fn drop(&amp;mut self) {
        if self.cap != 0 {
            // drop any remaining elements
            for _ in &amp;mut *self {}

            let align = mem::align_of::&lt;T&gt;();
            let elem_size = mem::size_of::&lt;T&gt;();
            let num_bytes = elem_size * self.cap;
            unsafe {
                heap::deallocate(*self.buf as *mut _, num_bytes, align);
            }
        }
    }
}
</code></pre>
<h1><a class="header" href="#rawvec" id="rawvec">RawVec</a></h1>
<p>We've actually reached an interesting situation here: we've duplicated the logic
for specifying a buffer and freeing its memory in Vec and IntoIter. Now that
we've implemented it and identified <em>actual</em> logic duplication, this is a good
time to perform some logic compression.</p>
<p>We're going to abstract out the <code>(ptr, cap)</code> pair and give them the logic for
allocating, growing, and freeing:</p>
<pre><code class="language-rust ignore">struct RawVec&lt;T&gt; {
    ptr: Unique&lt;T&gt;,
    cap: usize,
}

impl&lt;T&gt; RawVec&lt;T&gt; {
    fn new() -&gt; Self {
        assert!(mem::size_of::&lt;T&gt;() != 0, &quot;TODO: implement ZST support&quot;);
        unsafe {
            RawVec { ptr: Unique::new(heap::EMPTY as *mut T), cap: 0 }
        }
    }

    // unchanged from Vec
    fn grow(&amp;mut self) {
        unsafe {
            let align = mem::align_of::&lt;T&gt;();
            let elem_size = mem::size_of::&lt;T&gt;();

            let (new_cap, ptr) = if self.cap == 0 {
                let ptr = heap::allocate(elem_size, align);
                (1, ptr)
            } else {
                let new_cap = 2 * self.cap;
                let ptr = heap::reallocate(*self.ptr as *mut _,
                                            self.cap * elem_size,
                                            new_cap * elem_size,
                                            align);
                (new_cap, ptr)
            };

            // If allocate or reallocate fail, we'll get `null` back
            if ptr.is_null() { oom() }

            self.ptr = Unique::new(ptr as *mut _);
            self.cap = new_cap;
        }
    }
}


impl&lt;T&gt; Drop for RawVec&lt;T&gt; {
    fn drop(&amp;mut self) {
        if self.cap != 0 {
            let align = mem::align_of::&lt;T&gt;();
            let elem_size = mem::size_of::&lt;T&gt;();
            let num_bytes = elem_size * self.cap;
            unsafe {
                heap::deallocate(*self.ptr as *mut _, num_bytes, align);
            }
        }
    }
}
</code></pre>
<p>And change Vec as follows:</p>
<pre><code class="language-rust ignore">pub struct Vec&lt;T&gt; {
    buf: RawVec&lt;T&gt;,
    len: usize,
}

impl&lt;T&gt; Vec&lt;T&gt; {
    fn ptr(&amp;self) -&gt; *mut T { *self.buf.ptr }

    fn cap(&amp;self) -&gt; usize { self.buf.cap }

    pub fn new() -&gt; Self {
        Vec { buf: RawVec::new(), len: 0 }
    }

    // push/pop/insert/remove largely unchanged:
    // * `self.ptr -&gt; self.ptr()`
    // * `self.cap -&gt; self.cap()`
    // * `self.grow -&gt; self.buf.grow()`
}

impl&lt;T&gt; Drop for Vec&lt;T&gt; {
    fn drop(&amp;mut self) {
        while let Some(_) = self.pop() {}
        // deallocation is handled by RawVec
    }
}
</code></pre>
<p>And finally we can really simplify IntoIter:</p>
<pre><code class="language-rust ignore">struct IntoIter&lt;T&gt; {
    _buf: RawVec&lt;T&gt;, // we don't actually care about this. Just need it to live.
    start: *const T,
    end: *const T,
}

// next and next_back literally unchanged since they never referred to the buf

impl&lt;T&gt; Drop for IntoIter&lt;T&gt; {
    fn drop(&amp;mut self) {
        // only need to ensure all our elements are read;
        // buffer will clean itself up afterwards.
        for _ in &amp;mut *self {}
    }
}

impl&lt;T&gt; Vec&lt;T&gt; {
    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        unsafe {
            // need to use ptr::read to unsafely move the buf out since it's
            // not Copy, and Vec implements Drop (so we can't destructure it).
            let buf = ptr::read(&amp;self.buf);
            let len = self.len;
            mem::forget(self);

            IntoIter {
                start: *buf.ptr,
                end: buf.ptr.offset(len as isize),
                _buf: buf,
            }
        }
    }
}
</code></pre>
<p>Much better.</p>
<h1><a class="header" href="#drain-1" id="drain-1">Drain</a></h1>
<p>Let's move on to Drain. Drain is largely the same as IntoIter, except that
instead of consuming the Vec, it borrows the Vec and leaves its allocation
untouched. For now we'll only implement the &quot;basic&quot; full-range version.</p>
<pre><code class="language-rust ignore">use std::marker::PhantomData;

struct Drain&lt;'a, T: 'a&gt; {
    // Need to bound the lifetime here, so we do it with `&amp;'a mut Vec&lt;T&gt;`
    // because that's semantically what we contain. We're &quot;just&quot; calling
    // `pop()` and `remove(0)`.
    vec: PhantomData&lt;&amp;'a mut Vec&lt;T&gt;&gt;
    start: *const T,
    end: *const T,
}

impl&lt;'a, T&gt; Iterator for Drain&lt;'a, T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.start == self.end {
            None
</code></pre>
<p>-- wait, this is seeming familiar. Let's do some more compression. Both
IntoIter and Drain have the exact same structure, let's just factor it out.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct RawValIter&lt;T&gt; {
    start: *const T,
    end: *const T,
}

impl&lt;T&gt; RawValIter&lt;T&gt; {
    // unsafe to construct because it has no associated lifetimes.
    // This is necessary to store a RawValIter in the same struct as
    // its actual allocation. OK since it's a private implementation
    // detail.
    unsafe fn new(slice: &amp;[T]) -&gt; Self {
        RawValIter {
            start: slice.as_ptr(),
            end: if slice.len() == 0 {
                // if `len = 0`, then this is not actually allocated memory.
                // Need to avoid offsetting because that will give wrong
                // information to LLVM via GEP.
                slice.as_ptr()
            } else {
                slice.as_ptr().offset(slice.len() as isize)
            }
        }
    }
}

// Iterator and DoubleEndedIterator impls identical to IntoIter.
<span class="boring">}
</span></code></pre></pre>
<p>And IntoIter becomes the following:</p>
<pre><code class="language-rust ignore">pub struct IntoIter&lt;T&gt; {
    _buf: RawVec&lt;T&gt;, // we don't actually care about this. Just need it to live.
    iter: RawValIter&lt;T&gt;,
}

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;T&gt; { self.iter.next() }
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) { self.iter.size_hint() }
}

impl&lt;T&gt; DoubleEndedIterator for IntoIter&lt;T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; { self.iter.next_back() }
}

impl&lt;T&gt; Drop for IntoIter&lt;T&gt; {
    fn drop(&amp;mut self) {
        for _ in &amp;mut self.iter {}
    }
}

impl&lt;T&gt; Vec&lt;T&gt; {
    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        unsafe {
            let iter = RawValIter::new(&amp;self);

            let buf = ptr::read(&amp;self.buf);
            mem::forget(self);

            IntoIter {
                iter: iter,
                _buf: buf,
            }
        }
    }
}
</code></pre>
<p>Note that I've left a few quirks in this design to make upgrading Drain to work
with arbitrary subranges a bit easier. In particular we <em>could</em> have RawValIter
drain itself on drop, but that won't work right for a more complex Drain.
We also take a slice to simplify Drain initialization.</p>
<p>Alright, now Drain is really easy:</p>
<pre><code class="language-rust ignore">use std::marker::PhantomData;

pub struct Drain&lt;'a, T: 'a&gt; {
    vec: PhantomData&lt;&amp;'a mut Vec&lt;T&gt;&gt;,
    iter: RawValIter&lt;T&gt;,
}

impl&lt;'a, T&gt; Iterator for Drain&lt;'a, T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;T&gt; { self.iter.next() }
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) { self.iter.size_hint() }
}

impl&lt;'a, T&gt; DoubleEndedIterator for Drain&lt;'a, T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; { self.iter.next_back() }
}

impl&lt;'a, T&gt; Drop for Drain&lt;'a, T&gt; {
    fn drop(&amp;mut self) {
        for _ in &amp;mut self.iter {}
    }
}

impl&lt;T&gt; Vec&lt;T&gt; {
    pub fn drain(&amp;mut self) -&gt; Drain&lt;T&gt; {
        unsafe {
            let iter = RawValIter::new(&amp;self);

            // this is a mem::forget safety thing. If Drain is forgotten, we just
            // leak the whole Vec's contents. Also we need to do this *eventually*
            // anyway, so why not do it now?
            self.len = 0;

            Drain {
                iter: iter,
                vec: PhantomData,
            }
        }
    }
}
</code></pre>
<p>For more details on the <code>mem::forget</code> problem, see the
<a href="leaking.html">section on leaks</a>.</p>
<h1><a class="header" href="#handling-zero-sized-types" id="handling-zero-sized-types">Handling Zero-Sized Types</a></h1>
<p>It's time. We're going to fight the specter that is zero-sized types. Safe Rust
<em>never</em> needs to care about this, but Vec is very intensive on raw pointers and
raw allocations, which are exactly the two things that care about
zero-sized types. We need to be careful of two things:</p>
<ul>
<li>The raw allocator API has undefined behavior if you pass in 0 for an
allocation size.</li>
<li>raw pointer offsets are no-ops for zero-sized types, which will break our
C-style pointer iterator.</li>
</ul>
<p>Thankfully we abstracted out pointer-iterators and allocating handling into
RawValIter and RawVec respectively. How mysteriously convenient.</p>
<h2><a class="header" href="#allocating-zero-sized-types" id="allocating-zero-sized-types">Allocating Zero-Sized Types</a></h2>
<p>So if the allocator API doesn't support zero-sized allocations, what on earth
do we store as our allocation? Why, <code>heap::EMPTY</code> of course! Almost every operation
with a ZST is a no-op since ZSTs have exactly one value, and therefore no state needs
to be considered to store or load them. This actually extends to <code>ptr::read</code> and
<code>ptr::write</code>: they won't actually look at the pointer at all. As such we never need
to change the pointer.</p>
<p>Note however that our previous reliance on running out of memory before overflow is
no longer valid with zero-sized types. We must explicitly guard against capacity
overflow for zero-sized types.</p>
<p>Due to our current architecture, all this means is writing 3 guards, one in each
method of RawVec.</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; RawVec&lt;T&gt; {
    fn new() -&gt; Self {
        unsafe {
            // !0 is usize::MAX. This branch should be stripped at compile time.
            let cap = if mem::size_of::&lt;T&gt;() == 0 { !0 } else { 0 };

            // heap::EMPTY doubles as &quot;unallocated&quot; and &quot;zero-sized allocation&quot;
            RawVec { ptr: Unique::new(heap::EMPTY as *mut T), cap: cap }
        }
    }

    fn grow(&amp;mut self) {
        unsafe {
            let elem_size = mem::size_of::&lt;T&gt;();

            // since we set the capacity to usize::MAX when elem_size is
            // 0, getting to here necessarily means the Vec is overfull.
            assert!(elem_size != 0, &quot;capacity overflow&quot;);

            let align = mem::align_of::&lt;T&gt;();

            let (new_cap, ptr) = if self.cap == 0 {
                let ptr = heap::allocate(elem_size, align);
                (1, ptr)
            } else {
                let new_cap = 2 * self.cap;
                let ptr = heap::reallocate(*self.ptr as *mut _,
                                            self.cap * elem_size,
                                            new_cap * elem_size,
                                            align);
                (new_cap, ptr)
            };

            // If allocate or reallocate fail, we'll get `null` back
            if ptr.is_null() { oom() }

            self.ptr = Unique::new(ptr as *mut _);
            self.cap = new_cap;
        }
    }
}

impl&lt;T&gt; Drop for RawVec&lt;T&gt; {
    fn drop(&amp;mut self) {
        let elem_size = mem::size_of::&lt;T&gt;();

        // don't free zero-sized allocations, as they were never allocated.
        if self.cap != 0 &amp;&amp; elem_size != 0 {
            let align = mem::align_of::&lt;T&gt;();

            let num_bytes = elem_size * self.cap;
            unsafe {
                heap::deallocate(*self.ptr as *mut _, num_bytes, align);
            }
        }
    }
}
</code></pre>
<p>That's it. We support pushing and popping zero-sized types now. Our iterators
(that aren't provided by slice Deref) are still busted, though.</p>
<h2><a class="header" href="#iterating-zero-sized-types" id="iterating-zero-sized-types">Iterating Zero-Sized Types</a></h2>
<p>Zero-sized offsets are no-ops. This means that our current design will always
initialize <code>start</code> and <code>end</code> as the same value, and our iterators will yield
nothing. The current solution to this is to cast the pointers to integers,
increment, and then cast them back:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; RawValIter&lt;T&gt; {
    unsafe fn new(slice: &amp;[T]) -&gt; Self {
        RawValIter {
            start: slice.as_ptr(),
            end: if mem::size_of::&lt;T&gt;() == 0 {
                ((slice.as_ptr() as usize) + slice.len()) as *const _
            } else if slice.len() == 0 {
                slice.as_ptr()
            } else {
                slice.as_ptr().offset(slice.len() as isize)
            }
        }
    }
}
</code></pre>
<p>Now we have a different bug. Instead of our iterators not running at all, our
iterators now run <em>forever</em>. We need to do the same trick in our iterator impls.
Also, our size_hint computation code will divide by 0 for ZSTs. Since we'll
basically be treating the two pointers as if they point to bytes, we'll just
map size 0 to divide by 1.</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Iterator for RawValIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.start == self.end {
            None
        } else {
            unsafe {
                let result = ptr::read(self.start);
                self.start = if mem::size_of::&lt;T&gt;() == 0 {
                    (self.start as usize + 1) as *const _
                } else {
                    self.start.offset(1)
                };
                Some(result)
            }
        }
    }

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        let elem_size = mem::size_of::&lt;T&gt;();
        let len = (self.end as usize - self.start as usize)
                  / if elem_size == 0 { 1 } else { elem_size };
        (len, Some(len))
    }
}

impl&lt;T&gt; DoubleEndedIterator for RawValIter&lt;T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.start == self.end {
            None
        } else {
            unsafe {
                self.end = if mem::size_of::&lt;T&gt;() == 0 {
                    (self.end as usize - 1) as *const _
                } else {
                    self.end.offset(-1)
                };
                Some(ptr::read(self.end))
            }
        }
    }
}
</code></pre>
<p>And that's it. Iteration works!</p>
<h1><a class="header" href="#the-final-code" id="the-final-code">The Final Code</a></h1>
<pre><pre class="playground"><code class="language-rust">#![feature(unique)]
#![feature(alloc, heap_api)]

extern crate alloc;

use std::ptr::{Unique, self};
use std::mem;
use std::ops::{Deref, DerefMut};
use std::marker::PhantomData;

use alloc::heap;

struct RawVec&lt;T&gt; {
    ptr: Unique&lt;T&gt;,
    cap: usize,
}

impl&lt;T&gt; RawVec&lt;T&gt; {
    fn new() -&gt; Self {
        unsafe {
            // !0 is usize::MAX. This branch should be stripped at compile time.
            let cap = if mem::size_of::&lt;T&gt;() == 0 { !0 } else { 0 };

            // heap::EMPTY doubles as &quot;unallocated&quot; and &quot;zero-sized allocation&quot;
            RawVec { ptr: Unique::new(heap::EMPTY as *mut T), cap: cap }
        }
    }

    fn grow(&amp;mut self) {
        unsafe {
            let elem_size = mem::size_of::&lt;T&gt;();

            // since we set the capacity to usize::MAX when elem_size is
            // 0, getting to here necessarily means the Vec is overfull.
            assert!(elem_size != 0, &quot;capacity overflow&quot;);

            let align = mem::align_of::&lt;T&gt;();

            let (new_cap, ptr) = if self.cap == 0 {
                let ptr = heap::allocate(elem_size, align);
                (1, ptr)
            } else {
                let new_cap = 2 * self.cap;
                let ptr = heap::reallocate(*self.ptr as *mut _,
                                            self.cap * elem_size,
                                            new_cap * elem_size,
                                            align);
                (new_cap, ptr)
            };

            // If allocate or reallocate fail, we'll get `null` back
            if ptr.is_null() { oom() }

            self.ptr = Unique::new(ptr as *mut _);
            self.cap = new_cap;
        }
    }
}

impl&lt;T&gt; Drop for RawVec&lt;T&gt; {
    fn drop(&amp;mut self) {
        let elem_size = mem::size_of::&lt;T&gt;();
        if self.cap != 0 &amp;&amp; elem_size != 0 {
            let align = mem::align_of::&lt;T&gt;();

            let num_bytes = elem_size * self.cap;
            unsafe {
                heap::deallocate(*self.ptr as *mut _, num_bytes, align);
            }
        }
    }
}





pub struct Vec&lt;T&gt; {
    buf: RawVec&lt;T&gt;,
    len: usize,
}

impl&lt;T&gt; Vec&lt;T&gt; {
    fn ptr(&amp;self) -&gt; *mut T { *self.buf.ptr }

    fn cap(&amp;self) -&gt; usize { self.buf.cap }

    pub fn new() -&gt; Self {
        Vec { buf: RawVec::new(), len: 0 }
    }
    pub fn push(&amp;mut self, elem: T) {
        if self.len == self.cap() { self.buf.grow(); }

        unsafe {
            ptr::write(self.ptr().offset(self.len as isize), elem);
        }

        // Can't fail, we'll OOM first.
        self.len += 1;
    }

    pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.len == 0 {
            None
        } else {
            self.len -= 1;
            unsafe {
                Some(ptr::read(self.ptr().offset(self.len as isize)))
            }
        }
    }

    pub fn insert(&amp;mut self, index: usize, elem: T) {
        assert!(index &lt;= self.len, &quot;index out of bounds&quot;);
        if self.cap() == self.len { self.buf.grow(); }

        unsafe {
            if index &lt; self.len {
                ptr::copy(self.ptr().offset(index as isize),
                          self.ptr().offset(index as isize + 1),
                          self.len - index);
            }
            ptr::write(self.ptr().offset(index as isize), elem);
            self.len += 1;
        }
    }

    pub fn remove(&amp;mut self, index: usize) -&gt; T {
        assert!(index &lt; self.len, &quot;index out of bounds&quot;);
        unsafe {
            self.len -= 1;
            let result = ptr::read(self.ptr().offset(index as isize));
            ptr::copy(self.ptr().offset(index as isize + 1),
                      self.ptr().offset(index as isize),
                      self.len - index);
            result
        }
    }

    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        unsafe {
            let iter = RawValIter::new(&amp;self);
            let buf = ptr::read(&amp;self.buf);
            mem::forget(self);

            IntoIter {
                iter: iter,
                _buf: buf,
            }
        }
    }

    pub fn drain(&amp;mut self) -&gt; Drain&lt;T&gt; {
        unsafe {
            let iter = RawValIter::new(&amp;self);

            // this is a mem::forget safety thing. If Drain is forgotten, we just
            // leak the whole Vec's contents. Also we need to do this *eventually*
            // anyway, so why not do it now?
            self.len = 0;

            Drain {
                iter: iter,
                vec: PhantomData,
            }
        }
    }
}

impl&lt;T&gt; Drop for Vec&lt;T&gt; {
    fn drop(&amp;mut self) {
        while let Some(_) = self.pop() {}
        // allocation is handled by RawVec
    }
}

impl&lt;T&gt; Deref for Vec&lt;T&gt; {
    type Target = [T];
    fn deref(&amp;self) -&gt; &amp;[T] {
        unsafe {
            ::std::slice::from_raw_parts(self.ptr(), self.len)
        }
    }
}

impl&lt;T&gt; DerefMut for Vec&lt;T&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut [T] {
        unsafe {
            ::std::slice::from_raw_parts_mut(self.ptr(), self.len)
        }
    }
}





struct RawValIter&lt;T&gt; {
    start: *const T,
    end: *const T,
}

impl&lt;T&gt; RawValIter&lt;T&gt; {
    unsafe fn new(slice: &amp;[T]) -&gt; Self {
        RawValIter {
            start: slice.as_ptr(),
            end: if mem::size_of::&lt;T&gt;() == 0 {
                ((slice.as_ptr() as usize) + slice.len()) as *const _
            } else if slice.len() == 0 {
                slice.as_ptr()
            } else {
                slice.as_ptr().offset(slice.len() as isize)
            }
        }
    }
}

impl&lt;T&gt; Iterator for RawValIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.start == self.end {
            None
        } else {
            unsafe {
                let result = ptr::read(self.start);
                self.start = if mem::size_of::&lt;T&gt;() == 0 {
                    (self.start as usize + 1) as *const _
                } else {
                    self.start.offset(1)
                };
                Some(result)
            }
        }
    }

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        let elem_size = mem::size_of::&lt;T&gt;();
        let len = (self.end as usize - self.start as usize)
                  / if elem_size == 0 { 1 } else { elem_size };
        (len, Some(len))
    }
}

impl&lt;T&gt; DoubleEndedIterator for RawValIter&lt;T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.start == self.end {
            None
        } else {
            unsafe {
                self.end = if mem::size_of::&lt;T&gt;() == 0 {
                    (self.end as usize - 1) as *const _
                } else {
                    self.end.offset(-1)
                };
                Some(ptr::read(self.end))
            }
        }
    }
}




pub struct IntoIter&lt;T&gt; {
    _buf: RawVec&lt;T&gt;, // we don't actually care about this. Just need it to live.
    iter: RawValIter&lt;T&gt;,
}

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;T&gt; { self.iter.next() }
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) { self.iter.size_hint() }
}

impl&lt;T&gt; DoubleEndedIterator for IntoIter&lt;T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; { self.iter.next_back() }
}

impl&lt;T&gt; Drop for IntoIter&lt;T&gt; {
    fn drop(&amp;mut self) {
        for _ in &amp;mut *self {}
    }
}




pub struct Drain&lt;'a, T: 'a&gt; {
    vec: PhantomData&lt;&amp;'a mut Vec&lt;T&gt;&gt;,
    iter: RawValIter&lt;T&gt;,
}

impl&lt;'a, T&gt; Iterator for Drain&lt;'a, T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;T&gt; { self.iter.next_back() }
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) { self.iter.size_hint() }
}

impl&lt;'a, T&gt; DoubleEndedIterator for Drain&lt;'a, T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; { self.iter.next_back() }
}

impl&lt;'a, T&gt; Drop for Drain&lt;'a, T&gt; {
    fn drop(&amp;mut self) {
        // pre-drain the iter
        for _ in &amp;mut self.iter {}
    }
}

/// Abort the process, we're out of memory!
///
/// In practice this is probably dead code on most OSes
fn oom() {
    ::std::process::exit(-9999);
}

<span class="boring">fn main() {}
</span></code></pre></pre>
<h1><a class="header" href="#implementing-arc-and-mutex" id="implementing-arc-and-mutex">Implementing Arc and Mutex</a></h1>
<p>Knowing the theory is all fine and good, but the <em>best</em> way to understand
something is to use it. To better understand atomics and interior mutability,
we'll be implementing versions of the standard library's Arc and Mutex types.</p>
<p>TODO: ALL OF THIS OMG</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
