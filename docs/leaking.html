<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>リーク</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">はじめに</a></li><li class="chapter-item expanded "><a href="meet-safe-and-unsafe.html"><strong aria-hidden="true">1.</strong> 安全と危険のご紹介</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="safe-unsafe-meaning.html"><strong aria-hidden="true">1.1.</strong> 安全と危険の相互作用</a></li><li class="chapter-item expanded "><a href="working-with-unsafe.html"><strong aria-hidden="true">1.2.</strong> Unsafe と連携する</a></li></ol></li><li class="chapter-item expanded "><a href="data.html"><strong aria-hidden="true">2.</strong> データレイアウト</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="repr-rust.html"><strong aria-hidden="true">2.1.</strong> repr(Rust)</a></li><li class="chapter-item expanded "><a href="exotic-sizes.html"><strong aria-hidden="true">2.2.</strong> 奇妙なサイズの型</a></li><li class="chapter-item expanded "><a href="other-reprs.html"><strong aria-hidden="true">2.3.</strong> 代替メモリレイアウト</a></li></ol></li><li class="chapter-item expanded "><a href="ownership.html"><strong aria-hidden="true">3.</strong> 所有権とライフタイム</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">3.1.</strong> リファレンス</a></li><li class="chapter-item expanded "><a href="lifetimes.html"><strong aria-hidden="true">3.2.</strong> ライフタイム</a></li><li class="chapter-item expanded "><a href="lifetime-mismatch.html"><strong aria-hidden="true">3.3.</strong> ライフタイムシステムの限界</a></li><li class="chapter-item expanded "><a href="lifetime-elision.html"><strong aria-hidden="true">3.4.</strong> ライフタイムの省略</a></li><li class="chapter-item expanded "><a href="unbounded-lifetimes.html"><strong aria-hidden="true">3.5.</strong> 無制限のライフタイム</a></li><li class="chapter-item expanded "><a href="hrtb.html"><strong aria-hidden="true">3.6.</strong> 高階トレイト境界</a></li><li class="chapter-item expanded "><a href="subtyping.html"><strong aria-hidden="true">3.7.</strong> Subtyping and Variance</a></li><li class="chapter-item expanded "><a href="dropck.html"><strong aria-hidden="true">3.8.</strong> Drop Check</a></li><li class="chapter-item expanded "><a href="phantom-data.html"><strong aria-hidden="true">3.9.</strong> PhantomData</a></li><li class="chapter-item expanded "><a href="borrow-splitting.html"><strong aria-hidden="true">3.10.</strong> 借用の分割</a></li></ol></li><li class="chapter-item expanded "><a href="conversions.html"><strong aria-hidden="true">4.</strong> 型変換</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="coercions.html"><strong aria-hidden="true">4.1.</strong> 型強制</a></li><li class="chapter-item expanded "><a href="dot-operator.html"><strong aria-hidden="true">4.2.</strong> ドットオペレータ</a></li><li class="chapter-item expanded "><a href="casts.html"><strong aria-hidden="true">4.3.</strong> キャスト</a></li><li class="chapter-item expanded "><a href="transmutes.html"><strong aria-hidden="true">4.4.</strong> トランスミュート</a></li></ol></li><li class="chapter-item expanded "><a href="uninitialized.html"><strong aria-hidden="true">5.</strong> 初期化されないメモリ</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="checked-uninit.html"><strong aria-hidden="true">5.1.</strong> チェックされるメモリ</a></li><li class="chapter-item expanded "><a href="drop-flags.html"><strong aria-hidden="true">5.2.</strong> ドロップフラグ</a></li><li class="chapter-item expanded "><a href="unchecked-uninit.html"><strong aria-hidden="true">5.3.</strong> チェックされないメモリ</a></li></ol></li><li class="chapter-item expanded "><a href="obrm.html"><strong aria-hidden="true">6.</strong> 所有権に基づいたリソース管理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="constructors.html"><strong aria-hidden="true">6.1.</strong> コンストラクタ</a></li><li class="chapter-item expanded "><a href="destructors.html"><strong aria-hidden="true">6.2.</strong> Destructors</a></li><li class="chapter-item expanded "><a href="leaking.html" class="active"><strong aria-hidden="true">6.3.</strong> リーク</a></li></ol></li><li class="chapter-item expanded "><a href="unwinding.html"><strong aria-hidden="true">7.</strong> 巻き戻し</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="exception-safety.html"><strong aria-hidden="true">7.1.</strong> 例外安全性</a></li><li class="chapter-item expanded "><a href="poisoning.html"><strong aria-hidden="true">7.2.</strong> ポイゾニング</a></li></ol></li><li class="chapter-item expanded "><a href="concurrency.html"><strong aria-hidden="true">8.</strong> 並行性</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="races.html"><strong aria-hidden="true">8.1.</strong> 競合</a></li><li class="chapter-item expanded "><a href="send-and-sync.html"><strong aria-hidden="true">8.2.</strong> Send and Sync</a></li><li class="chapter-item expanded "><a href="atomics.html"><strong aria-hidden="true">8.3.</strong> Atomics</a></li></ol></li><li class="chapter-item expanded "><a href="vec.html"><strong aria-hidden="true">9.</strong> Vec の実装</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="vec-layout.html"><strong aria-hidden="true">9.1.</strong> Layout</a></li><li class="chapter-item expanded "><a href="vec-alloc.html"><strong aria-hidden="true">9.2.</strong> Allocating</a></li><li class="chapter-item expanded "><a href="vec-push-pop.html"><strong aria-hidden="true">9.3.</strong> Push and Pop</a></li><li class="chapter-item expanded "><a href="vec-dealloc.html"><strong aria-hidden="true">9.4.</strong> Deallocating</a></li><li class="chapter-item expanded "><a href="vec-deref.html"><strong aria-hidden="true">9.5.</strong> Deref</a></li><li class="chapter-item expanded "><a href="vec-insert-remove.html"><strong aria-hidden="true">9.6.</strong> Insert and Remove</a></li><li class="chapter-item expanded "><a href="vec-into-iter.html"><strong aria-hidden="true">9.7.</strong> IntoIter</a></li><li class="chapter-item expanded "><a href="vec-raw.html"><strong aria-hidden="true">9.8.</strong> RawVec</a></li><li class="chapter-item expanded "><a href="vec-drain.html"><strong aria-hidden="true">9.9.</strong> Drain</a></li><li class="chapter-item expanded "><a href="vec-zsts.html"><strong aria-hidden="true">9.10.</strong> Handling Zero-Sized Types</a></li><li class="chapter-item expanded "><a href="vec-final.html"><strong aria-hidden="true">9.11.</strong> Final Code</a></li></ol></li><li class="chapter-item expanded "><a href="arc-and-mutex.html"><strong aria-hidden="true">10.</strong> Implementing Arc and Mutex</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
# Leaking
-->
<h1><a class="header" href="#リーク" id="リーク">リーク</a></h1>
<!--
Ownership-based resource management is intended to simplify composition. You
acquire resources when you create the object, and you release the resources when
it gets destroyed. Since destruction is handled for you, it means you can't
forget to release the resources, and it happens as soon as possible! Surely this
is perfect and all of our problems are solved.
-->
<p>所有権に基づいたリソース管理は、構成を単純にすることを意図しています。
オブジェクトを生成すると、リソースを獲得します。そして、オブジェクトが
破棄されるとリソースを解放します。オブジェクトは自動的に破棄されるので、
リソースは必ず解放されますし、できるだけ早く解放されるのです!
明らかにこれは完全で、我々の全ての問題は解決します。</p>
<!--
Everything is terrible and we have new and exotic problems to try to solve.
-->
<p>実際にはこれは最悪で、我々には新しくそして風変わりな問題が与えられるのです。</p>
<!--
Many people like to believe that Rust eliminates resource leaks. In practice,
this is basically true. You would be surprised to see a Safe Rust program
leak resources in an uncontrolled way.
-->
<p>多くの人々は、 Rust はリソースのリークを取り除いたと信じることが好きです。
実際、これは基本的には正しいです。安全な Rust のプログラムが、制御不能なやり方で、
リソースをリークしたら驚くでしょう。</p>
<!--
However from a theoretical perspective this is absolutely not the case, no
matter how you look at it. In the strictest sense, "leaking" is so abstract as
to be unpreventable. It's quite trivial to initialize a collection at the start
of a program, fill it with tons of objects with destructors, and then enter an
infinite event loop that never refers to it. The collection will sit around
uselessly, holding on to its precious resources until the program terminates (at
which point all those resources would have been reclaimed by the OS anyway).
-->
<p>しかしながら理論的な観点から見れば、どのように見ても、これは全く真実ではありません。
最も厳密な意味では、 &quot;リーク&quot; は非常に抽象的で、防げるものではありません。
プログラムの始めにコレクションを初期化し、デストラクタと共に沢山のオブジェクトで
いっぱいにし、そしてこのコレクションを絶対に参照しない無限イベントループに
突入することは極めて些細なことです。コレクションはプログラムが終わるまで、
貴重な資源を保持し続けたまま、使われず無駄に浪費し続けます (そして OS によって
結局全ての資源は返還されますが) 。</p>
<!--
We may consider a more restricted form of leak: failing to drop a value that is
unreachable. Rust also doesn't prevent this. In fact Rust *has a function for
doing this*: `mem::forget`. This function consumes the value it is passed *and
then doesn't run its destructor*.
-->
<p>より厳密なリークの形式を考えたほうが良いかもしれません。到達できない値を
ドロップし損ねることです。 Rust はこれも防ぐことが出来ません。実際 Rust には、
<em>これを行なう関数があります</em>。 <code>mem::forget</code> です。この関数は渡された値を消費し、
<em>そしてその値のデストラクタを実行しません</em>。</p>
<!--
In the past `mem::forget` was marked as unsafe as a sort of lint against using
it, since failing to call a destructor is generally not a well-behaved thing to
do (though useful for some special unsafe code). However this was generally
determined to be an untenable stance to take: there are many ways to fail to
call a destructor in safe code. The most famous example is creating a cycle of
reference-counted pointers using interior mutability.
-->
<p>過去に <code>mem::forget</code> は、リントにおいてアンセーフとしてマークされていました。
デストラクタを呼ばないことは、通常行儀の良い方法ではないからです (いくつかの
特別なアンセーフのコードにおいては便利ですが) 。
しかしこれは、一般的に次の意見に対して擁護できない考えだと決定されました。
すなわち、 安全なコードでデストラクタを呼び損ねる方法が沢山存在するのです。
最も有名な例は、内部可変性を使用した、参照カウント方式のポインタの循環を生成
することです。</p>
<!--
It is reasonable for safe code to assume that destructor leaks do not happen, as
any program that leaks destructors is probably wrong. However *unsafe* code
cannot rely on destructors to be run in order to be safe. For most types this
doesn't matter: if you leak the destructor then the type is by definition
inaccessible, so it doesn't matter, right? For instance, if you leak a `Box<u8>`
then you waste some memory but that's hardly going to violate memory-safety.
-->
<p>安全なコードが、デストラクタのリークが起こらないと見なすことは理に適っています。
いかなるプログラムにおいても、デストラクタをリークするようなものは大体間違っていますから。
しかし、<em>アンセーフな</em>コードは、デストラクタがきちんと安全に実行されると信用できません。
ほとんどの型にとっては、これは問題ではありません。もしデストラクタをリークしたら、
当然その型へはアクセス不可能となります。ですからこれは問題ではありません。
そうですよね? 例えば、 <code>Box&lt;u8&gt;</code> をリークしても、いくらかのメモリを無駄にはしますが、
メモリ安全性はほとんど侵害することがないでしょう。</p>
<!--
However where we must be careful with destructor leaks are *proxy* types. These
are types which manage access to a distinct object, but don't actually own it.
Proxy objects are quite rare. Proxy objects you'll need to care about are even
rarer. However we'll focus on three interesting examples in the standard
library:
-->
<p>しかし、デストラクタのリークに対して注意深くならなければいけない場合は、<em>プロキシ</em>型です。
これらは、なんとかして異なったオブジェクトにアクセスするものの、そのオブジェクトを
実際には所有しない型です。プロキシオブジェクトは極めて稀です。気を付ける必要のある
プロキシオブジェクトに至っては殊更稀です。しかし、ここでは標準ライブラリにある 3 つの
興味深い例について着目していきます。</p>
<ul>
<li><code>vec::Drain</code></li>
<li><code>Rc</code></li>
<li><code>thread::scoped::JoinGuard</code></li>
</ul>
<h2><a class="header" href="#drain" id="drain">Drain</a></h2>
<!--
`drain` is a collections API that moves data out of the container without
consuming the container. This enables us to reuse the allocation of a `Vec`
after claiming ownership over all of its contents. It produces an iterator
(Drain) that returns the contents of the Vec by-value.
-->
<p><code>drain</code> は、コンテナを消費せずにコンテナからデータをムーブする、
コレクションの API です。これによって、 <code>Vec</code> の全ての内容の所有権を獲得した後に、 <code>Vec</code> の
アロケーションを再利用することが出来ます。 <code>drain</code> は Vec の内容を値で返すイテレータ (Drain) を
生成します。</p>
<!--
Now, consider Drain in the middle of iteration: some values have been moved out,
and others haven't. This means that part of the Vec is now full of logically
uninitialized data! We could backshift all the elements in the Vec every time we
remove a value, but this would have pretty catastrophic performance
consequences.
-->
<p>では、 Drain がイテレーションの真っ最中であるとしましょう。ムーブされた値もあれば、
まだの値もあります。つまりこれは、 Vec の一部のデータが今、論理的には未初期化のデータで
埋まっていることを意味します! 値を削除する度に Vec の要素をずらすことも出来たでしょう。
けれどもこれは結果的に、パフォーマンスをひどく落とすことになるでしょう。</p>
<!--
Instead, we would like Drain to fix the Vec's backing storage when it is
dropped. It should run itself to completion, backshift any elements that weren't
removed (drain supports subranges), and then fix Vec's `len`. It's even
unwinding-safe! Easy!
-->
<p>その代わりに Drain がドロップする時に、 Vecの背後にあるストレージを
修正するようにしたいと思います。 Drain を使い終わったら、削除されなかった要素を
ずらし (Drain は副範囲をサポートしています) 、そして Vec の <code>len</code> を修正します。
巻き戻し安全でもあります! 安心!</p>
<!--
Now consider the following:
-->
<p>それでは以下の例を考えてみましょう。</p>
<pre><code class="language-rust ignore">let mut vec = vec![Box::new(0); 4];

{
    // ドレインを開始します。 vec にはもうアクセスできません
    let mut drainer = vec.drain(..);

    // 2 つの値を引き出し、即座にドロップします
    drainer.next();
    drainer.next();

    // drainer を取り除きますが、デストラクタは呼び出しません
    mem::forget(drainer);
}

// しまった、 vec[0] はドロップされていたんだった、解放されたメモリを読み出そうとしているぞ!
println!(&quot;{}&quot;, vec[0]);
</code></pre>
<!--
This is pretty clearly Not Good. Unfortunately, we're kind of stuck between a
rock and a hard place: maintaining consistent state at every step has an
enormous cost (and would negate any benefits of the API). Failing to maintain
consistent state gives us Undefined Behavior in safe code (making the API
unsound).
-->
<p>これは本当に明らかに良くないです。残念ながら、ある種の板挟みになっています。
すなわち、毎回のステップで一貫性のある状態を維持することは、膨大なコストが
発生するのです (そして API のあらゆる利点を消してしまうでしょう) 。
一貫性のある状態を維持できないことで、安全なコードで未定義動作を起こしてしまいます (これにより API が
不健全となってしまいます) 。</p>
<!--
So what can we do? Well, we can pick a trivially consistent state: set the Vec's
len to be 0 when we start the iteration, and fix it up if necessary in the
destructor. That way, if everything executes like normal we get the desired
behavior with minimal overhead. But if someone has the *audacity* to
mem::forget us in the middle of the iteration, all that does is *leak even more*
(and possibly leave the Vec in an unexpected but otherwise consistent state).
Since we've accepted that mem::forget is safe, this is definitely safe. We call
leaks causing more leaks a *leak amplification*.
-->
<p>ではどうすればいいのでしょうか? うーん、自明に一貫性のある状態を選択することが出来ます。
すなわち、イテレーションの初めでは Vec の len を 0 に設定し、そしてもし必要ならば、
デストラクタ内で len を修正します。このようにすることで、もしすべてが普通に実行されるなら、
最小限のオーバーヘッドで望まれている振る舞いを得ることが出来ます。
しかし、もし<em>大胆にも</em> mem::forget がイテレーションの真ん中に存在したら、
この関数によって、<em>更に多くのものがリークされます</em> (そして多分 Vec を、
一貫性はあるとしてもユーザが予期しない状態にするでしょう) 。 mem::forget は安全だとして
受け入れたので、このリークは絶対安全です。リークが更に多くのリークを引き起こしてしまうことを、
<em>リークの増幅</em>と呼びます。</p>
<h2><a class="header" href="#rc" id="rc">Rc</a></h2>
<!--
Rc is an interesting case because at first glance it doesn't appear to be a
proxy value at all. After all, it manages the data it points to, and dropping
all the Rcs for a value will drop that value. Leaking an Rc doesn't seem like it
would be particularly dangerous. It will leave the refcount permanently
incremented and prevent the data from being freed or dropped, but that seems
just like Box, right?
-->
<p>Rc は興味深いケースです。なぜなら、ひと目見ただけでは、 Rc がプロキシな値とは全く見えないからです。
結局、 Rc は自身が指しているデータを操作し、その値に対する Rc が全てドロップされることで、
その値もドロップされます。 Rc をリークすることは特に危険のようには見えません。
参照カウントが永遠にインクリメントされたまま、データが解放されたりドロップされるのを
妨害します。けれどもこれは単に Box に似ています。そうですよね?</p>
<!--
Nope.
-->
<p>いいえ。</p>
<!--
Let's consider a simplified implementation of Rc:
-->
<p>では、以下の単純化された Rc の実装を確認しましょう。</p>
<pre><code class="language-rust ignore">struct Rc&lt;T&gt; {
    ptr: *mut RcBox&lt;T&gt;,
}

struct RcBox&lt;T&gt; {
    data: T,
    ref_count: usize,
}

impl&lt;T&gt; Rc&lt;T&gt; {
    fn new(data: T) -&gt; Self {
        unsafe {
            // もし heap::allocate がこのように動作したらよいと思いませんか?
            let ptr = heap::allocate::&lt;RcBox&lt;T&gt;&gt;();
            ptr::write(ptr, RcBox {
                data: data,
                ref_count: 1,
            });
            Rc { ptr: ptr }
        }
    }

    fn clone(&amp;self) -&gt; Self {
        unsafe {
            (*self.ptr).ref_count += 1;
        }
        Rc { ptr: self.ptr }
    }
}

impl&lt;T&gt; Drop for Rc&lt;T&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            (*self.ptr).ref_count -= 1;
            if (*self.ptr).ref_count == 0 {
                // データをドロップしそして解放します
                ptr::read(self.ptr);
                heap::deallocate(self.ptr);
            }
        }
    }
}
</code></pre>
<!--
This code contains an implicit and subtle assumption: `ref_count` can fit in a
`usize`, because there can't be more than `usize::MAX` Rcs in memory. However
this itself assumes that the `ref_count` accurately reflects the number of Rcs
in memory, which we know is false with `mem::forget`. Using `mem::forget` we can
overflow the `ref_count`, and then get it down to 0 with outstanding Rcs. Then
we can happily use-after-free the inner data. Bad Bad Not Good.
-->
<p>このコードは暗黙で微妙な前提を含んでいます。すなわち、 <code>ref_count</code> が <code>usize</code> に
収まるということです。なぜなら、 <code>usize::MAX</code> 個以上の Rc はメモリに存在し得ないからです。
しかしながら、これ自体が <code>ref_count</code> が正確に、メモリ上にある Rc の数を反映しているという
前提の上にあります。ご存知のように、 <code>mem::forget</code> のせいでこれは正しくありません。 <code>mem::forget</code> を
使用することで、 <code>ref_count</code> をオーバーフローさせることが可能です。そして、 Rc が存在していても
<code>ref_count</code> を 0 にすることができます。こうしてめでたく、内部データを解放後に使用することができます。
だめだだめだ、最悪だ。</p>
<!--
This can be solved by just checking the `ref_count` and doing *something*. The
standard library's stance is to just abort, because your program has become
horribly degenerate. Also *oh my gosh* it's such a ridiculous corner case.
-->
<p>これは単に <code>ref_count</code> を確認し、<em>何かを</em>行なうことで解決可能です。
標準ライブラリにおいては、単にアボートします。なぜならプログラムが
ひどく悪化したからです。そして<em>おーまいがっしゅ</em>、これは本当に馬鹿げたコーナーケースなのです。</p>
<h2><a class="header" href="#threadscopedjoinguard" id="threadscopedjoinguard">thread::scoped::JoinGuard</a></h2>
<!--
The thread::scoped API intends to allow threads to be spawned that reference
data on their parent's stack without any synchronization over that data by
ensuring the parent joins the thread before any of the shared data goes out
of scope.
-->
<p>thread::scoped API は、共有されているデータが 1 つでもスコープを抜ける前に、
親がスレッドを join することを保証します。こうすることで、親スレッドのスタック上の
データを同期なしに参照するようなスレッドを生成することが可能になります。</p>
<pre><code class="language-rust ignore">pub fn scoped&lt;'a, F&gt;(f: F) -&gt; JoinGuard&lt;'a&gt;
    where F: FnOnce() + Send + 'a
</code></pre>
<!--
Here `f` is some closure for the other thread to execute. Saying that
`F: Send +'a` is saying that it closes over data that lives for `'a`, and it
either owns that data or the data was Sync (implying `&data` is Send).
-->
<p>ここで <code>f</code> は、他のスレッドで実行する何らかのクロージャです。 <code>F: Send + 'a</code> ということは、 f は <code>'a</code> の長さ
生きるデータを内包します。そしてそのデータを所有するか、データは Sync ということになります (<code>&amp;data</code> が Send であることを示唆します) 。</p>
<!--
Because JoinGuard has a lifetime, it keeps all the data it closes over
borrowed in the parent thread. This means the JoinGuard can't outlive
the data that the other thread is working on. When the JoinGuard *does* get
dropped it blocks the parent thread, ensuring the child terminates before any
of the closed-over data goes out of scope in the parent.
-->
<p>JoinGuard がライフタイムを所有しているため、 JoinGuard は、内包しているデータが
親スレッドで借用されたままの状態にします。これはつまり、 JoinGuard が、もう片方のスレッドが扱っている
データよりも長生きできないことを意味します。 JoinGuard が<em>本当に</em>ドロップされるとき、
JoinGuard は親スレッドをブロックし、内包されているデータのどれか 1 つでも親のスコープを
抜ける前に、子スレッドを確実に終了させます。</p>
<!--
Usage looked like:
-->
<p>使用法は以下のような感じです。</p>
<pre><code class="language-rust ignore">let mut data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
{
    let guards = vec![];
    for x in &amp;mut data {
        // 可変参照をクロージャ内にムーブします。そして、
        // クロージャを別のスレッド上で実行します。クロージャには
        // 可変参照 `x` のライフタイムによる、ライフタイムの制限があります。
        // 値が返される guard には、代わってクロージャのライフタイムが
        // 代入されます。ですから `x` と同じように、 guard も `data` を可変で借用します。
        // これは、 guard がスコープを抜けるまで `data` にアクセスできないことを意味します。
        let guard = thread::scoped(move || {
            *x *= 2;
        });
        // 後の使用に備えて、スレッドのガードを保存します
        guards.push(guard);
    }
    // 全てのガードはここでドロップされましたので、全てのスレッドを強制的に join します
    // (このスレッドは他のスレッドが終了するまでブロックされます) 。
    // スレッドが join されたら、借用は有効ではなくなり、データは
    // 再びこのスレッドからアクセス可能となります。
}
// data は絶対ここで変化します。
</code></pre>
<!--
In principle, this totally works! Rust's ownership system perfectly ensures it!
...except it relies on a destructor being called to be safe.
-->
<p>原則として、これは完全に動作します! Rust の所有権システムが見事にこれを確実に行ないます!
...デストラクタが安全に呼ばれるということに頼っている以外は。</p>
<pre><code class="language-rust ignore">let mut data = Box::new(0);
{
    let guard = thread::scoped(|| {
        // これは良くてもデータ競合を引き起こし、最悪、解放後の使用にもなります。
        *data += 1;
    });
    // guard が忘れられたので、このスレッドをブロックせず、
    // 借用が有効ではなくなります。
    mem::forget(guard);
}
// ですからスコープ内のスレッドが Box にアクセスしようとしているかもしれないし、
// しようとしていないかもしれない最中に Box がここでドロップされてしまいます。
</code></pre>
<!--
Dang. Here the destructor running was pretty fundamental to the API, and it had
to be scrapped in favor of a completely different design.
-->
<p>ちくしょう。デストラクタが実行されるのは API にとってとても大切だったのですが、
全く別の設計上の理由で破棄しなくてはいけなかったのです。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="destructors.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="unwinding.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="destructors.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="unwinding.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
