<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>リファレンス - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="README.html">はじめに</a></li><li><a href="meet-safe-and-unsafe.html"><strong>1.</strong> 安全と危険のご紹介</a></li><li><ul class="section"><li><a href="safe-unsafe-meaning.html"><strong>1.1.</strong> 安全と危険の相互作用</a></li><li><a href="working-with-unsafe.html"><strong>1.2.</strong> Unsafe と連携する</a></li></ul></li><li><a href="data.html"><strong>2.</strong> データレイアウト</a></li><li><ul class="section"><li><a href="repr-rust.html"><strong>2.1.</strong> repr(Rust)</a></li><li><a href="exotic-sizes.html"><strong>2.2.</strong> 奇妙なサイズの型</a></li><li><a href="other-reprs.html"><strong>2.3.</strong> 代替メモリレイアウト</a></li></ul></li><li><a href="ownership.html"><strong>3.</strong> 所有権と生存期間</a></li><li><ul class="section"><li><a href="references.html" class="active"><strong>3.1.</strong> リファレンス</a></li><li><a href="lifetimes.html"><strong>3.2.</strong> Lifetimes</a></li><li><a href="lifetime-mismatch.html"><strong>3.3.</strong> Limits of Lifetimes</a></li><li><a href="lifetime-elision.html"><strong>3.4.</strong> Lifetime Elision</a></li><li><a href="unbounded-lifetimes.html"><strong>3.5.</strong> Unbounded Lifetimes</a></li><li><a href="hrtb.html"><strong>3.6.</strong> Higher-Rank Trait Bounds</a></li><li><a href="subtyping.html"><strong>3.7.</strong> Subtyping and Variance</a></li><li><a href="dropck.html"><strong>3.8.</strong> Drop Check</a></li><li><a href="phantom-data.html"><strong>3.9.</strong> PhantomData</a></li><li><a href="borrow-splitting.html"><strong>3.10.</strong> Splitting Borrows</a></li></ul></li><li><a href="conversions.html"><strong>4.</strong> Type Conversions</a></li><li><ul class="section"><li><a href="coercions.html"><strong>4.1.</strong> Coercions</a></li><li><a href="dot-operator.html"><strong>4.2.</strong> The Dot Operator</a></li><li><a href="casts.html"><strong>4.3.</strong> Casts</a></li><li><a href="transmutes.html"><strong>4.4.</strong> Transmutes</a></li></ul></li><li><a href="uninitialized.html"><strong>5.</strong> Uninitialized Memory</a></li><li><ul class="section"><li><a href="checked-uninit.html"><strong>5.1.</strong> Checked</a></li><li><a href="drop-flags.html"><strong>5.2.</strong> Drop Flags</a></li><li><a href="unchecked-uninit.html"><strong>5.3.</strong> Unchecked</a></li></ul></li><li><a href="obrm.html"><strong>6.</strong> Ownership Based Resource Management</a></li><li><ul class="section"><li><a href="constructors.html"><strong>6.1.</strong> Constructors</a></li><li><a href="destructors.html"><strong>6.2.</strong> Destructors</a></li><li><a href="leaking.html"><strong>6.3.</strong> Leaking</a></li></ul></li><li><a href="unwinding.html"><strong>7.</strong> Unwinding</a></li><li><ul class="section"><li><a href="exception-safety.html"><strong>7.1.</strong> Exception Safety</a></li><li><a href="poisoning.html"><strong>7.2.</strong> Poisoning</a></li></ul></li><li><a href="concurrency.html"><strong>8.</strong> Concurrency</a></li><li><ul class="section"><li><a href="races.html"><strong>8.1.</strong> Races</a></li><li><a href="send-and-sync.html"><strong>8.2.</strong> Send and Sync</a></li><li><a href="atomics.html"><strong>8.3.</strong> Atomics</a></li></ul></li><li><a href="vec.html"><strong>9.</strong> Implementing Vec</a></li><li><ul class="section"><li><a href="vec-layout.html"><strong>9.1.</strong> Layout</a></li><li><a href="vec-alloc.html"><strong>9.2.</strong> Allocating</a></li><li><a href="vec-push-pop.html"><strong>9.3.</strong> Push and Pop</a></li><li><a href="vec-dealloc.html"><strong>9.4.</strong> Deallocating</a></li><li><a href="vec-deref.html"><strong>9.5.</strong> Deref</a></li><li><a href="vec-insert-remove.html"><strong>9.6.</strong> Insert and Remove</a></li><li><a href="vec-into-iter.html"><strong>9.7.</strong> IntoIter</a></li><li><a href="vec-raw.html"><strong>9.8.</strong> RawVec</a></li><li><a href="vec-drain.html"><strong>9.9.</strong> Drain</a></li><li><a href="vec-zsts.html"><strong>9.10.</strong> Handling Zero-Sized Types</a></li><li><a href="vec-final.html"><strong>9.11.</strong> Final Code</a></li></ul></li><li><a href="arc-and-mutex.html"><strong>10.</strong> Implementing Arc and Mutex</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <!--
# References
-->
<a class="header" href="#リファレンス" name="リファレンス"><h1>リファレンス</h1></a>
<!--
This section gives a high-level view of the memory model that *all* Rust
programs must satisfy to be correct. Safe code is statically verified
to obey this model by the borrow checker. Unsafe code may go above
and beyond the borrow checker while still satisfying this model. The borrow
checker may also be extended to allow more programs to compile, as long as
this more fundamental model is satisfied.
-->
<p>このセクションでは、<em>すべての</em> Rust プログラムが満たさなくてはならないメモリモデルを
ざっくりと見ていきます。
安全なコードは、ボローチェッカーによってこのモデルを満たしていることが静的に検証されます。
危険なコードは、ボローチェッカーの裏をかくかもしれませんが、このモデルを満たします。
この基本的なモデルを満たしている限り、より多くのプログラムがコンパイルに通るように
ボローチェッカーを拡張することも可能です。</p>
<!--
There are two kinds of reference:
-->
<p>リファレンスには 2 種類があります。</p>
<!--
* Shared reference: `&`
* Mutable reference: `&mut`
-->
<ul>
<li>共有リファレンス: <code>&amp;</code></li>
<li>可変リファレンス: <code>&amp;mut</code></li>
</ul>
<!--
Which obey the following rules:
-->
<p>リファレンスは次のルールに従います。</p>
<!--
* A reference cannot outlive its referent
* A mutable reference cannot be aliased
-->
<ul>
<li>リファレンスの生存期間が、参照先の生存期間より長くなることはできません。</li>
<li>可変リファレンスは、別名を持つことができません。</li>
</ul>
<!--
That's it. That's the whole model. Of course, we should probably define
what *aliased* means. To define aliasing, we must define the notion of
*paths* and *liveness*.
-->
<p>これだけです。これがモデルの全てです。
もちろん、<em>別名を持つ</em>とはどういうことかを定義するべきでしょう。
別名を定義するには、<em>パス</em>と<em>生存</em>という概念を定義しなくてはなりません。</p>
<!--
**NOTE: The model that follows is generally agreed to be dubious and have
issues. It's ok-ish as an intuitive model, but fails to capture the desired
semantics. We leave this here to be able to use notions introduced here in later
sections. This will be significantly changed in the future. TODO: do that.**
-->
<p><strong>これから説明するモデルは疑わしく、問題があるという点に、多くの人が同意しています。
直感的なモデルとして使うにはたぶん大丈夫ですが、望むような意味論を捉えることはできないでしょう。
ここではその点にこだわらず、のちの節で使うための概念を紹介することにします。
将来的にはこの構成は大きく変わるでしょう。TODO: 構成を変える。</strong></p>
<!--
# Paths
-->
<a class="header" href="#パス" name="パス"><h1>パス</h1></a>
<!--
If all Rust had were values (no pointers), then every value would be uniquely
owned by a variable or composite structure. From this we naturally derive a
*tree* of ownership. The stack itself is the root of the tree, with every
variable as its direct children. Each variable's direct children would be their
fields (if any), and so on.
-->
<p>もし、Rust が扱うのが値だけ（ポインタはない）であれば、
すべての値はただ一つの変数か複合型に所有されることになります。
ここから所有権の<em>木構造</em>が自然に導かれます。
スタック自信が木のルートになり、変数が直接の子になります。
変数がフィールドを持つのであれば、それは変数の直接の子になるでしょう。</p>
<!--
From this view, every value in Rust has a unique *path* in the tree of
ownership. Of particular interest are *ancestors* and *descendants*: if `x` owns
`y`, then `x` is an ancestor of `y`, and `y` is a descendant of `x`. Note
that this is an inclusive relationship: `x` is a descendant and ancestor of
itself.
-->
<p>このように見ると、Rust におけるすべての値は、所有権を表す木構造の<em>パス</em>を持つことになります。
特に重要なのは、<em>先祖</em>と<em>子孫</em>です。<code>x</code> が <code>y</code> が所有しているとき、<code>x</code> は <code>y</code> の先祖で、
<code>y</code> は <code>x</code> の子孫です。この関係は内包的であることに注意してください。
<code>x</code> はそれ自身の先祖であり子孫です。</p>
<!--
We can then define references as simply *names* for paths. When you create a
reference, you're declaring that an ownership path exists to this address
of memory.
-->
<p>リファレンスは、単純にパスの名前と定義できます。
リファレンスを作成するということは、あるメモリアドレスに所有権の
パスが存在することを宣言するということです。</p>
<!--
Tragically, plenty of data doesn't reside on the stack, and we must also
accommodate this. Globals and thread-locals are simple enough to model as
residing at the bottom of the stack (though we must be careful with mutable
globals). Data on the heap poses a different problem.
-->
<p>悲惨なことに、スタックに存在しないデータはたくさんあり、この点も考慮しなくてはいけません。
グローバル変数やスレッドローカル変数は、単純にスタックの底に存在すると考えることができます。
（ただし、可変なグローバル変数に注意が必要です）。
ヒープにあるデータは別の問題を提起します。</p>
<!--
If all Rust had on the heap was data uniquely owned by a pointer on the stack,
then we could just treat such a pointer as a struct that owns the value on the
heap. Box, Vec, String, and HashMap, are examples of types which uniquely
own data on the heap.
-->
<p>もし、ヒープにある各データが、スタック上のただ一つのポインタに所有されているのだとすると、
そういうポインタを、ヒープ上の値を所有する構造体だと解釈すればよいだけです。
ヒープ上のデータを独占的に所有する型の例としては、Box, Vec, String, HashMap があります。</p>
<!--
Unfortunately, data on the heap is not *always* uniquely owned. Rc for instance
introduces a notion of *shared* ownership. Shared ownership of a value means
there is no unique path to it. A value with no unique path limits what we can do
with it.
-->
<p>残念ながら、ヒープ上のデータは<em>常に</em>独占的に所有されているわけではありません。
例えば Rc によって、<em>共有</em>所有権という概念がでてきます。
値が共有所有されると、その値への一意なパスが存在しないことになります。
一意なパスが存在しない値によって、いろいろな制約が発生します。</p>
<!--
In general, only shared references can be created to non-unique paths. However
mechanisms which ensure mutual exclusion may establish One True Owner
temporarily, establishing a unique path to that value (and therefore all
its children). If this is done, the value may be mutated. In particular, a
mutable reference can be taken.
-->
<p>一般に、一意ではないパスを参照できるのは、共有リファレンスだけです。
しかし、相互排他を保証するメカニズムがあれば、一時的にその値（とそしてすべての子ども）への唯一のパスを確立し、
「唯一の真の所有者」を確立できるかもしれません。
もしこれが可能なら、その値を変更できるかもしれません。
とくに、可変リファレンスを取ることができるようになります。</p>
<!--
The most common way to establish such a path is through *interior mutability*,
in contrast to the *inherited mutability* that everything in Rust normally uses.
Cell, RefCell, Mutex, and RWLock are all examples of interior mutability types.
These types provide exclusive access through runtime restrictions.
-->
<p>そのようなパスを確立するために、Rust で標準的に使われる<em>継承可変性</em>ではなく、
<em>内部可変性</em>がよく使われます。
内部可変性を持った型の例としては、Cell, RefCell, Mutex, RWLock があります。
これらの型は、実行時の制約を用いて、排他的アクセスを提供します。</p>
<!--
An interesting case of this effect is Rc itself: if an Rc has refcount 1,
then it is safe to mutate or even move its internals. Note however that the
refcount itself uses interior mutability.
-->
<p>この効果を使った興味深い例が Rc 地震です。もし Rc の参照カウントが 1 なら、
内部状態を変更したり、move したりしても安全です。
refcount 自体も内部可変性を使っています。</p>
<!--
In order to correctly communicate to the type system that a variable or field of
a struct can have interior mutability, it must be wrapped in an UnsafeCell. This
does not in itself make it safe to perform interior mutability operations on
that value. You still must yourself ensure that mutual exclusion is upheld.
-->
<p>変数や構造体のフィールドに内部可変性があることを型システムに正しく伝えるには、
UnsafeCell を使います。
UnsafeCell 自身は、その値に対して内部可変の操作を安全にはしません。
正しく相互排他していることを、あなた自身が保証しなくてはなりません。</p>
<!--
# Liveness
-->
<a class="header" href="#生存性" name="生存性"><h1>生存性</h1></a>
<!--
Note: Liveness is not the same thing as a *lifetime*, which will be explained
in detail in the next section of this chapter.
-->
<p>生存性 (liveness) は、この章の次の節でで詳しく説明する <em>生存期間 (lifetime)</em> とは違うことに注意してください。</p>
<!--
Roughly, a reference is *live* at some point in a program if it can be
dereferenced. Shared references are always live unless they are literally
unreachable (for instance, they reside in freed or leaked memory). Mutable
references can be reachable but *not* live through the process of *reborrowing*.
-->
<p>大雑把に言うと、リファレンスをデリファレンスできるとき、
そのリファレンスは、プログラム中のある時点で <em>生存している</em> といえます。
共有リファレンスは、文字通り到達不可能な場合（たとえば、解放済みメモリやリークしてるメモリに
存在している場合）を除いて、常に生存しています。
可変リファレンスには、<em>又貸し</em>というプロセスがあるので、到達できても生存して<em>いない</em>ことがあります。</p>
<!--
A mutable reference can be reborrowed to either a shared or mutable reference to
one of its descendants. A reborrowed reference will only be live again once all
reborrows derived from it expire. For instance, a mutable reference can be
reborrowed to point to a field of its referent:
-->
<p>可変リファレンスは、その子孫を他の共有リファレンスまたは可変リファレンスに又貸しすることができます。
又貸ししたリファレンスは、派生したすべたの又貸しの有効期限が切れると、ふたたび生存することになります。
たとえば、可変リファレンスは、その参照先の一つのフィールドを指すリファレンスを又貸しすることができます。</p>
<pre><code class="language-rust">let x = &amp;mut (1, 2);
{
    // x のフィールドを又借りする
    let y = &amp;mut x.0;
    // この時点で y は生存しているが、x は生存していない
    *y = 3;
}
// y がスコープ外に出たので、x がふたたび生存中になる
*x = (5, 7);
</code></pre>
<!--
It is also possible to reborrow into *multiple* mutable references, as long as
they are *disjoint*: no reference is an ancestor of another. Rust
explicitly enables this to be done with disjoint struct fields, because
disjointness can be statically proven:
-->
<p><em>複数の</em>可変リファレンスに又貸しすることも可能ですが、その複数のリファレンスは互いに素でなくてはいけません。
つまり、どのリファレンスも他のリファレンスの先祖であってはいけないということです。
Rust は、構造体のフィールドが互いに素であることを静的に証明できるので、
フィールドの又貸しが可能です。</p>
<pre><code class="language-rust">let x = &amp;mut (1, 2);
{
    // x を 2 つの互いに素なフィールドに又貸しする
    let y = &amp;mut x.0;
    let z = &amp;mut x.1;

    // y と z は生存しているが、x は生存していない
    *y = 3;
    *z = 4;
}
// y と z がスコープ外に出たので、x がふたたび生存中になる
*x = (5, 7);
</code></pre>
<!--
However it's often the case that Rust isn't sufficiently smart to prove that
multiple borrows are disjoint. *This does not mean it is fundamentally illegal
to make such a borrow*, just that Rust isn't as smart as you want.
-->
<p>ただし、多くの場合 Rust は十分に賢くないので、複数の借り手が互いに素であることを証明できません。
<em>これはそのような又貸しが禁じられているという意味ではなく</em>、
単に Rust が期待するほど賢くないというだけです。</p>
<!--
To simplify things, we can model variables as a fake type of reference: *owned*
references. Owned references have much the same semantics as mutable references:
they can be re-borrowed in a mutable or shared manner, which makes them no
longer live. Live owned references have the unique property that they can be
moved out of (though mutable references *can* be swapped out of). This power is
only given to *live* owned references because moving its referent would of
course invalidate all outstanding references prematurely.
-->
<p>話を単純にするために、変数をリファレンス型の一種、<em>所有中</em>リファレンス、と仮定してみましょう。
所有中リファレンスは、可変リファレンスとほとんど同じ意味を持ちます。
可変リファレンスまたは共有リファレンスに又貸しでき、それによって生存中ではなくなります。
生存中の所有中リファレンスは、値を解放（move out）できるという特殊な性質があります
（とはいえ、可変リファレンスは値をスワップアウトできますが）。
この能力は、<em>生存中の</em> 所有中リファレンスのみに与えられています。
そうでなければ、早すぎるタイミングでその他のリファレンスを無効にすることになります。</p>
<!--
As a local lint against inappropriate mutation, only variables that are marked
as `mut` can be borrowed mutably.
-->
<p>不適切な値の変更を lint が検出するので、<code>mut</code> とマークされた変数だけが変更可能なように貸し出されます。</p>
<!--
It is interesting to note that Box behaves exactly like an owned reference. It
can be moved out of, and Rust understands it sufficiently to reason about its
paths like a normal variable.
-->
<p>Box がまさに所有中リファレンスのように振る舞うというおとを覚えておくと良いでしょう。
Box は値を解放することができ、変数が解放された時と同様に Rust はそのパスについて推論するための
十分な情報を持っています。</p>
<!--
# Aliasing
-->
<a class="header" href="#別名付け" name="別名付け"><h1>別名付け</h1></a>
<!--
With liveness and paths defined, we can now properly define *aliasing*:
-->
<p>生存性とパスを定義したので、ようやく<em>別名</em>を適切に定義できます。</p>
<!--
**A mutable reference is aliased if there exists another live reference to one
of its ancestors or descendants.**
-->
<p><strong>可変リファレンスは、その先祖か子孫に他のリファレンスが存在している時、別名を持つといいます。</strong></p>
<!--
(If you prefer, you may also say the two live references alias *each other*.
This has no semantic consequences, but is probably a more useful notion when
verifying the soundness of a construct.)
-->
<p>（二つの生存中のリファレンスが互いの別名になっている、と言うこともできます。
意味上の違いは特にありませんが、プログラムの構造の健全性を検証する時には、
この考え方の方がわかりやすいでしょう。）</p>
<!--
That's it. Super simple right? Except for the fact that it took us two pages to
define all of the terms in that definition. You know: Super. Simple.
-->
<p>これだけです。すげーわかりやすいですよね? この定義に必要なすべての用語を定義するのに 2 ページ必要に
なりましたが・・・。すごく、分かりやすい。でしょ?</p>
<!--
Actually it's a bit more complicated than that. In addition to references, Rust
has *raw pointers*: `*const T` and `*mut T`. Raw pointers have no inherent
ownership or aliasing semantics. As a result, Rust makes absolutely no effort to
track that they are used correctly, and they are wildly unsafe.
-->
<p>実際には、もう少し複雑です。リファレンスに加えて Rust には<em>生のポインタ</em>もあります。
<code>*const T</code> と <code>*mut T</code> のことです。
生のポインタには、継承可能な所有権も別名という概念もありません。
そのため、Rust は生のポインタを追跡する努力を一切しませんし、名前のポインタは極めて危険です。</p>
<!--
**It is an open question to what degree raw pointers have alias semantics.
However it is important for these definitions to be sound that the existence of
a raw pointer does not imply some kind of live path.**
-->
<p><strong>生のポインタが別名という意味をどの程度持っているのか、というのはまだ答えの出てない問題です。
しかし、この節で出てきた定義が健全であるためには、生のポインタを使うとある種の生存パスが
わからなくなるということ重要です。</strong></p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="ownership.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="lifetimes.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="ownership.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="lifetimes.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
